From a598bdbaaa49867dfefca3f5a7b38e9315116d70 Mon Sep 17 00:00:00 2001
From: lanshh <lsh@rock-chips.com>
Date: Mon, 24 Jul 2017 09:07:56 +0800
Subject: [PATCH] for panorama camera debug

Change-Id: I33b3cfdec43e5745c618b15dcba39f81b037bb7b
Signed-off-by: lanshh <lsh@rock-chips.com>
---
 arch/arm/boot/dts/Makefile                         |    3 +-
 arch/arm/boot/dts/rv1108-camb-v13.dtsi             |   45 +-
 arch/arm/boot/dts/rv1108-panorama.dts              |  660 +++++++++
 arch/arm/boot/dts/rv1108.dtsi                      |    8 +-
 drivers/base/firmware_class.c                      |    3 +-
 .../soc_camera/rockchip/ov4689_v4l2-i2c-subdev.c   |   19 +-
 .../i2c/soc_camera/rockchip/rk_camera_module.c     |    3 +-
 drivers/media/platform/Makefile                    |    1 +
 drivers/media/platform/preisp_driver/Makefile      |   11 +
 drivers/media/platform/preisp_driver/ap-i2c.c      |   72 +
 drivers/media/platform/preisp_driver/ap-i2c.h      |   21 +
 .../preisp_driver/cif-preisp-dummy-rv1108.c        |   45 +
 .../preisp_driver/cif-preisp-dummy-rv1108.h        |   30 +
 .../platform/preisp_driver/cif-preisp-pltfrm.c     |  147 ++
 .../platform/preisp_driver/cif-preisp-pltfrm.h     |   61 +
 .../platform/preisp_driver/cif-preisp-rv1108.c     |   52 +
 drivers/media/platform/preisp_driver/cif-preisp.c  |  670 +++++++++
 drivers/media/platform/preisp_driver/cif-preisp.h  |  335 +++++
 .../media/platform/preisp_driver/cif-preisp.rar    |  Bin 0 -> 3437 bytes
 .../platform/preisp_driver/cif-preisp_img_src.c    |  226 +++
 .../platform/preisp_driver/cif-preisp_img_src.h    |   90 ++
 .../preisp_driver/cif-preisp_img_src_ops.h         |   98 ++
 .../preisp_driver/cif-preisp_img_src_v4l2-subdev.c |  520 +++++++
 .../preisp_driver/cif-preisp_img_src_v4l2-subdev.h |   72 +
 drivers/media/platform/preisp_driver/isp-fw.c      |  149 ++
 drivers/media/platform/preisp_driver/isp-fw.h      |   83 ++
 drivers/media/platform/preisp_driver/msg-queue.c   |  468 ++++++
 drivers/media/platform/preisp_driver/msg-queue.h   |  243 ++++
 .../media/platform/preisp_driver/spi-rkpreisp.c    | 1524 ++++++++++++++++++++
 .../media/platform/preisp_driver/spi-rkpreisp.h    |  183 +++
 drivers/media/platform/preisp_driver/spi2apb.c     |  528 +++++++
 drivers/media/platform/preisp_driver/spi2apb.h     |  196 +++
 drivers/media/platform/rk-isp11/Makefile           |    2 +-
 drivers/media/platform/rk-isp11/cif_isp11.c        |   10 +-
 .../media/platform/rk-isp11/cif_isp11_img_src.c    |    3 +-
 .../platform/rk-isp11/cif_isp11_img_src_ops.h      |   31 +-
 .../rk-isp11/cif_isp11_img_src_spi-subdev.c        |  255 ++++
 .../rk-isp11/cif_isp11_img_src_spi-subdev.h        |  122 ++
 drivers/media/platform/rk-isp11/cif_isp11_pltfrm.c |   42 +-
 drivers/media/platform/rk-isp11/cif_isp11_rv1108.c |   12 +-
 drivers/media/platform/rk-isp11/cif_isp11_v4l2.c   |    9 +-
 drivers/of/base.c                                  |    3 +-
 drivers/of/platform.c                              |   16 +
 include/linux/of_platform.h                        |    2 +
 44 files changed, 7004 insertions(+), 69 deletions(-)
 create mode 100644 arch/arm/boot/dts/rv1108-panorama.dts
 create mode 100644 drivers/media/platform/preisp_driver/Makefile
 create mode 100644 drivers/media/platform/preisp_driver/ap-i2c.c
 create mode 100644 drivers/media/platform/preisp_driver/ap-i2c.h
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.c
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.h
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp-pltfrm.c
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp-pltfrm.h
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp-rv1108.c
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp.c
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp.h
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp.rar
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp_img_src.c
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp_img_src.h
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp_img_src_ops.h
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.c
 create mode 100644 drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.h
 create mode 100644 drivers/media/platform/preisp_driver/isp-fw.c
 create mode 100644 drivers/media/platform/preisp_driver/isp-fw.h
 create mode 100644 drivers/media/platform/preisp_driver/msg-queue.c
 create mode 100644 drivers/media/platform/preisp_driver/msg-queue.h
 create mode 100644 drivers/media/platform/preisp_driver/spi-rkpreisp.c
 create mode 100644 drivers/media/platform/preisp_driver/spi-rkpreisp.h
 create mode 100644 drivers/media/platform/preisp_driver/spi2apb.c
 create mode 100644 drivers/media/platform/preisp_driver/spi2apb.h
 create mode 100644 drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.c
 create mode 100644 drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.h

diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 221aed7..e8d92d4 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -203,7 +203,8 @@ dtb-$(CONFIG_ARCH_ROCKCHIP) += \
 	rv1108-ipc-emmc-v10.dtb \
 	rv1108-ketong.dtb \
 	rv1108-minievb-v10.dtb \
-	rv1108-sportdv-v10.dtb
+	rv1108-sportdv-v10.dtb \
+    rv1108-panorama.dtb
 dtb-$(CONFIG_ARCH_U8500) += snowball.dtb \
 	hrefprev60.dtb \
 	hrefv60plus.dtb \
diff --git a/arch/arm/boot/dts/rv1108-camb-v13.dtsi b/arch/arm/boot/dts/rv1108-camb-v13.dtsi
index bbc8d27..fa49ed8 100644
--- a/arch/arm/boot/dts/rv1108-camb-v13.dtsi
+++ b/arch/arm/boot/dts/rv1108-camb-v13.dtsi
@@ -1,48 +1,17 @@
-
 camera0: camera-module@36 {
 	status = "okay";
-	compatible = "omnivision,ov2710-v4l2-i2c-subdev";
-	reg = <0x36>;
-	device_type = "v4l2-i2c-subdev";
-	clocks = <&clk_cif_out>;
-	clock-names = "clk_cif_out";
-	pinctrl-names = "rockchip,camera_default", "rockchip,camera_sleep";
-	pinctrl-0 = <&cif_dvp_clk_out>;
-	pinctrl-1 = <&cif_dvp_clk_out_sleep>;
-	rockchip,pd-gpio = <&gpio3 GPIO_B0 GPIO_ACTIVE_HIGH>;
-	rockchip,pwr-gpio = <&gpio3 GPIO_B5 GPIO_ACTIVE_HIGH>;
-	rockchip,rst-gpio = <&gpio3 GPIO_D1 GPIO_ACTIVE_LOW>;
-	rockchip,camera-module-mclk-name = "clk_cif_out";
-	rockchip,camera-module-facing = "back";
-	rockchip,camera-module-name = "LA6110PA";
-	rockchip,camera-module-len-name = "YM6011P";
-	rockchip,camera-module-fov-h = "128";
-	rockchip,camera-module-fov-v = "55.7";
-	rockchip,camera-module-orientation = <0>;
-	rockchip,camera-module-iq-flip = <0>;
-	rockchip,camera-module-iq-mirror = <0>;
-	rockchip,camera-module-flip = <0>;
-	rockchip,camera-module-mirror = <0>;
-	/* resolution.w, resolution.h, defrect.left, defrect.top, defrect.w, defrect.h */
-	rockchip,camera-module-defrect0 = <1920 1080 0 0 1920 1080>;
-	rockchip,camera-module-flash-support = <0>;
-	rockchip,camera-module-mipi-dphy-index = <0>;
-};
-
-camera1: camera-module@36-1 {
-	status = "okay";
 	compatible = "omnivision,ov4689-v4l2-i2c-subdev";
 	reg = <0x36>;
 	device_type = "v4l2-i2c-subdev";
-	clocks = <&clk_cif_out>;
-	clock-names = "clk_cif_out";
+	clocks = <&clk_mipicsi_out>;
+	clock-names = "clk_mipicsi_out";
 	pinctrl-names = "rockchip,camera_default", "rockchip,camera_sleep";
 	pinctrl-0 = <&cif_dvp_clk_out>;
 	pinctrl-1 = <&cif_dvp_clk_out_sleep>;
 	rockchip,pd-gpio = <&gpio3 GPIO_B0 GPIO_ACTIVE_LOW>;
-	rockchip,pwr-gpio = <&gpio3 GPIO_B5 GPIO_ACTIVE_HIGH>;
+	rockchip,pwr-gpio = <&gpio0 GPIO_C3 GPIO_ACTIVE_HIGH>;
 	rockchip,rst-gpio = <&gpio3 GPIO_D1 GPIO_ACTIVE_LOW>;
-	rockchip,camera-module-mclk-name = "clk_cif_out";
+	rockchip,camera-module-mclk-name = "clk_mipicsi_out";
 	rockchip,camera-module-facing = "back";
 	rockchip,camera-module-name = "LA6111PA";
 	rockchip,camera-module-len-name = "YM6011P";
@@ -60,7 +29,7 @@ camera1: camera-module@36-1 {
 };
 
 camera2: camera-module@1a {
-	status = "okay";
+	status = "disabled";
 	compatible = "sony,imx323-v4l2-i2c-subdev";
 	reg = <0x1a>;
 	device_type = "v4l2-i2c-subdev";
@@ -92,7 +61,7 @@ camera2: camera-module@1a {
 };
 
 camera3: camera-module@60 {
-	status = "okay";
+	status = "disabled";
 	compatible = "omnivision,ov7251-bw-v4l2-i2c-subdev";
 	reg = <0x60>;
 	device_type = "v4l2-i2c-subdev";
@@ -120,7 +89,7 @@ camera3: camera-module@60 {
 };
 
 camera4: camera-module@1a-1 {
-	status = "okay";
+	status = "disabled";
 	compatible = "sony,imx291-v4l2-i2c-subdev";
 	reg = <0x1a>;
 	device_type = "v4l2-i2c-subdev";
diff --git a/arch/arm/boot/dts/rv1108-panorama.dts b/arch/arm/boot/dts/rv1108-panorama.dts
new file mode 100644
index 0000000..ac95c77
--- /dev/null
+++ b/arch/arm/boot/dts/rv1108-panorama.dts
@@ -0,0 +1,660 @@
+/*
+ * Copyright (c) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ *
+ * This file is dual-licensed: you can use it either under the terms
+ * of the GPL or the X11 license, at your option. Note that this dual
+ * licensing only applies to this file, and not this project as a
+ * whole.
+ *
+ *  a) This file is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This file is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ * Or, alternatively,
+ *
+ *  b) Permission is hereby granted, free of charge, to any person
+ *     obtaining a copy of this software and associated documentation
+ *     files (the "Software"), to deal in the Software without
+ *     restriction, including without limitation the rights to use,
+ *     copy, modify, merge, publish, distribute, sublicense, and/or
+ *     sell copies of the Software, and to permit persons to whom the
+ *     Software is furnished to do so, subject to the following
+ *     conditions:
+ *
+ *     The above copyright notice and this permission notice shall be
+ *     included in all copies or substantial portions of the Software.
+ *
+ *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ *     EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
+ *     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ *     NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+ *     HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ *     WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ *     FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ *     OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+/dts-v1/;
+
+#include "rv1108.dtsi"
+//#include "lcd-ili9806e_mipi.dtsi" /* dispaly board v10 v11 */
+//#include "lcd-e555hbm2_mipi.dtsi" /* display board v20*/
+//#include "lcd-ili9807_mipi.dtsi" /* display board v30 */
+#include "lcd_dummy_mipi.dtsi" /* dummy mipi for rv1108 */
+#include "dt-bindings/suspend/rockchip-pm.h"
+
+/ {
+	model = "Rockchip RV1108 IPC MAINBOARD V10";
+	compatible = "rockchip,rv1108-ipc-v10", "rockchip,rv1108";
+
+	memory {
+		device_type = "memory";
+		reg = <0x60000000 0x08000000>;
+	};
+
+	fiq-debugger {
+		status = "okay";
+		rockchip,serial-id = <2>;
+		pinctrl-0 = <&uart2m0_xfer>;
+	};
+
+	rockchip_suspend: rockchip_suspend {
+		rockchip,ctrbits = <
+			(0
+			|RKPM_CTR_GTCLKS
+			|RKPM_CTR_PLLS
+			/*|RKPM_CTR_ARMOFF_LPMD*/
+			|RKPM_CTR_ARMLOGDP_LPMD
+			/*|RKPM_CTR_IDLESRAM_MD*/
+			|RKPM_CTR_DDR
+			|RKPM_CTR_PMIC
+			/*|RKPM_CTR_BUS_IDLE*/
+			|RKPM_CTR_SYSCLK_32K
+			)
+			>;
+		rockchip,pmic-suspend_gpios = <0>;
+	};
+
+	chosen {
+		bootargs = "user_debug=31 rockchip_jtag noinitrd root=/dev/mtdblock3 rootfstype=squashfs";
+	};
+
+	ion {
+		compatible = "rockchip,ion";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		/* memory region for dsp pool, start from 0x62000000 */
+		dsp {
+			compatible = "rockchip,ion-heap";
+			rockchip,ion_heap = <2>;
+			reg = <0x62000000 0x100000>; /* 1MB@32M */
+		};
+		ion_cma: rockchip,ion-heap@4 { /* CMA HEAP */
+			compatible = "rockchip,ion-heap";
+			rockchip,ion_heap = <4>;
+			reg = <0x00000000 0x04400000>; /* 68MB */
+		};
+		rockchip,ion-heap@0 { /* VMALLOC HEAP */
+			compatible = "rockchip,ion-heap";
+			rockchip,ion_heap = <0>;
+		};
+	};
+
+	io-domains {
+		compatible = "rockchip,rv1108-io-voltage-domain";
+		rockchip,grf = <&grf>;
+		rockchip,pmugrf = <&pmugrf>;
+
+		/* GRF_IO_VSEL */
+		status = "okay";
+		vccio1-supply = <&rk805_ldo2_reg>;
+		vccio2-supply = <&rk805_ldo2_reg>;
+		vccio3-supply = <&rk805_dcdc4_reg>;
+		vccio5-supply = <&rk805_ldo2_reg>;
+
+		/* PMU_GRF_IO_VSEL */
+		pmu-supply = <&rk805_dcdc4_reg>;
+	};
+
+	/* pmic_sleep */
+	gpio_poweroff {
+		compatible = "gpio-poweroff";
+		gpios = <&gpio0 GPIO_B5 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	wireless-wlan {
+		compatible = "wlan-platdata";
+		wifi_chip_type = "rtl8189fs";
+		sdio_vref = <0>;
+		WIFI,poweren_gpio = <&gpio0 GPIO_A2 GPIO_ACTIVE_HIGH>;
+		WIFI,host_wake_irq = <&gpio0 GPIO_A3 GPIO_ACTIVE_HIGH>;
+		status = "okay";
+	};
+
+	rockchip_audio {
+		compatible = "rockchip,rv1108-audio";
+		dais {
+			dai0 {
+				audio-codec = <&codec>;
+				audio-controller = <&i2s1>;
+				format = "i2s";
+			};
+		};
+	};
+
+	motor_1 {
+		compatible = "motor-gpio";
+		gpios = <&gpio0 GPIO_A4 GPIO_ACTIVE_LOW>,
+				<&gpio0 GPIO_A5 GPIO_ACTIVE_LOW>,
+				<&gpio0 GPIO_A6 GPIO_ACTIVE_LOW>,
+				<&gpio0 GPIO_A7 GPIO_ACTIVE_LOW>;
+		rockchip,motor-id = <1>;
+		status = "disabled";
+	};
+
+	motor_2 {
+		compatible = "motor-gpio";
+		gpios = <&gpio0 GPIO_B6 GPIO_ACTIVE_LOW>,
+				<&gpio0 GPIO_B0 GPIO_ACTIVE_LOW>,
+				//<&gpio0 GPIO_C3 GPIO_ACTIVE_LOW>,
+				<&gpio0 GPIO_C5 GPIO_ACTIVE_LOW>;
+		rockchip,motor-id = <2>;
+		status = "disabled";
+	};
+
+	ipc_leds {
+		compatible = "gpio-leds";
+		led0 {
+			label = "led0";
+			gpios = <&rk805 0 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "blink";
+		};
+		led1 {
+			label = "led1";
+			gpios = <&rk805 1 GPIO_ACTIVE_LOW>;
+			default-state = "off";
+			linux,default-trigger = "blink";
+		};
+	};
+};
+
+/*
+ * clk_mac_pll can be selected from apll/gpll.
+ *
+ * to use one of these, we should modify
+ * 'rockchip,clocks-init-parent' and
+ * 'rockchip,clocks-init-rate' as follows:
+ *
+ * from apll:
+ * 1, <&clk_mac_pll &clk_apll>;
+ *
+ * from gpll:
+ * 1, <&clk_mac_pll &clk_gpll>;
+ * 2, <&clk_gpll 1200000000>
+ *
+ * note:
+ * if gpll use 1200Mhz, hdmi function is unable to used
+ * and should be disabled.
+ */
+&rockchip_clocks_init {
+	rockchip,clocks-init-parent =
+		<&aclk_bus_pre &clk_gpll>, <&aclk_peri &clk_gpll>,
+		<&clk_emmc &clk_gpll>, <&clk_sdio &clk_gpll>,
+		<&hdmiphy &hdmiphy_pll>, <&usb480m &usbphy_480m>,
+		<&clk_mac_pll &clk_apll>;
+	rockchip,clocks-init-rate =
+		<&clk_gpll 1188000000>, <&clk_core 800000000>,
+		<&clk_dsp 396000000>, <&aclk_bus_pre 150000000>,
+		<&hclk_bus_pre 150000000>, <&pclk_bus_pre 75000000>,
+		<&aclk_peri 150000000>, <&hclk_peri 150000000>,
+		<&pclk_peri 75000000>, <&aclk_vio0_pre 300000000>,
+		<&aclk_vio1_pre 300000000>, <&hclk_vio_pre 75000000>,
+		<&pclk_vio_pre 75000000>, <&aclk_rkvdec_pre 300000000>,
+		<&aclk_vpu_pre 300000000>, <&clk_hevc_cabac 300000000>,
+		<&clk_hevc_core 300000000>, <&aclk_rkvenc_pre 300000000>,
+		<&clk_venc_core 300000000>, <&clk_crypto 150000000>,
+		<&clk_nandc 150000000>, <&clk_i2s0_pll 594000000>,
+		<&clk_i2s1_pll 594000000>, <&clk_i2s2_pll 594000000>,
+		<&clk_uart0_pll 297000000>, <&clk_uart1_pll 297000000>,
+		<&clk_uart2_pll 297000000>, <&clk_rga 300000000>;
+};
+
+&clk_core_dvfs_table {
+
+	operating-points = <
+		/* KHz	  uV */
+		408000 1000000
+		600000 1000000
+		816000 1000000
+		1008000 1150000
+		>;
+	status = "disabled";
+};
+
+&watchdog {
+	status = "okay";
+	rockchip,timeout = <5>;
+	rockchip,atboot = <0>;
+};
+
+&adc {
+	status = "okay";
+
+	light_sensor0: light_sensor {
+		compatible = "rockchip,light_sensor";
+		io-channels = <&adc 2>;
+	};
+
+	key0 {
+		compatible = "rockchip,key";
+		io-channels = <&adc 0>;
+		adc-drift = <45>;
+
+		tab-key {
+			linux,code = <15>;
+			label = "tab";
+			rockchip,adc_value = <685>;
+		};
+
+		enter-key {
+			linux,code = <28>;
+			label = "volume down";
+			rockchip,adc_value = <802>;
+		};
+
+		up-key {
+			linux,code = <103>;
+			label = "up";
+			rockchip,adc_value = <238>;
+		};
+
+		down-key {
+			linux,code = <108>;
+			label = "down";
+			rockchip,adc_value = <353>;
+		};
+
+		left-key {
+			linux,code = <105>;
+			label = "left";
+			rockchip,adc_value = <465>;
+		};
+
+		right-key {
+			linux,code = <106>;
+			label = "right";
+			rockchip,adc_value = <109>;
+		};
+
+		menu-key {
+			linux,code = <127>;
+			label = "menu";
+			rockchip,adc_value = <581>;
+		};
+
+		esc-key {
+			linux,code = <1>;
+			label = "esc";
+			rockchip,adc_value = <1>;
+		};
+	};
+};
+
+&spi0 {
+    status = "okay";
+	pinctrl-names = "default";
+	pinctrl-0 = <&spim0_clk &spim0_cs0 &spim0_tx &spim0_rx>;
+	spi_rk_preisp@00 {
+               compatible =  "rockchip,spi_rk_preisp";
+               device_type = "spi_rk_preisp";
+               rockchip,camera-modules-attached = <&camera0 &camera1>;
+               reg = <0>;
+               spi-max-frequency = <20000000>;
+               spi-min-frequency = <12000000>;
+               rockchip,grf = <&grf>;
+               //spi-cpol;
+               //spi-cpha;
+               reset-gpio = <&gpio3 GPIO_A7 GPIO_ACTIVE_HIGH>;
+               irq-gpio = <&gpio3 GPIO_B2 GPIO_ACTIVE_HIGH>;
+               sleepst-gpio = <&gpio3 GPIO_B3 GPIO_ACTIVE_HIGH>;
+               wakeup-gpio = <&gpio3 GPIO_B1 GPIO_ACTIVE_HIGH>;
+               //powerdown-gpio = <&gpio8 GPIO_A0 GPIO_ACTIVE_HIGH>;
+               pinctrl-names = "default";
+               pinctrl-0 = <&preisp_reset_gpios &preisp_irq_gpios &preisp_wake_gpios &preisp_sleep_gpios>;
+               //firmware-nowait-mode = <1>;
+               //TODO:
+               //regulator config...
+       };
+};
+
+&i2c0 {
+	status = "okay";
+
+	i2c-scl-rising-time-ns = <275>;
+	i2c-scl-falling-time-ns = <16>;
+	clock-frequency = <400000>;
+
+	rk805: rk805@18 {
+		reg = <0x18>;
+		status = "okay";
+	};
+
+	sensor: sensor@19 {
+		compatible = "bma2xx_acc";
+		reg = <0x19>;
+		type = <2>;
+		irq-gpio = <&gpio0 GPIO_B3 IRQ_TYPE_LEVEL_HIGH>;
+		irq_enable = <0>;
+		poll_delay_ms = <30>;
+		layout = <2>;
+		status = "okay";
+	};
+
+	nvp6124: nvp6124@30 {
+		status = "disabled";
+		compatible = "rockchip,nvp";
+		reg = <0x30>;
+		device_type = "v4l2-i2c-subdev";
+		/* 1 or 2 or 4 */
+		channels = <4>;
+		/* 1.8v or 3.3v */
+		apio_vol = <3300>;
+		/* PAL or NTSC */
+		cvbs_mode = "PAL";
+		reset-gpio = <&gpio3 GPIO_C6 GPIO_ACTIVE_LOW>;
+		irq-gpio = <&gpio3 GPIO_D3 GPIO_ACTIVE_HIGH>;
+		pinctrl-names = "default", "sleep";
+		pinctrl-0 = <&cif_dvp_d2d9 &cif_dvp_clk_in>;
+		pinctrl-1 = <&cif_dvp_d2d9_sleep &cif_dvp_clk_in_sleep>;
+	};
+
+	mpu6500: mpu6500@68 {
+		status = "disabled";
+		compatible = "invensense,mpu6500";
+		reg = <0x68>;
+		mpu-int_config = <0x10>;
+		mpu-level_shifter = <0>;
+		mpu-orientation = <1 0 0 0 1 0 0 0 1>;
+		orientation-x= <1>;
+		orientation-y= <1>;
+		orientation-z= <0>;
+		support-hw-poweroff = <1>;
+		mpu-debug = <1>;
+	};
+};
+
+&i2c1 {
+	status = "okay";
+
+//#include "rv1108-camb-v11.dtsi" /* camera board v11 */
+//#include "rv1108-camb-v12.dtsi" /* camera board v12 */
+#include "rv1108-camb-v13.dtsi" /* camera board v13 */
+};
+/ {
+	cam_ircut0: cam_ircut {
+		status = "okay";
+		compatible = "rockchip,ircut";
+		rockchip,ircut-gpio-close = <&gpio1 GPIO_A2 GPIO_ACTIVE_LOW>;
+		rockchip,ircut-gpio-open  = <&gpio1 GPIO_A1 GPIO_ACTIVE_LOW>;
+		rockchip,led              = <&gpio0 GPIO_C0 GPIO_ACTIVE_LOW>;
+	};
+};
+
+&i2c3 {
+	status = "okay";
+    camera1: camera-module@37 {
+    	status = "okay";
+    	compatible = "omnivision,ov4689-v4l2-i2c-subdev";
+    	reg = <0x36>;
+    	device_type = "v4l2-i2c-subdev";
+    	clocks = <&clk_mipicsi_out>;
+    	clock-names = "clk_mipicsi_out";
+    	rockchip,pd-gpio = <&gpio3 GPIO_B0 GPIO_ACTIVE_LOW>;
+    	rockchip,pwr-gpio = <&gpio0 GPIO_C3 GPIO_ACTIVE_HIGH>;
+    	rockchip,rst-gpio = <&gpio3 GPIO_D1 GPIO_ACTIVE_LOW>;
+    	rockchip,camera-module-mclk-name = "clk_mipicsi_out";
+    	rockchip,camera-module-facing = "back";
+    	rockchip,camera-module-name = "LA6111PA";
+    	rockchip,camera-module-len-name = "YM6011P";
+    	rockchip,camera-module-fov-h = "116";
+    	rockchip,camera-module-fov-v = "61";
+    	rockchip,camera-module-orientation = <0>;
+    	rockchip,camera-module-iq-flip = <0>;
+    	rockchip,camera-module-iq-mirror = <0>;
+    	rockchip,camera-module-flip = <0>;
+    	rockchip,camera-module-mirror = <1>;
+    	/* resolution.w, resolution.h, defrect.left, defrect.top, defrect.w, defrect.h */
+    	rockchip,camera-module-defrect0 = <2688 1520 0 0 2688 1520>;
+    	rockchip,camera-module-flash-support = <0>;
+    	rockchip,camera-module-mipi-dphy-index = <0>;
+    };
+};
+
+&camera0 {
+	rockchip,camera-ircut = <&cam_ircut0>;
+	rockchip,camera-ls = <&light_sensor0>;
+	rockchip,camera-ls-range = <0 700 800 1024>;
+};
+
+&camera1 {
+	rockchip,camera-ircut = <&cam_ircut0>;
+	rockchip,camera-ls = <&light_sensor0>;
+	rockchip,camera-ls-range = <0 700 800 1024>;
+};
+
+&camera2 {
+	rockchip,camera-ircut = <&cam_ircut0>;
+	rockchip,camera-ls = <&light_sensor0>;
+	rockchip,camera-ls-range = <0 750 950 1024>;
+};
+
+&cif1to4 {
+	status = "disabled";
+};
+
+&cif_cif0 {
+	rockchip,camera-modules-attached = <&nvp6124 &cvbsin>;
+	status = "disabled";
+};
+
+&cif_cif1 {
+	rockchip,camera-modules-attached = <&nvp6124>;
+	status = "disabled";
+};
+
+&cif_cif2 {
+	rockchip,camera-modules-attached = <&nvp6124>;
+	status = "disabled";
+};
+
+&cif_cif3 {
+	rockchip,camera-modules-attached = <&nvp6124>;
+	status = "disabled";
+};
+
+&cif_isp0 {
+	rockchip,camera-modules-attached = <&spi0>;
+	status = "okay";
+};
+
+&cvbsin {
+	status = "disabled";
+};
+
+&gmac_clkin {
+	clock-frequency = <50000000>;
+};
+
+&gmac {
+	status = "okay";
+
+	/* pmu_regulator = "act_ldo5"; */
+	/* power-gpio = <&gpio0 GPIO_A6 GPIO_ACTIVE_HIGH>; */
+	reset-gpio = <&gpio1 GPIO_C0 GPIO_ACTIVE_LOW>;
+
+	phy-mode = "rmii";
+	clock_in_out = "output";
+};
+
+&emmc {
+	clock-frequency = <50000000>;
+	clock-freq-min-max = <400000 50000000>;
+	supports-highspeed;
+	supports-emmc;
+	bootpart-no-access;
+	supports-DDR_MODE;
+	caps2-mmc-hs200;
+	ignore-pm-notify;
+	keep-power-in-suspend;
+	status = "disabled";
+};
+
+&sdmmc {
+	clock-frequency = <50000000>;
+	clock-freq-min-max = <200000 50000000>;
+	supports-highspeed;
+	supports-sd;
+	broken-cd;
+	card-detect-delay = <200>;
+	ignore-pm-notify;
+	keep-power-in-suspend;
+	power-inverted;
+	status = "okay";
+};
+
+&sdio {
+	clock-frequency = <50000000>;
+	clock-freq-min-max = <200000 50000000>;
+	supports-highspeed;
+	supports-sdio;
+	ignore-pm-notify;
+	keep-power-in-suspend;
+	cap-sdio-irq;
+	status = "okay";
+};
+
+&sfc {
+	status = "okay";
+};
+
+//#include "rv1108-rk805-v11.dtsi" /* rk805 v11 */
+#include "rv1108-rk805-v12.dtsi" /* rk805 v12 */
+
+&dwc_control_usb {
+	rockchip,remote_wakeup;
+	rockchip,usb_irq_wakeup;
+	status = "okay";
+};
+
+&tsadc {
+	status = "okay";
+};
+
+&usb_host_ehci {
+	status = "okay";
+};
+
+&usb_host_ohci {
+	status = "okay";
+};
+
+&usb_otg {
+	rockchip,high-bandwidth;
+	status = "okay";
+};
+
+&rkvenc {
+	status = "okay";
+};
+
+&vpu {
+	status = "okay";
+};
+
+&rkvdec {
+	status = "okay";
+};
+
+&iep {
+	status = "okay";
+};
+
+&fb {
+	status = "okay";
+};
+
+&rk_screen {
+	status = "okay";
+};
+
+&vop {
+	status = "okay";
+	pinctrl-names = "default", "gpio";
+	pinctrl-0 = <&lcdc_mipi_data>;
+	pinctrl-1 = <&lcdc_mipi_gpio>;
+	power_ctr: power_ctr {
+		rockchip,debug = <0>;
+		/*
+		lcd_en: lcd_en {
+			rockchip,power_type = <GPIO>;
+			gpios = <&gpio3 GPIO_C4 GPIO_ACTIVE_HIGH>;
+			rockchip,delay = <10>;
+		};
+		*/
+	};
+};
+
+&rga {
+	status = "okay";
+};
+
+&i2s1 {
+	status = "okay";
+};
+
+&codec {
+	spk_ctl_io = <&gpio0 GPIO_C4 GPIO_ACTIVE_HIGH>;
+	rockchip,single-ended = <1>;
+	status = "okay";
+};
+
+&hdmi {
+	status = "okay";
+	pinctrl-0 = <&hdmi_cec &i2c2m1_xfer &hdmi_hpd>;
+};
+
+&camera2 {
+	rockchip,pwr-gpio = <&gpio1 GPIO_A0 GPIO_ACTIVE_HIGH>;
+	rockchip,camera-module-name = "LA6271";
+	rockchip,camera-module-flip = <1>;
+	rockchip,camera-module-mirror = <1>;
+};
+
+&pinctrl {
+	preisp_gpios {
+		preisp_reset_gpios: preisp-reset-gpios {
+			rockchip,pins = <3 GPIO_A7 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		preisp_irq_gpios: preisp-irq-gpios {
+			rockchip,pins = <3 GPIO_B2 RK_FUNC_GPIO &pcfg_pull_up>;
+		};
+
+		preisp_wake_gpios: preisp-wake-gpios {
+			rockchip,pins = <3 GPIO_B1 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+
+		preisp_sleep_gpios: preisp-sleep-gpios {
+			rockchip,pins = <3 GPIO_B3 RK_FUNC_GPIO &pcfg_pull_none>;
+		};
+	};
+};
\ No newline at end of file
diff --git a/arch/arm/boot/dts/rv1108.dtsi b/arch/arm/boot/dts/rv1108.dtsi
index 1da0a9c..4e11955 100644
--- a/arch/arm/boot/dts/rv1108.dtsi
+++ b/arch/arm/boot/dts/rv1108.dtsi
@@ -1890,10 +1890,10 @@
 
 		cam_pins {
 			cam0_default_pins: cam0-default-pins {
-				rockchip,pins = <3 GPIO_B5 RK_FUNC_1 &pcfg_pull_none>;
+				rockchip,pins = <1 GPIO_B5 RK_FUNC_1 &pcfg_pull_none>;
 			};
 			cam0_sleep_pins: cam0-sleep-pins {
-				rockchip,pins = <3 GPIO_B5 RK_FUNC_GPIO &pcfg_pull_none>;
+				rockchip,pins = <1 GPIO_B5 RK_FUNC_GPIO &pcfg_pull_none>;
 			};
 		};
 
@@ -1927,7 +1927,7 @@
 						<3 GPIO_C6 RK_FUNC_1 &pcfg_pull_none>; /* cif_vsync */
 			};
 			cif_dvp_clk_out: cif-dvp-clk-out {
-				rockchip,pins = <3 GPIO_D2 RK_FUNC_1 &pcfg_pull_none>;
+				rockchip,pins = <3 GPIO_B5 RK_FUNC_1 &pcfg_pull_none>;
 			};
 			cif_dvp_clk_in: cif-dvp-clk-in {
 				rockchip,pins = <3 GPIO_C7 RK_FUNC_1 &pcfg_pull_none>;
@@ -1943,7 +1943,7 @@
 						<3 GPIO_D4 RK_FUNC_GPIO &pcfg_pull_none>;
 			};
 			cif_dvp_clk_out_sleep: cif-dvp-clk-out-sleep {
-				rockchip,pins = <3 GPIO_D2 RK_FUNC_GPIO &pcfg_pull_none>;
+				rockchip,pins = <3 GPIO_B5 RK_FUNC_1 &pcfg_pull_none>;
 			};
 			cif_dvp_clk_in_sleep: cif-dvp-clk-in-sleep {
 				rockchip,pins = <3 GPIO_C7 RK_FUNC_GPIO &pcfg_pull_none>;
diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c
index 30d575a..f2b11c1 100644
--- a/drivers/base/firmware_class.c
+++ b/drivers/base/firmware_class.c
@@ -269,7 +269,8 @@ static const char * const fw_path[] = {
 	"/lib/firmware/updates/" UTS_RELEASE,
 	"/lib/firmware/updates",
 	"/lib/firmware/" UTS_RELEASE,
-	"/lib/firmware"
+	"/lib/firmware",
+	"/user"
 };
 
 /*
diff --git a/drivers/media/i2c/soc_camera/rockchip/ov4689_v4l2-i2c-subdev.c b/drivers/media/i2c/soc_camera/rockchip/ov4689_v4l2-i2c-subdev.c
index 9b91f39..12f026e 100644
--- a/drivers/media/i2c/soc_camera/rockchip/ov4689_v4l2-i2c-subdev.c
+++ b/drivers/media/i2c/soc_camera/rockchip/ov4689_v4l2-i2c-subdev.c
@@ -87,6 +87,8 @@
 #define ov4689_BINING_SIZE_RESOLUTION_WIDTH 1280
 
 static struct ov_camera_module ov4689;
+static struct ov_camera_module ov4689_1;
+static int num_cameras;
 static struct ov_camera_module_custom_config ov4689_custom_config;
 
 /* ======================================================================== */
@@ -1034,7 +1036,7 @@ static int ov4689_start_streaming(struct ov_camera_module *cam_mod)
 {
 	int ret = 0;
 
-	ov_camera_module_pr_debug(cam_mod, "active config=%s\n", cam_mod->active_config->name);
+	ov_camera_module_pr_info(cam_mod, "active config=%s\n", cam_mod->active_config->name);
 
 	ret = ov4689_g_VTS(cam_mod, &cam_mod->vts_min);
 	if (IS_ERR_VALUE(ret))
@@ -1088,7 +1090,7 @@ static int ov4689_check_camera_id(struct ov_camera_module *cam_mod)
 	}
 
 	if ((pidh == ov4689_PIDH_MAGIC) && (pidl == ov4689_PIDL_MAGIC))
-		ov_camera_module_pr_debug(cam_mod,
+		ov_camera_module_pr_info(cam_mod,
 			"successfully detected camera ID 0x%02x%02x\n",
 			pidh, pidl);
 	else {
@@ -1157,12 +1159,17 @@ static int ov4689_probe(
 	struct i2c_client *client,
 	const struct i2c_device_id *id)
 {
-	dev_info(&client->dev, "probing...\n");
+	struct ov_camera_module *tmp_ov4689 = NULL;
+
+	dev_info(&client->dev, "probing[%d]...\n", num_cameras);
+
+	tmp_ov4689 = (num_cameras == 0) ? &ov4689 : &ov4689_1;
 
 	ov4689_filltimings(&ov4689_custom_config);
-	v4l2_i2c_subdev_init(&ov4689.sd, client, &ov4689_camera_module_ops);
-	ov4689.sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
-	ov4689.custom = ov4689_custom_config;
+	v4l2_i2c_subdev_init(&tmp_ov4689->sd, client, &ov4689_camera_module_ops);
+	tmp_ov4689->sd.flags |= V4L2_SUBDEV_FL_HAS_DEVNODE;
+	tmp_ov4689->custom = ov4689_custom_config;
+	num_cameras++;
 
 	dev_info(&client->dev, "probing successful\n");
 	return 0;
diff --git a/drivers/media/i2c/soc_camera/rockchip/rk_camera_module.c b/drivers/media/i2c/soc_camera/rockchip/rk_camera_module.c
index 332b445..e30e951 100644
--- a/drivers/media/i2c/soc_camera/rockchip/rk_camera_module.c
+++ b/drivers/media/i2c/soc_camera/rockchip/rk_camera_module.c
@@ -245,7 +245,8 @@ static int pltfrm_camera_module_init_gpio(
 						"failed to request GPIO #%d ('%s')\n",
 						pdata->gpios[i].pltfrm_gpio,
 						pdata->gpios[i].label);
-					goto err;
+					//goto err;
+					continue;
 				}
 			}
 
diff --git a/drivers/media/platform/Makefile b/drivers/media/platform/Makefile
index 3c12b73..0fceede 100644
--- a/drivers/media/platform/Makefile
+++ b/drivers/media/platform/Makefile
@@ -51,5 +51,6 @@ obj-y	+= davinci/
 obj-$(CONFIG_ARCH_OMAP)	+= omap/
 
 ccflags-y += -I$(srctree)/drivers/media/i2c
+obj-y   += preisp_driver/
 obj-y	+= rk-cif/
 obj-y   += rk-isp11/
diff --git a/drivers/media/platform/preisp_driver/Makefile b/drivers/media/platform/preisp_driver/Makefile
new file mode 100644
index 0000000..26d7de2
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/Makefile
@@ -0,0 +1,11 @@
+#
+# Makefile for the RockChip PreIsp device drivers.
+#
+#EXTRA_CFLAGS += -Wno-unused-variable
+#EXTRA_CFLAGS += -Wno-unused-label
+#EXTRA_CFLAGS += -Wno-unused-value
+#EXTRA_CFLAGS += -Wno-unused-parameter
+#EXTRA_CFLAGS += -Wno-unused-function
+#EXTRA_CFLAGS += -Wno-unused
+rkpreisp-objs := spi-rkpreisp.o isp-fw.o spi2apb.o msg-queue.o ap-i2c.o cif-preisp-dummy-rv1108.o cif-preisp_img_src.o cif-preisp_img_src_v4l2-subdev.o cif-preisp-pltfrm.o cif-preisp.o
+obj-y += rkpreisp.o
diff --git a/drivers/media/platform/preisp_driver/ap-i2c.c b/drivers/media/platform/preisp_driver/ap-i2c.c
new file mode 100644
index 0000000..d6c23d2
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/ap-i2c.c
@@ -0,0 +1,72 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include "ap-i2c.h"
+#include "linux/i2c.h"
+
+int ap_i2c_do_xfer(struct spi_device *spi, msg_do_i2c_t *i2c_msg)
+{
+    struct i2c_adapter *i2c;
+    struct i2c_msg msg[2];
+    int err = 0;
+    int i;
+    MSG(msg_do_i2c_ret_t, ret_msg);
+
+    i2c = i2c_get_adapter(i2c_msg->head.nr);
+    if (i2c == NULL) {
+        dev_err(&spi->dev, "i2c get adapter(%d) error!", i2c_msg->head.nr);
+        return -1;
+    }
+
+    if (i2c_msg->head.num_msg > AP_I2C_ONCE_MAX_NUM) {
+        i2c_msg->head.num_msg = AP_I2C_ONCE_MAX_NUM;
+        dev_warn(&spi->dev, "ap i2c once msg num too large %d > %d",
+                i2c_msg->head.num_msg, AP_I2C_ONCE_MAX_NUM);
+    }
+
+    for (i = 0; i < i2c_msg->head.num_msg; i++) {
+        int msg_num = 1;
+        msg[0].addr = i2c_msg->msg[i].addr;
+        msg[0].len = i2c_msg->msg[i].len;
+        msg[0].buf = i2c_msg->msg[i].buf;
+        msg[0].flags = i2c_msg->msg[i].flags;
+
+        if (i < (i2c_msg->head.num_msg - 1) &&
+            (i2c_msg->msg[i+1].flags & I2C_M_RD)) {
+            msg_num = 2;
+            i++;
+            msg[1].addr = i2c_msg->msg[i].addr;
+            msg[1].len = i2c_msg->msg[i].len;
+            msg[1].buf = i2c_msg->msg[i].buf;
+            msg[1].flags = i2c_msg->msg[i].flags;
+        }
+
+        err = i2c_transfer(i2c, msg, msg_num);
+
+        if (err < 0) {
+            dev_err(&spi->dev, "i2c transfer(addr:0x%x,len:%d, msg_num:%d) error(%d)!",
+                    msg[0].addr, msg[0].len, msg_num, err);
+        } else if (msg_num == 2) {
+            ret_msg.nr = i2c_msg->head.nr;
+            ret_msg.addr = i2c_msg->msg[i].addr;
+            memcpy(ret_msg.buf, i2c_msg->msg[i].buf, sizeof(i2c_msg->msg[i].len));
+
+            dsp_msq_send_msg(spi, (msg_t*)&ret_msg);
+        }
+    }
+
+
+    i2c_put_adapter(i2c);
+
+    return err;
+}
diff --git a/drivers/media/platform/preisp_driver/ap-i2c.h b/drivers/media/platform/preisp_driver/ap-i2c.h
new file mode 100644
index 0000000..9e2daac
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/ap-i2c.h
@@ -0,0 +1,21 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __RK_PREISP_AP_I2C_H__
+#define __RK_PREISP_AP_I2C_H__
+
+#include "msg-queue.h"
+
+int ap_i2c_do_xfer(struct spi_device *spi, msg_do_i2c_t *msg);
+
+#endif
diff --git a/drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.c b/drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.c
new file mode 100644
index 0000000..b954c6c
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.c
@@ -0,0 +1,45 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.0
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+#ifdef CONFIG_ARM
+#include "cif-preisp-dummy-rv1108.h"
+
+int pltfrm_rv1108_dummy_cfg(
+		struct pltfrm_soc_cfg_para *cfg)
+{
+	switch (cfg->cmd) {
+	case PLTFRM_CLKEN:
+		break;
+
+	case PLTFRM_CLKDIS:
+		break;
+
+	case PLTFRM_CLKRST:
+		break;
+
+	case PLTFRM_CLKINIT:
+		break;
+
+	case PLTFRM_SOC_INIT:
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_ARM */
+
diff --git a/drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.h b/drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.h
new file mode 100644
index 0000000..dc3c253
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp-dummy-rv1108.h
@@ -0,0 +1,30 @@
+#ifndef _CIF_ISP11_PLATFORM_H
+#define _CIF_ISP11_PLATFORM_H
+
+#define CIF_DUMMY_SOC_RV1108	"dummy-rv1108"
+
+enum pltfrm_soc_cfg_cmd {
+	PLTFRM_MCLK_CFG = 0,
+	PLTFRM_MIPI_DPHY_CFG,
+
+	PLTFRM_CLKEN,
+	PLTFRM_CLKDIS,
+	PLTFRM_CLKRST,
+
+	PLTFRM_CLKINIT,
+	PLTFRM_SOC_INIT
+};
+
+struct pltfrm_soc_cfg_para {
+	enum pltfrm_soc_cfg_cmd cmd;
+	void *cfg_para;
+};
+
+struct pltfrm_soc_cfg {
+	char name[32];
+	int (*soc_cfg)(struct pltfrm_soc_cfg_para *cfg);
+};
+
+int pltfrm_rv1108_dummy_cfg (
+		struct pltfrm_soc_cfg_para *cfg);
+#endif
diff --git a/drivers/media/platform/preisp_driver/cif-preisp-pltfrm.c b/drivers/media/platform/preisp_driver/cif-preisp-pltfrm.c
new file mode 100644
index 0000000..06e5cf5
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp-pltfrm.c
@@ -0,0 +1,147 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef CONFIG_OF
+#error "this driver requires a kernel with device tree support"
+#endif
+
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <linux/io.h>
+#include <linux/jiffies.h>
+#include <linux/list.h>
+#ifndef CONFIG_DEBUG_FS
+#include <linux/debugfs.h>
+#include <linux/fs.h>
+#endif
+#include "cif-preisp.h"
+
+const char *cif_preisp_pltfrm_get_device_type(
+	struct device *dev)
+{
+	return dev->of_node->type;
+}
+
+const char *cif_preisp_pltfrm_dev_string(
+	struct device *dev)
+{
+	return dev_driver_string(dev);
+}
+
+int cif_preisp_pltfrm_get_img_src_device(
+	struct device *dev,
+	struct cif_preisp_img_src **img_src_array,
+	unsigned int array_len)
+{
+	struct device_node *node = NULL;
+	struct device_node *camera_list_node = NULL;
+	struct i2c_client *i2c_client = NULL;
+	int ret = 0;
+	int index, size = 0;
+	const __be32 *phandle;
+	int num_cameras = 0;
+	struct spi_device *spi_dev = to_spi_device(dev);
+	struct spi_rk_preisp_data *cif_preisp_dev = spi_get_drvdata(spi_dev);
+
+	node = of_node_get(dev->of_node);
+	if (IS_ERR_OR_NULL(node)) {
+		dev_err(dev, "Unable to obtain CIF device node\n");
+		ret = -EEXIST;
+		goto err;
+	}
+
+	phandle = of_get_property(node,
+		"rockchip,camera-modules-attached", &size);
+	if (IS_ERR_OR_NULL(phandle)) {
+		cif_preisp_pltfrm_pr_err(dev,
+			"no camera-modules-attached'\n");
+			ret = -EINVAL;
+			goto err;
+	}
+
+	for (index = 0; index < size/sizeof(*phandle); index++) {
+		camera_list_node = of_parse_phandle(node,
+			"rockchip,camera-modules-attached", index);
+		of_node_put(node);
+		if (IS_ERR_OR_NULL(camera_list_node)) {
+			cif_preisp_pltfrm_pr_err(dev,
+				"invalid index %d for property"
+				"'rockchip,camera-modules-attached'\n",
+				index);
+				ret = -EINVAL;
+				goto err;
+		}		
+
+		cif_preisp_pltfrm_pr_info(dev, "full name: %s", camera_list_node->full_name);
+
+		if (!strcmp(camera_list_node->type,
+			    "v4l2-i2c-subdev")) {
+			i2c_client = of_find_i2c_device_by_node(
+				camera_list_node);
+			cif_preisp_pltfrm_pr_info(dev, "i2c_client name: %s\n", i2c_client->name);
+			of_node_put(camera_list_node);
+			if (IS_ERR_OR_NULL(i2c_client)) {
+				cif_preisp_pltfrm_pr_err(dev,
+					"could not get camera i2c client,"
+					" maybe not yet created, deferring"
+					" device probing...\n");
+				continue;
+			}
+		} else {
+			cif_preisp_pltfrm_pr_dbg(dev,
+				"device of type %s not supported\n",
+				camera_list_node->type);
+			of_node_put(camera_list_node);
+			continue;
+		}
+
+		img_src_array[num_cameras] =
+			cif_preisp_img_src_to_img_src(
+				&i2c_client->dev,
+				cif_preisp_dev->soc_cfg);
+		if (!IS_ERR_OR_NULL(img_src_array[num_cameras])) {
+			cif_preisp_pltfrm_pr_info(dev,
+				"%s attach to cif cif-preisp img_src_array[%d]\n",
+				cif_preisp_img_src_g_name(
+					img_src_array[num_cameras]),
+				num_cameras);
+			num_cameras++;
+			if (num_cameras >= array_len) {
+				cif_preisp_pltfrm_pr_err(dev,
+					"cif preisp isn't support > %d"
+					"'camera modules attached'\n",
+					array_len);
+				break;
+			}
+		} else {
+			img_src_array[num_cameras] = NULL;
+		}
+	}
+
+	return num_cameras;
+err:
+	dev_err(dev, "failed with error %d\n", ret);
+	if (!IS_ERR_OR_NULL(i2c_client))
+		put_device(&i2c_client->dev);
+	if (!IS_ERR_OR_NULL(camera_list_node))
+		of_node_put(camera_list_node);
+	return ret;
+}
+
diff --git a/drivers/media/platform/preisp_driver/cif-preisp-pltfrm.h b/drivers/media/platform/preisp_driver/cif-preisp-pltfrm.h
new file mode 100644
index 0000000..908ae0d
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp-pltfrm.h
@@ -0,0 +1,61 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef _CIF_PREISP_PLTFRM_H
+#define _CIF_PREISP_PLTFRM_H
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include <linux/wait.h>
+#include <linux/string.h>
+
+struct cif_preisp_img_src;
+
+#define CIF_PREISP_PLTFRM_DEVICE struct device *
+
+#define cif_preisp_pltfrm_pr_dbg(dev, fmt, arg...) \
+	do { \
+		pr_debug("%s: " fmt, \
+			__func__, ## arg); \
+	} while (0)
+#define cif_preisp_pltfrm_pr_info(dev, fmt, arg...) \
+	do { \
+		pr_info("%s: " fmt, \
+			__func__, ## arg); \
+	} while (0)
+#define cif_preisp_pltfrm_pr_warn(dev, fmt, arg...) \
+	do { \
+		pr_warn("%s WARN: " fmt, \
+			__func__, ## arg); \
+	} while (0)
+#define cif_preisp_pltfrm_pr_err(dev, fmt, arg...) \
+	do { \
+		pr_err("%s(%d) ERR: " fmt, \
+			__func__, __LINE__, ## arg); \
+	} while (0)
+
+const char *cif_preisp_pltfrm_get_device_type(
+	struct device *dev);
+
+const char *cif_preisp_pltfrm_dev_string(
+	struct device *dev);
+
+int cif_preisp_pltfrm_get_img_src_device(
+	struct device *dev,
+	struct cif_preisp_img_src **img_src_array,
+	unsigned int array_len);
+#endif
diff --git a/drivers/media/platform/preisp_driver/cif-preisp-rv1108.c b/drivers/media/platform/preisp_driver/cif-preisp-rv1108.c
new file mode 100644
index 0000000..651d2a4
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp-rv1108.c
@@ -0,0 +1,52 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.0
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+#ifdef CONFIG_ARM
+
+#include "cif-preisp-dummy-rv1108.h"
+
+struct cif_preisp_rv1108 {
+	int dummy;
+};
+
+static struct cif_preisp_rv1108 preisp_dummy_rv1108 = {0};
+
+int pltfrm_rv1108_dummy_cfg(
+		struct pltfrm_soc_cfg_para *cfg)
+{
+	switch (cfg->cmd) {
+	case PLTFRM_CLKEN:
+		break;
+
+	case PLTFRM_CLKDIS:
+		break;
+
+	case PLTFRM_CLKRST:
+		break;
+
+	case PLTFRM_CLKINIT:
+		break;
+
+	case PLTFRM_SOC_INIT:
+		break;
+
+	default:
+		break;
+	}
+
+	return 0;
+}
+#endif /* CONFIG_ARM */
+
diff --git a/drivers/media/platform/preisp_driver/cif-preisp.c b/drivers/media/platform/preisp_driver/cif-preisp.c
new file mode 100644
index 0000000..f45d4b9
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp.c
@@ -0,0 +1,670 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#include <linux/pm_runtime.h>
+#include <linux/vmalloc.h>
+#include <linux/rockchip/common.h>
+#include "cif-preisp.h"
+#include "cif-preisp-dummy-rv1108.h"
+
+#define OPEN_CAM_NUM 1
+#define DEBUG_POLL_MODE_READ_MSG 0
+#define DEBUG_DUMP_ALL_SEND_RECV_MSG 0
+#define DEBUG_MSG_LOOP_TEST 0
+int msq_free_received_msg(struct msg_queue *q, const struct msg *m);
+
+static struct pltfrm_soc_cfg rv1108_cfg = {
+	.name = CIF_DUMMY_SOC_RV1108,
+	.soc_cfg = pltfrm_rv1108_dummy_cfg,
+};
+
+int doConnectDspMsg(struct spi_rk_preisp_data *pdata, int camId)
+{
+	int ret = 0;
+	preisp_client *client = preisp_client_new();
+
+	client->id = camId;
+        ret = preisp_client_connect(pdata, client);
+
+        return ret;
+}
+
+int rkpreisp_send_msg(struct spi_rk_preisp_data *pdata, const struct msg *msg)
+{
+	int ret = 0;
+
+#if DEBUG_DUMP_ALL_SEND_RECV_MSG == 1
+	int32_hexdump("send msg:", (int32_t*)msg, sizeof(msg));
+#endif
+
+#if DEBUG_MSG_LOOP_TEST == 0
+        ret = preisp_send_msg_to_dsp(pdata, msg);
+#else
+        dispatch_received_msg(pdata, msg);
+#endif
+
+	return ret;
+}
+
+int rkpreisp_recv_msg(int camId, struct spi_rk_preisp_data *pdata, struct msg *msg)
+{
+	int ret = 0;
+	preisp_client *client;
+
+	client = pdata->rkpreisp_client[camId];
+	ret = msq_recv_msg(&client->q, &msg);
+	if (ret) {
+		cif_preisp_pltfrm_pr_err(NULL,
+			"msq_recv_msg failed!\n");
+		ret = EFAULT;
+	}
+	msq_free_received_msg(&client->q, NULL);
+
+	return ret;
+}
+
+int sendMsgAndWait(int camId, struct spi_rk_preisp_data *pdata, struct msg *msg,
+		   msg_response_t *resp, int timeoutMillis)
+{
+	int ret = EFAULT;
+	preisp_client *client = NULL;
+
+	cif_preisp_pltfrm_pr_info(NULL, "before send, before recv size: [%u, %u], type: [%u, %u]\n",
+		msg->size, resp->size, msg->type, resp->type);	
+
+#if DEBUG_MSG_LOOP_TEST == 0
+        ret = preisp_send_msg_to_dsp(pdata, msg);
+#else
+        dispatch_received_msg(pdata, msg);
+#endif
+
+	client = pdata->rkpreisp_client[camId];
+
+	cif_preisp_pltfrm_pr_info(NULL, "send sucess, before recv size: [%u, %u], type: [%u, %u]\n",
+				  msg->size, resp->size, msg->type, resp->type);	
+	wait_event_interruptible_timeout(client->wait, !msq_is_empty(&client->q),
+					 msecs_to_jiffies(timeoutMillis));
+
+	if (!msq_is_empty(&client->q)) {
+		if (resp != NULL) {
+			ret = msq_recv_msg(&client->q, &msg);
+			if (ret) {
+				cif_preisp_pltfrm_pr_err(dev,
+					"msq_recv_msg failed!\n");
+				goto err;
+			}
+			if (msg->type == resp->type && msg->size == resp->size) {
+				ret = 0;
+			} else {
+				cif_preisp_pltfrm_pr_err(NULL, "msq_recv_msg err!\n");
+				ret = EFAULT;
+			}
+		}
+	} else {
+		cif_preisp_pltfrm_pr_err(NULL, "msq is empty\n");
+		ret = EFAULT;
+	}
+
+	cif_preisp_pltfrm_pr_info(NULL, "size: [%u, %u], type: [%u, %u]\n",
+		msg->size, resp->size, msg->type, resp->type);	
+err:
+	msq_free_received_msg(&client->q, msg);
+	return ret;
+}
+
+int doInitSensor(struct spi_rk_preisp_data *pdata, int camId)
+{
+	msg_init_sensor_t msg;
+	msg_init_sensor_ret_t ret;
+	int err = 0;
+
+	cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);	
+
+	msg.size = sizeof(msg_init_sensor_t) / 4;
+    	msg.type = id_msg_init_sensor_t;
+    	msg.camera_id = camId;
+	msg.sync = 1;
+
+        msg.in_mipi_phy = 0;
+        msg.out_mipi_phy = 0;
+        msg.mipi_lane = 2;
+        msg.bayer = 1;
+	strcpy(msg.sensor_name, "ov4689");
+
+	ret.size = sizeof(msg_init_sensor_ret_t) / 4;
+	ret.type = id_msg_init_sensor_ret_t;
+	ret.camera_id = -1;
+
+	err = sendMsgAndWait(camId, pdata, (struct msg*)&msg, &ret, 1000);
+	if (err < 0) {
+		cif_preisp_pltfrm_pr_err(NULL, "%s: sendMsgAndWait failed!\n", __FUNCTION__);
+		err = EFAULT;
+	}
+
+	return err;
+}
+
+int doSetInputSize(struct spi_rk_preisp_data *pdata, int camId)
+{
+        u32 size = 0;
+	int err = 0;
+	int VcProfilesSize = 1;
+	size_t i = 0;
+        msg_set_input_size_t *msg;
+	msg_set_input_size_ret_t ret;
+
+	cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);	
+
+        size = sizeof(msg_set_input_size_head_t) +
+            /* resProfiles->mVcProfiles.size() */ VcProfilesSize * sizeof(preisp_vc_cfg_t);
+        msg = (msg_set_input_size_t*)kmalloc(size, GFP_KERNEL);
+        msg->head.size = size / 4;
+        msg->head.type = id_msg_set_input_size_t;
+        msg->head.camera_id = camId;
+        msg->head.sync = 1;
+        for (i = 0; i < VcProfilesSize; ++i) {
+            msg->channel[i].data_id = 0x2b;
+            msg->channel[i].decode_format = 0x2b;
+            msg->channel[i].flag = 1;
+            msg->channel[i].width = 2688;
+            msg->channel[i].height = 1520;
+        }
+
+	ret.size = sizeof(msg_set_input_size_ret_t) / 4;
+	ret.type = id_msg_set_input_size_ret_t;
+	ret.camera_id = -1;
+
+	err = sendMsgAndWait(camId, pdata, (struct msg*)msg, &ret, 1000);
+	kfree(msg);
+	err = !err ? err : ret.err;
+        if (err) {
+		cif_preisp_pltfrm_pr_err(NULL, "%s: sendMsgAndWait failed!\n", __FUNCTION__);
+		err = EFAULT;
+        }
+
+        return err;
+}
+
+int doSetOutputSize(struct spi_rk_preisp_data *pdata, int camId)
+{
+	int err = 0;
+	msg_set_output_size_ret_t ret;
+	msg_set_output_size_t msg;
+
+	cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);	
+
+	msg.size = sizeof(msg_set_output_size_t) / 4;
+	msg.type = id_msg_set_output_size_t;
+	msg.camera_id = camId;
+	msg.sync = 1;
+	msg.width = 2688;
+	msg.height = 1520;
+	msg.mipi_clk = 1200000000;
+	msg.line_length_pclk = 0x512;
+	msg.frame_length_lines = 0x612;
+
+	ret.size = sizeof(msg_set_output_size_ret_t) / 4;
+	ret.type = id_msg_set_output_size_ret_t;
+	ret.camera_id = -1;
+
+	err = sendMsgAndWait(camId, pdata, (struct msg*)&msg, &ret, 1000);
+	err = !err ? err : ret.err;
+        if (err) {
+		cif_preisp_pltfrm_pr_err(NULL, "%s: sendMsgAndWait failed!\n", __FUNCTION__);
+		err = EFAULT;
+        }
+
+	return err;
+}
+
+int doStartInputStream(struct spi_rk_preisp_data *pdata, int camId)
+{
+	int err = 0;
+	msg_set_stream_in_on_ret_t ret;
+	msg_init_sensor_t msg;
+
+	cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);	
+
+	msg.size = sizeof(msg_set_stream_in_on_t) / 4;
+    	msg.type = id_msg_set_stream_in_on_t;
+    	msg.camera_id = camId;
+	msg.sync = 1;
+
+	ret.size = sizeof(msg_set_stream_in_on_ret_t) / 4;
+	ret.type = id_msg_set_stream_in_on_ret_t;
+	ret.camera_id = -1;
+
+	err = sendMsgAndWait(camId, pdata, (struct msg*)&msg, &ret, 1000);
+	return err;
+}
+
+int doStopInputStream(struct spi_rk_preisp_data *pdata, int camId)
+{
+    int err = 0;
+    msg_set_stream_in_off_ret_t ret;
+    msg_set_stream_in_off_t msg;
+
+    cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);  
+
+    msg.size = sizeof(msg_set_stream_in_off_t) / 4;
+    msg.type = id_msg_set_stream_in_off_t;
+    msg.camera_id = camId;
+    msg.sync = 1;
+
+    ret.size = sizeof(msg_set_stream_in_off_t) / 4;
+    ret.type = id_msg_set_stream_in_off_t;
+    ret.camera_id = -1;
+
+    err = sendMsgAndWait(camId, pdata, (struct msg*)&msg, &ret, 1000);
+    return err;
+}
+
+int doStartOutputStream(struct spi_rk_preisp_data *pdata, int camId)
+{
+    int err = 0;
+    msg_set_stream_out_on_ret_t ret;
+    msg_set_stream_in_off_t msg;
+
+    cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);  
+
+    msg.size = sizeof(msg_set_stream_out_on_t) / 4;
+    msg.type = id_msg_set_stream_out_on_t;
+    msg.camera_id = camId;
+    msg.sync = 1;
+
+    ret.size = sizeof(msg_set_stream_out_on_ret_t) / 4;
+    ret.type = id_msg_set_stream_out_on_ret_t;
+    ret.camera_id = -1;
+
+    err = sendMsgAndWait(camId, pdata, (struct msg*)&msg, &ret, 1000);
+    return err;
+}
+
+int doStopOutputStream(struct spi_rk_preisp_data *pdata, int camId)
+{
+    int err = 0;
+    msg_set_stream_out_off_ret_t ret;
+    msg_set_stream_out_off_t msg;
+
+    cif_preisp_pltfrm_pr_info(NULL, "%s: enter!\n", __FUNCTION__);  
+
+    msg.size = sizeof(msg_set_stream_out_off_t) / 4;
+    msg.type = id_msg_set_stream_out_off_t;
+    msg.camera_id = camId;
+    msg.sync = 1;
+
+    ret.size = sizeof(msg_set_stream_out_off_ret_t) / 4;
+    ret.type = id_msg_set_stream_out_off_ret_t;
+    ret.camera_id = -1;
+
+    err = sendMsgAndWait(camId, pdata, (struct msg*)&msg, &ret, 1000);
+    return err;
+}
+
+int cif_preisp_cfg(struct device *dev, struct cif_preisp_cfg_para *cfg)
+{
+	int ret = 0;
+	int i = 0;
+	struct spi_device *spi_client;
+	struct spi_rk_preisp_data *cif_preisp_dev;
+	struct cif_preisp_strm_fmt_desc *strm_fmt_desc;
+	struct cif_preisp_strm_fmt *strm_fmt;
+
+	spi_client = to_spi_device(dev);
+	if (IS_ERR_OR_NULL(spi_client)) {
+		cif_preisp_pltfrm_pr_err(dev,
+			"not an spi device\n");
+		return EFAULT;
+	}
+
+	cif_preisp_pltfrm_pr_dbg(NULL, "%s: cmd: %d\n", __FUNCTION__, cfg->cmd);
+
+	cif_preisp_dev = spi_get_drvdata(spi_client);
+	if (IS_ERR_OR_NULL(cif_preisp_dev)) {
+		cif_preisp_pltfrm_pr_err(dev,
+			"not an spi subdev\n");
+		return EFAULT;
+	}
+
+	switch (cfg->cmd) {
+	case CIF_PREISP_STREAM:
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			if (*(int *)(cfg->cfg_para)) {
+				cif_preisp_dev->rkpreisp_client[i] = preisp_client_new();
+
+				cif_preisp_dev->rkpreisp_client[i]->id = i;
+				ret |= preisp_client_connect(cif_preisp_dev,
+					cif_preisp_dev->rkpreisp_client[i]);
+				if (ret < 0) {
+					cif_preisp_pltfrm_pr_err(NULL,
+						"preisp_client_connect error %d\n", ret);
+					break;
+				}
+
+				ret |= doInitSensor(cif_preisp_dev, i);
+				if (ret < 0) {
+					cif_preisp_pltfrm_pr_err(NULL,
+						"doInitSensor error %d\n", ret);
+					break;
+				}
+
+				ret |= doSetInputSize(cif_preisp_dev, i);
+				if (ret < 0) {
+					cif_preisp_pltfrm_pr_err(NULL,
+						"doSetSize error %d\n", ret);
+					break;
+				}
+
+				cif_preisp_pltfrm_pr_info(NULL,
+					"doStartInputStream---------- %d\n", ret);
+
+				ret |= doStartInputStream(cif_preisp_dev, i);
+				if (ret < 0) {
+					cif_preisp_pltfrm_pr_err(NULL,
+						"doStartInputStream error %d\n", ret);
+					break;
+				}
+			} else {
+				preisp_client_release(cif_preisp_dev->rkpreisp_client[i]);
+
+				preisp_client_disconnect(cif_preisp_dev,
+					cif_preisp_dev->rkpreisp_client[i]);
+				cif_preisp_dev->rkpreisp_client[i]->id = -1;
+
+				ret |= doStopInputStream(cif_preisp_dev, i);
+				if (ret < 0) {
+					cif_preisp_pltfrm_pr_err(NULL,
+						"doStartInputStream error %d\n", ret);
+					break;
+				}
+				ret |= doStopOutputStream(cif_preisp_dev, i);
+				if (ret < 0) {
+					cif_preisp_pltfrm_pr_err(NULL,
+						"doStartOutputStream error %d\n", ret);
+					break;
+				}
+			}
+
+			ret |= doSetOutputSize(cif_preisp_dev, 0);
+			if (ret < 0) {
+				cif_preisp_pltfrm_pr_err(NULL,
+					"doSetSize error %d\n", ret);
+				break;
+			}
+
+			cif_preisp_pltfrm_pr_info(NULL,
+				"doStartOutputStream---------- %d\n", ret);
+			
+			ret |= doStartOutputStream(cif_preisp_dev, 0);
+			if (ret < 0) {
+				cif_preisp_pltfrm_pr_err(NULL,
+					"doStartOutputStream error %d\n", ret);
+				break;
+			}
+		}
+
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			ret = cif_preisp_img_src_s_streaming(
+				cif_preisp_dev->img_src_array[i],
+				*(int *)(cfg->cfg_para));
+			if (ret < 0) {
+				cif_preisp_pltfrm_pr_err(NULL,
+					"s_streaming error %d\n", ret);
+				break;
+			}
+		}
+		break;
+	case CIF_PREISP_POWER:
+		if (*(int *)(cfg->cfg_para)) {
+			cif_preisp_pltfrm_pr_info(NULL,
+				"start rkpreisp_power_on----------\n");
+			ret |= rkpreisp_power_on(cif_preisp_dev);
+			if (ret < 0) {
+				cif_preisp_pltfrm_pr_err(NULL,
+					"rkpreisp_power_on with error %d\n",
+					ret);
+				break;
+			}
+			cif_preisp_pltfrm_pr_info(NULL,
+				"end rkpreisp_power_on----------\n");
+		} else {
+			ret |= rkpreisp_power_off(cif_preisp_dev);
+			if (ret < 0) {
+				cif_preisp_pltfrm_pr_info(NULL,
+					"rkpreisp_power_off with error %d\n",
+					ret);
+				break;
+			}
+		}
+
+		cif_preisp_pltfrm_pr_info(NULL,
+			"cam[%d]: s_power\n", i);
+
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			ret = cif_preisp_img_src_s_power(
+				cif_preisp_dev->img_src_array[i],
+				*(bool *)(cfg->cfg_para));
+			if (ret < 0) {
+				cif_preisp_pltfrm_pr_info(NULL,
+					"cam[%d]: s_power with error %d\n", i, ret);
+				break;
+			}
+		}
+		break;
+	case CIF_PREISP_ENUM_STRM_FMTS:
+		strm_fmt_desc = (struct cif_preisp_strm_fmt_desc *)(cfg->cfg_para);
+		ret = cif_preisp_img_src_enum_strm_fmts(
+			cif_preisp_dev->img_src_array[i],
+			(u32)(cfg->id),
+			strm_fmt_desc);
+		if (ret < 0) {
+			cif_preisp_pltfrm_pr_info(NULL,
+				"src_enum_strm_fmts with error %d\n", ret);
+		}
+
+		strm_fmt_desc->min_frmsize.width *= OPEN_CAM_NUM;
+		strm_fmt_desc->min_frmsize.height *= OPEN_CAM_NUM;
+		strm_fmt_desc->defrect.left *= OPEN_CAM_NUM;
+		strm_fmt_desc->defrect.top *= OPEN_CAM_NUM;
+		strm_fmt_desc->defrect.width *= OPEN_CAM_NUM;
+		strm_fmt_desc->defrect.height *= OPEN_CAM_NUM;
+
+		cif_preisp_pltfrm_pr_info(NULL,
+			"cam[%d]: strm_fmt_desc size[%d, %d], defrect[%d, %d]\n",
+			i, strm_fmt_desc->min_frmsize.width,
+			strm_fmt_desc->min_frmsize.height,
+			strm_fmt_desc->defrect.width,
+			strm_fmt_desc->defrect.height);
+		break;
+	case CIF_PREISP_STRM_FMT_DESC:
+		strm_fmt = (struct cif_preisp_strm_fmt *)(cfg->cfg_para);
+
+		strm_fmt->frm_fmt.width /= OPEN_CAM_NUM;
+		strm_fmt->frm_fmt.height /= OPEN_CAM_NUM;
+		strm_fmt->frm_fmt.defrect.left /= OPEN_CAM_NUM;
+		strm_fmt->frm_fmt.defrect.top /= OPEN_CAM_NUM;
+		strm_fmt->frm_fmt.defrect.width /= OPEN_CAM_NUM;
+		strm_fmt->frm_fmt.defrect.height /= OPEN_CAM_NUM;
+
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			ret = cif_preisp_img_src_s_strm_fmt(
+				cif_preisp_dev->img_src_array[i],
+				strm_fmt);
+		}
+
+		break;
+	case CIF_PREISP_S_FRMAE_INTERVAL:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = cif_preisp_img_src_s_frame_interval(
+				cif_preisp_dev->img_src_array[i],
+				(struct cif_preisp_frm_intrvl *)(cfg->cfg_para));
+		break;
+	case CIF_PREISP_G_FRMAE_INTERVAL:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = cif_preisp_img_src_g_frame_interval(
+				cif_preisp_dev->img_src_array[i],
+				(struct cif_preisp_frm_intrvl *)(cfg->cfg_para));
+		break;
+	case CIF_PREISP_SUBDEV_G_CTRL:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = cif_preisp_img_src_g_ctrl(
+				cif_preisp_dev->img_src_array[i],
+			(int)(cfg->id),
+			(int *)(cfg->cfg_para));
+		break;
+	case CIF_PREISP_SUBDEV_S_CTRL:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = cif_preisp_img_src_s_ctrl(
+				cif_preisp_dev->img_src_array[i],
+				(int)(cfg->id),
+				*(int *)(cfg->cfg_para));
+		break;
+	case CIF_PREISP_S_EXT_CTRL:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = cif_preisp_img_src_s_ext_ctrls(
+				cif_preisp_dev->img_src_array[i],
+			(struct cif_preisp_img_src_ext_ctrl *)(cfg->cfg_para));
+		break;
+	case CIF_PREISP_IOCTL:
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			ret = cif_preisp_img_src_ioctl(
+				cif_preisp_dev->img_src_array[i],
+				cfg->id,
+				cfg->cfg_para);
+		}
+		break;
+	case CIF_PREISP_POWER_ON:
+		ret = rkpreisp_power_on(cif_preisp_dev);
+		break;
+	case CIF_PREISP_POWER_OFF:
+		ret = rkpreisp_power_off(cif_preisp_dev);
+		break;
+	case CIF_PREISP_INIT_SENSOR:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			doInitSensor(cif_preisp_dev, i);
+		break;
+	case CIF_PREISP_SET_SIZE:
+		//for (i = 0; i < OPEN_CAM_NUM; i++)
+			//ret = doSetSize(cif_preisp_dev, i);
+		break;
+	case CIF_PREISP_STREAM_IN_ON:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = doStartInputStream(cif_preisp_dev, i);
+		break;
+	case CIF_PREISP_STREAM_IN_OFF:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = doStopInputStream(cif_preisp_dev, i);
+		break;
+	case CIF_PREISP_STREAM_OUT_ON:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = doStartOutputStream(cif_preisp_dev, i);
+		break;
+	case CIF_PREISP_STREAM_OUT_OFF:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			ret = doStopOutputStream(cif_preisp_dev, i);
+		break;
+	case CIF_PREISP_CLIENT_NEW:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			cif_preisp_dev->rkpreisp_client[i] = preisp_client_new();
+		break;
+	case CIF_PREISP_CLIENT_RELEASE:
+		for (i = 0; i < OPEN_CAM_NUM; i++)
+			preisp_client_release(cif_preisp_dev->rkpreisp_client[i]);
+		break;
+	case CIF_PREISP_CLIENT_CONNECT:
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			cif_preisp_dev->rkpreisp_client[i]->id = i;
+			ret = preisp_client_connect(cif_preisp_dev,
+				cif_preisp_dev->rkpreisp_client[i]);
+		}
+		break;
+	case CIF_PREISP_CLIENT_DISCONNECT:
+		for (i = 0; i < OPEN_CAM_NUM; i++) {
+			preisp_client_disconnect(cif_preisp_dev,
+				cif_preisp_dev->rkpreisp_client[i]);
+			cif_preisp_dev->rkpreisp_client[i]->id = -1;
+		}
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+int cif_preisp_pltfrm_soc_init(
+	struct spi_rk_preisp_data *cif_preisp_dev,
+	struct pltfrm_soc_cfg *soc_cfg)
+{
+	//struct pltfrm_soc_cfg_para cfg_para;
+	//struct device *dev = cif_preisp_dev->dev;
+	//struct platform_device *pdev =
+		//container_of(dev, struct platform_device, dev);
+	//struct pltfrm_soc_init_para init_para;
+	int ret = 0;
+
+	if (!IS_ERR_OR_NULL(soc_cfg) && !IS_ERR_OR_NULL(soc_cfg->soc_cfg)) {
+		//cfg_para.cmd = PLTFRM_SOC_INIT;
+		//cfg_para.cfg_para = &init_para;
+		//init_para.pdev = pdev;
+		//init_para.isp_base = cif_preisp_dev->config.base_addr;
+		//ret = (soc_cfg->soc_cfg)(&cfg_para);
+		//if (ret == 0)
+		cif_preisp_dev->soc_cfg = soc_cfg;
+	}
+
+	return ret;
+}
+
+int cif_preisp_img_srcs_init(struct spi_rk_preisp_data *dev)
+{
+	int ret = 0;
+
+	dev->img_src_cnt = cif_preisp_pltfrm_get_img_src_device(dev->dev,
+		dev->img_src_array, CIF_PREISP_NUM_INPUTS);
+
+	if (dev->img_src_cnt > 0) {
+		return 0;
+	}
+
+	dev->img_src_cnt = 0;
+	ret = -EFAULT;
+
+	cif_preisp_pltfrm_pr_err(dev->dev,
+		"failed with error %d\n", ret);
+	return ret;
+}
+
+int cif_preisp_create(struct spi_rk_preisp_data *cif_preisp_dev)
+{
+	int ret = 0;
+
+	cif_preisp_dev->cif_preisp_cfg = &cif_preisp_cfg;
+	
+	cif_preisp_pltfrm_soc_init(cif_preisp_dev, &rv1108_cfg);
+
+	ret = cif_preisp_img_srcs_init(cif_preisp_dev);
+	cif_preisp_pltfrm_pr_info(NULL,	"IS_ERR_VALUE(%d) = %lu\n", ret, IS_ERR_VALUE(ret));
+	if (IS_ERR_VALUE(ret))
+		goto err;
+
+	return 0;
+err:
+	cif_preisp_pltfrm_pr_err(NULL,
+		"failed with error %d\n", ret);
+	return ret;
+}
+
diff --git a/drivers/media/platform/preisp_driver/cif-preisp.h b/drivers/media/platform/preisp_driver/cif-preisp.h
new file mode 100644
index 0000000..3eaf147
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp.h
@@ -0,0 +1,335 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef _CIF_PREISP_H
+#define _CIF_PREISP_H
+
+#define CIF_PREISP_NUM_INPUTS 10
+
+#include <linux/platform_device.h>
+#include <media/v4l2-device.h>
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include <linux/wakelock.h>
+#include "cif-preisp-pltfrm.h"
+#include "cif-preisp_img_src.h"
+#include "spi-rkpreisp.h"
+
+/*****************************************************************************/
+/* Definitions */
+
+#define CIF_PREISP_PIX_FMT_Y_AS_BAYER	0
+
+enum cif_preisp_pix_fmt {
+	/* YUV */
+	CIF_YUV400				= 0x10008000,
+	CIF_YVU400				= 0x10008004,
+	CIF_Y10					= 0x1000a000,
+	CIF_Y12 				= 0x10010000,/* bpp is 16bit */
+	CIF_Y12_420SP			= 0x10014211,/* bpp is 20bit */
+	CIF_Y12_422SP			= 0x10018221,/* bpp is 24bit */
+
+	CIF_YUV420I				= 0x1000c220,
+	CIF_YUV420SP			= 0x1000c221,	/* NV12 */
+	CIF_YUV420P				= 0x1000c222,
+	CIF_YVU420I				= 0x1000c224,
+	CIF_YVU420SP			= 0x1000c225,	/* NV21 */
+	CIF_YVU420P				= 0x1000c226,	/* YV12 */
+
+	CIF_YUV422I				= 0x10010240,
+	CIF_YUV422SP			= 0x10010241,
+	CIF_YUV422P				= 0x10010242,
+	CIF_YVU422I				= 0x10010244,
+	CIF_YVU422SP			= 0x10010245,
+	CIF_YVU422P				= 0x10010246,
+
+	CIF_YUV444I				= 0x10018440,
+	CIF_YUV444SP			= 0x10018441,
+	CIF_YUV444P				= 0x10018442,
+	CIF_YVU444I				= 0x10018444,
+	CIF_YVU444SP			= 0x10018445,
+	CIF_YVU444P				= 0x10018446,
+
+	CIF_UYV400				= 0x10008008,
+
+	CIF_UYV420I				= 0x1000c228,
+	CIF_UYV420SP			= 0x1000c229,
+	CIF_UYV420P				= 0x1000c22a,
+	CIF_VYU420I				= 0x1000c22c,
+	CIF_VYU420SP			= 0x1000c22d,
+	CIF_VYU420P				= 0x1000c22e,
+
+	CIF_UYV422I				= 0x10010248,
+	CIF_UYV422SP			= 0x10010249,
+	CIF_UYV422P				= 0x1001024a,
+	CIF_VYU422I				= 0x1001024c,
+	CIF_VYU422SP			= 0x1001024d,
+	CIF_VYU422P				= 0x1001024e,
+
+	CIF_UYV444I				= 0x10018448,
+	CIF_UYV444SP			= 0x10018449,
+	CIF_UYV444P				= 0x1001844a,
+	CIF_VYU444I				= 0x1001844c,
+	CIF_VYU444SP			= 0x1001844d,
+	CIF_VYU444P				= 0x1001844e,
+
+	/* RGB */
+	CIF_RGB565				= 0x20010000,
+	CIF_RGB666				= 0x20012000,
+	CIF_RGB888				= 0x20018000,
+
+	/* RAW Bayer */
+	CIF_BAYER_SBGGR8		= 0x30008000,
+	CIF_BAYER_SGBRG8		= 0x30008010,
+	CIF_BAYER_SGRBG8		= 0x30008020,
+	CIF_BAYER_SRGGB8		= 0x30008030,
+
+	CIF_BAYER_SBGGR10		= 0x3000a000,
+	CIF_BAYER_SGBRG10		= 0x3000a010,
+	CIF_BAYER_SGRBG10		= 0x3000a020,
+	CIF_BAYER_SRGGB10		= 0x3000a030,
+
+	CIF_BAYER_SBGGR12		= 0x3000c000,
+	CIF_BAYER_SGBRG12		= 0x3000c010,
+	CIF_BAYER_SGRBG12		= 0x3000c020,
+	CIF_BAYER_SRGGB12		= 0x3000c030,
+
+	/* JPEG */
+	CIF_JPEG                        = 0x40008000,
+
+	/* Data */
+	CIF_DATA                        = 0x70000000,
+
+	CIF_UNKNOWN_FORMAT              = 0x80000000
+};
+
+enum cif_preisp_cid {
+	CIF_PREISP_CID_FLASH_MODE = 0,
+	CIF_PREISP_CID_EXPOSURE_TIME = 1,
+	CIF_PREISP_CID_ANALOG_GAIN = 2,
+	CIF_PREISP_CID_WB_TEMPERATURE = 3,
+	CIF_PREISP_CID_BLACK_LEVEL = 4,
+	CIF_PREISP_CID_AUTO_GAIN = 5,
+	CIF_PREISP_CID_AUTO_EXPOSURE = 6,
+	CIF_PREISP_CID_AUTO_WHITE_BALANCE = 7,
+	CIF_PREISP_CID_FOCUS_ABSOLUTE = 8,
+	CIF_PREISP_CID_AUTO_N_PRESET_WHITE_BALANCE = 9,
+	CIF_PREISP_CID_SCENE_MODE = 10,
+	CIF_PREISP_CID_SUPER_IMPOSE = 11,
+	CIF_PREISP_CID_JPEG_QUALITY = 12,
+	CIF_PREISP_CID_IMAGE_EFFECT = 13,
+	CIF_PREISP_CID_HFLIP = 14,
+	CIF_PREISP_CID_VFLIP = 15,
+	CIF_PREISP_CID_AUTO_FPS = 16,
+	CIF_PREISP_CID_VBLANKING = 17,
+	CIF_PREISP_CID_ISO_SENSITIVITY = 18,
+	CIF_PREISP_CID_BAND_STOP_FILTER = 19,
+};
+
+struct cif_preisp_frm_intrvl {
+	u32 numerator;
+	u32 denominator;
+};
+
+struct cif_preisp_frm_fmt {
+	u32 width;
+	u32 height;
+	u32 stride;
+	u32 std_id;
+	enum cif_preisp_pix_fmt pix_fmt;
+	struct v4l2_rect defrect;
+};
+
+struct cif_preisp_strm_fmt {
+	struct cif_preisp_frm_fmt frm_fmt;
+	struct cif_preisp_frm_intrvl frm_intrvl;
+};
+
+struct cif_preisp_strm_fmt_desc {
+	bool discrete_frmsize;
+	struct {
+		u32 width;
+		u32 height;
+	} min_frmsize;
+	struct {
+		u32 width;
+		u32 height;
+	} max_frmsize;
+	enum cif_preisp_pix_fmt pix_fmt;
+	bool discrete_intrvl;
+	struct cif_preisp_frm_intrvl min_intrvl;
+	struct cif_preisp_frm_intrvl max_intrvl;
+	struct v4l2_rect defrect;
+	u32 std_id;
+};
+
+enum {
+    //AP -> DSP sensor msg
+    id_msg_init_sensor_t = 0x0001,
+    id_msg_set_input_size_t,
+    id_msg_set_output_size_t,
+    id_msg_set_stream_in_on_t,
+    id_msg_set_stream_in_off_t,
+    id_msg_set_stream_out_on_t,
+    id_msg_set_stream_out_off_t,
+
+	/* 1 msg of take picture */
+	id_msg_take_picture_t =         0x0021,
+	id_msg_take_picture_done_t,
+
+	/* 2 msg of realtime parameter */
+	id_msg_rt_args_t =          0x0031,
+
+	/* 5 msg of print log */
+	id_msg_init_sensor_ret_t =      0x0300 + 0x0001,
+    id_msg_set_input_size_ret_t,
+	id_msg_set_output_size_ret_t,
+	id_msg_set_stream_in_on_ret_t,
+	id_msg_set_stream_in_off_ret_t,
+	id_msg_set_stream_out_on_ret_t,
+	id_msg_set_stream_out_off_ret_t,
+
+	/* DSP -> AP
+	 *6 response of take picture msg */
+	id_msg_take_picture_ret_t =			0x0320,
+	id_msg_take_picture_done_ret_t,
+
+	/* DSP -> AP
+	 *7 response of realtime parameter msg */
+	id_msg_rt_args_ret_t =			0x0330,
+
+	/*9 msg of xfile */
+	id_msg_xfile_import_t =         0xfe00,
+	id_msg_xfile_export_t,
+	id_msg_xfile_mkdir_t,
+};
+
+// AP -> DSP msg
+
+typedef struct {
+	uint32_t size;
+	uint16_t type;
+	int8_t   camera_id;
+	int8_t   sync;
+	uint32_t i2c_bus; //unused
+	uint32_t i2c_clk; //unused
+
+	int8_t in_mipi_phy;
+	int8_t out_mipi_phy;
+	int8_t mipi_lane;
+	int8_t bayer;
+	uint8_t sensor_name[32];
+} msg_init_sensor_t;
+
+typedef struct {
+    int8_t   data_id;
+    int8_t   decode_format;
+    int8_t   flag;
+    int8_t   unused;
+
+    uint16_t width;
+    uint16_t height;
+} preisp_vc_cfg_t;
+
+typedef msg_t msg_set_input_size_head_t;
+
+typedef struct {
+    msg_set_input_size_head_t head;
+    preisp_vc_cfg_t channel[0];
+} msg_set_input_size_t;
+
+typedef struct {
+    uint32_t size;
+    uint16_t type;
+    int8_t   camera_id;
+    int8_t   sync;
+
+    uint16_t width;
+    uint16_t height;
+
+    uint32_t mipi_clk;
+    uint16_t line_length_pclk;
+    uint16_t frame_length_lines;
+} msg_set_output_size_t;
+
+typedef msg_t msg_set_stream_in_on_t;
+typedef msg_t msg_set_stream_in_off_t;
+typedef msg_t msg_set_stream_out_on_t;
+typedef msg_t msg_set_stream_out_off_t;
+typedef msg_t msg_take_picture_done_t;
+typedef msg_t msg_set_sys_mode_bypass_t;
+typedef msg_t msg_set_sys_mode_standby_t;
+
+enum {
+	ALGO_NIGHTSHOT,
+	ALGO_ANTISHAKING,
+	ALGO_HDR,
+	ALGO_MFHDR,
+	ALGO_LLHDR,
+};
+
+// DSP -> AP msg
+typedef struct {
+    uint32_t size;
+    uint16_t type;
+    int8_t   camera_id;
+    int8_t   err;
+} msg_response_t;
+
+typedef msg_response_t msg_rt_args_ret_t;
+typedef msg_response_t msg_init_sensor_ret_t;
+typedef msg_response_t msg_set_input_size_ret_t;
+typedef msg_response_t msg_set_output_size_ret_t;
+typedef msg_response_t msg_set_stream_in_on_ret_t;
+typedef msg_response_t msg_set_stream_in_off_ret_t;
+typedef msg_response_t msg_set_stream_out_on_ret_t;
+typedef msg_response_t msg_set_stream_out_off_ret_t;
+typedef msg_response_t msg_take_picture_ret_t;
+typedef msg_response_t msg_take_picture_done_ret_t;
+
+typedef struct {
+    uint32_t size;
+    uint16_t type;
+    int8_t   camera_id;
+    uint8_t  division;
+} msg_stats_head_t;
+
+typedef struct {
+    msg_stats_head_t head;
+    uint16_t data[2];
+} msg_stats_data_t;
+
+
+#if 0
+#define MSG_SIZE(m) ((m).size * 4)
+
+#define MSG(TYPE, ID, var) TYPE var; \
+    var.size = sizeof(TYPE)/4;\
+    var.type = id_ ## TYPE;\
+    var.camera_id = ID
+
+//AP -> DSP sync msg, dsp must send msg_response_t to AP
+#define SYNC_MSG(TYPE, ID, var) MSG(TYPE, ID, var); var.sync = 1
+
+//AP -> DSP async msg, dsp not need to send msg_response_t to AP
+#define ASYNC_MSG(TYPE, ID, var) MSG(TYPE, ID, var); var.sync = 0
+
+//DSP -> AP msg
+#define RET_MSG(TYPE, var) MSG(TYPE, -1, var)
+#endif
+
+int cif_preisp_create(struct spi_rk_preisp_data *cif_preisp_dev);
+#endif
diff --git a/drivers/media/platform/preisp_driver/cif-preisp.rar b/drivers/media/platform/preisp_driver/cif-preisp.rar
new file mode 100644
index 0000000000000000000000000000000000000000..e44e8f1095ff63d283e586981d3d0d26232d1760
GIT binary patch
literal 3437
zcmV-z4U+OwVR9iF2LR8Ia{vGh000000002*-*g~=EC41A002Kj0006WS&f-vUhPU9
zGYkNL0001EX=W{Oa%E|Aa4usEA<)ds(L9<Nz0ZK}gROcj4ZA#hwu{njye7Ei<~l~;
zjmy2gdW0NJDA!inT9R_vz1QyiIk@C&!1D<!%+j6>x6u6(Bu-`=%s;aZB2xISe}o_3
ziAMk^5-{d0Kp#fcZ|D50c(>-uI<ef!A@M^3YMp&#`jJ@Vl<n);;yTUFQ@1vE2uD-%
zyt+5eQyVLdgmA$sT||?;^X)2$K?^IWuUkLUfrhPKsoT4Io`V|lDbSu2dloENF{Xv)
z6Kw^~_TuRN(q{gXxUzou6v+C;VXq*<$^qtar)=w;#>M@Yae^T(v}S2mh0?X`M+Z_%
zB8aSPe6MIb=XHWLzBG-Y-)9>oK8%hq(VNARzqAZyB^hM8$cPI}nLue6z|dME*qbe}
zN!jhS&)cJolD(xaT%8zPF~PfbL3V2JV`E~wM!t7JQ37SeDlN>o(NqM<8`ls;Fu!g<
zd8>zhopZ60I{C$mkS#n{#j}cu#ZX*&&cez*ceCT5XKT3ae)RF7hb8wA{Isi&C(mhI
zN37?r1&JM;9?19ISg&Eiq7qkY8!>i}000YoB06X$mcpwdn(DI@^6c2Zk*sy>E!DZX
zx9TA%6SO3nQ%1MTV$t>ZIS;kZ$adrQ{5C&6e`)--`1sG{x1t}-V}pl5x$Qe{DIW`1
z<v)N4?lw;jWnbNwU|Ju?ZM)CAV&&1kW|%t?|FPm4kL}QMuB30C$n?|z!;t~J=|A?!
zk7{*q+g$BF<7Li%>6FD+d|0MP0GbZmtA&Qp#Cqx=dI>Z_wuI{So&OqTEu43;A{}8B
zLcMZ+u5WI;n|p+tTyNbu^}32O2#*kMK$qxDU|0+4S8;tY=Qvkak@f3DO{@G*EB|Xw
zL3rxQkNZgCYJ-8<z7g^&fcLa!0}tB-ts@yBg)~CqvA^J^LAO1;epL$I(k+h1u{+>O
zM8I2|Z{40lJ3y<2Ln-C8Dl!4KMTR?A3vZ*XUX%=oU8q9JiH5dAEqjS3<VD(3VNcf5
zcM5O#Zl8f4m}HW*DT<mYt?F&vP`7MWsumhD>Hg@bl|jUXp!>k3G@;>8#IRsHa*p-Z
z(YF-S7LMz_6xkD4S_9`HGF4gRFhd&gOr29{Y9DwZI<sBicdmA={Z3z`m~Mg=1;7eF
zW7zVXTaS4ZkB0eI;3gQ$d1=;kO9Wi&8L)4(j;WPZBt$m;jOy-aY0e&s%T%?`$Hp-g
z+Eap)IV-`aHUGQ)W2QuDv1=S$4L<1D1GuFpB?u~Lr$qi)`wnyjWpH;tqj)jkpP3j?
z0m0M?gG>kvagcn&)>#COf+}QVlS?6|>};Zao0X8TvAh3h4H@t}61fl%o-~vw2{^IB
zzDD<5eHWn+r1=nHQ0gRa?;Y>+WM#X5hj7PQusgsM6CeRyZ~-c1Mf^L~OJOn0-Imfd
zA}W6%&!f@m8JC+VsyYzH>8WlC0l?Q6dH&N$CT)6<^DtbAho{^kS(0rGO1C5d8&uE~
zBx0eR_ZKuxZ9avHQ6Xw#7cc2kT%=lvUCeZ;rL%y{z28T$cb&k6$KBJ1YaH|He&~B%
zRiH`a5+?{^)h;Fgke0x=g0#hg(=DU?gMv;lA*<|}OEV@}(6jO}Gz)I@>Rir&sPg0L
zP$(+CrJQN8a4RcOZt+E?*459})p3(hfY5FN3s)jA@PV=vzM)1T8=2&Nd6(We86-)a
z+BxU(bGN<QHtlFG#ZV(QN*thT-wzO~cG2I7sTLu5Medb|?ctTdCI%opE02Xr(Qy8}
zXk}ZFsWlsh%54<E<Ew+L!=er7NOETQmsoFOL@xJo`{=#aipIpL23R1kT|u`p>@{kG
zu2ZY=^!mT0GfC<_HU`Y-6|mN-?2%s70{WK`V&FWgI2d(t$@p%QBOQ*xCINK^yWEE=
z!R7~r748(EtjKkMAWl1-1`&YDl|kVclCeTHDGR_I$FO1P;(?eEnY75_?uODCLk%(|
z&XmCon-IdxTwXFG0ynRYG3R{De{EJ7AG-PWJ(!<<gktJ78rxBFCbPIXosUsGL%}-_
zBf(FRQbM<{iF~sv7FmAYE>r)#j%!vp;vgJ2S6DAh&fYm3)5Ky(%0@1ulE92}U6W>V
zp+ooxZ^|Q`Wc>bg$)<3X!bl;4@OZ3Y_owjL7#l7%xAWcT-_#Z&f}OeHi{iY*?8z)Q
zx?(QUB;O|jV*tr7)9UqV3a}zgq!3B^H(<lTbnPr%M66)b<&lz+JYO|{Y6T?weW5f3
z_>PtJ4JNZBNBjM9-*{rPWVALvj*^qGw1oU3==dNwCb0Mqi=+d`5+$%?Q%XpN29?ti
z1cGA@K(dksj9~Fxgn}tbY0DK60~L>_G-Ahz<h19Dr$KBY1v1)22c@+pnaE-Ijk_#w
z&t8Vs<AGsEA4_K*sY!PJeuj|o0ztVH@d%c#LN8DM5=tnQ){zp^LM9XfyVz<}N<#-z
zM(|mSBPo3ap|~|4Q`owbJC=))9uo6COmM}A)TvsGscLCoj$ucol14pYq~gc081q=W
zE?`HHHLx)Lz;xxUoa@IN!ed@v6B!SQY}#Q8Wfky3lyc%2s2dpu<s_jB$#Pf4sFC<F
zaM#^K&V}IPuto1<;$Z-;R)%RW0!guiDVZHEriL@GjsV9rsOat3nr7yhs>8%aXrbrh
zKql{RBOY2bhsN>P&Ft-rvF3p3hHt^t&S+*d%`OSt_-kj&?Gd!1zru~3T<cvX`pDa%
zPQBwFBpbA8*t%=q#`~v~F~Oa_%^W5NWZ)M`?nL0;q7Hmhs|Wq=6&PhY73VuTuyo1s
zYL9Ym_CSL-QzO>*7gZ^URDp{D*=enO@GubH{e3Vy>yL4CS-5?UZe#8C!vOUkH7@_8
z=YEQwH3QLN6=cp*4)mzK`Zn~i#9|n)_a1BUqBI6lL$E5(8nFm%=z(xyIzS{}Tc}+8
z7E)2RhJx>H()l_9-!senlMX580C|HZ6ouu{CqG{=HHRAIKIPu;gOGR7sYTi7f#`(=
zkDtzEu#B~0as$??WbuR*SsoVfTI2C|r|_BQ!<`@v&%~S#4?p`W&$kU4SEV_?%J^R5
zP6sQt^F=x3un*Mal@X8_KJy1tOW=k58H?W&c6}Xju(&6pF^4AmwZy&@QC6p*vUr5%
zAKt~1Kk%(9$?5|#Uadq?nDU%`g$;+lM8jgX@eTZ$z(m354knJ_;L;63aS%>Csl>s;
zC(bH2C^R@d(J-{-;*2R+xsgDJJ->>`Qhh2djmaE~QD3%1oMp4^@NQ4(X!U`Jr-&*4
zSq!170Z$)INj$%FrNGv`)){(bW>-$4<B~0e>93~&P?l++G_P~uziAg-&Rc(_j&Ca0
zE@o2;j$S?L(kiFRFdj*7%5mx}UJEgcA_b2T3bC*=f{~0F^K`CkFV9>!dUKPf3l3cp
zj!7iEGn0(5M{<qJ-(0S$9Z7)EVaK6GF!*?KkCSFoqqUv>9V`SX4QSoR7bV-2IDM9O
z$m7X~WIdcq6ARGY?M$DB>7B}V>bq$l$lcWNBNs#Jud;CX9eZc+*tuWD9{TS$y^&?!
zG^@eXGn!e_?*)VG+Ph<$-NDB^XY)K>La?5)D|KGO;hHhdAVxM^v`R}f9^9vov>iEm
zo1Fij4Ucd%_3ra{t2*P0P}wop1}u4vpM7I)WvE{)i6%O3n0bg`vHmXSsz>I*85$hr
zWCNR}4x}i|)th=&<MBy|CZmB-GLYFl2eswretA`4_U&&y?J7>{4%DQ0xTX?Pl&4F+
zJ63Lo!s~M1H3T2(_G{)vkZ+b;v;J&R#fGbAj$acd;5aqT<c${>iR91VR0C!O89`BA
z${T$5d<%ku<$2(gF8<*&eCzSqZU+9fWAw`lz;5>H)V&jq#|6q12KXJLO<JK|-K$nB
z-J#9qi@l#Q^HjvmLrwyC&iyAX7Y>Ksnpz&)T=jCIZM4N`+LBkYVPkp~r_x{K@sHuY
zA4nj2%JnEbW7_YQL;7KB8=>ET_DGn#db!(v2}BM-D0=6S&liqr3R%ZP+fI9ry;2*C
zk7!|(E_J1{YB^AnBa<~{-PE=MUK5-u-uF)YZb)-{f3Y~k-Eo2Om`YvgP0~XKkX_8>
z_Ct$o6a2h)L&2batHIXKekmck0H<0K!<{|fvR5v0rg#vp#qRVB7RP<y@RCobWN%Ns
ze)`5cD{&oysjUu@aKTOH$R9M}C4(0Md+UTZO#opUo8`(dCI#r`{Fl`eN)<rpV~J8B
zfH?Amx<>yn0R(X)!aYfv@MQEmDE4h~^WC`r%u^c}_C2u<X5(%56(F*b^sH9H+@v98
zGs@!n<4m70B*w-Lss5l6aAIfTIe=L)kTF1vFF*iBv^x=3A)7^(R9XhLp8JN)kP^NH
ztH_`P&r`HBN|~d0HUc^9RP$e|3I8@6j=e7875KhNu{qKpT#it`^U1%FqU?+F3~Kj@
PJI-<c<itID06+%-%Lb}o

literal 0
HcmV?d00001

diff --git a/drivers/media/platform/preisp_driver/cif-preisp_img_src.c b/drivers/media/platform/preisp_driver/cif-preisp_img_src.c
new file mode 100644
index 0000000..be3c310
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp_img_src.c
@@ -0,0 +1,226 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#include <linux/kernel.h>
+#include <linux/platform_data/rk_isp11_platform.h>
+#include "cif-preisp.h"
+#include "cif-preisp_img_src_ops.h"
+
+struct cif_preisp_img_src {
+	void *img_src;
+	const struct cif_preisp_img_src_ops *ops;
+};
+
+struct cif_preisp_img_src *cif_preisp_img_src_to_img_src(
+	CIF_PREISP_PLTFRM_DEVICE dev,
+	struct pltfrm_soc_cfg *soc_cfg)
+{
+	int ret = 0;
+	int i;
+	const char *device_type;
+	struct cif_preisp_img_src *img_src;
+
+	img_src = devm_kzalloc(dev, sizeof(*img_src), GFP_KERNEL);
+	if (NULL == img_src) {
+		ret = -ENOMEM;
+		goto err;
+	}
+
+	device_type = cif_preisp_pltfrm_get_device_type(dev);
+
+	img_src->ops = NULL;
+	for (i = 0; i < ARRAY_SIZE(cif_preisp_img_src_ops); i++) {
+		if (!strcmp(device_type, cif_preisp_img_src_ops[i].device_type)) {
+			img_src->ops = &cif_preisp_img_src_ops[i].ops;
+			break;
+		}
+	}
+	if (NULL == img_src->ops) {
+		cif_preisp_pltfrm_pr_err(NULL,
+			"unsupported device type %s\n",
+			device_type);
+		ret = -EINVAL;
+		goto err;
+	}
+
+	BUG_ON(NULL == img_src->ops->to_img_src);
+	BUG_ON(NULL == img_src->ops->s_streaming);
+	BUG_ON(NULL == img_src->ops->s_power);
+	BUG_ON(NULL == img_src->ops->enum_strm_fmts);
+	BUG_ON(NULL == img_src->ops->s_strm_fmt);
+	BUG_ON(NULL == img_src->ops->g_ctrl);
+	BUG_ON(NULL == img_src->ops->s_ctrl);
+
+	img_src->img_src = img_src->ops->to_img_src(dev, soc_cfg);
+	if (IS_ERR_OR_NULL(img_src->img_src)) {
+		cif_preisp_pltfrm_pr_err(NULL,
+			"to_img_src failed!\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+	return img_src;
+err:
+	cif_preisp_pltfrm_pr_err(NULL, "failed with error %d\n",
+		ret);
+	if (!IS_ERR_OR_NULL(img_src))
+		devm_kfree(dev, img_src);
+
+	return ERR_PTR(ret);
+}
+
+int cif_preisp_img_src_s_streaming(
+	struct cif_preisp_img_src *img_src,
+	bool enable)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+
+	cif_preisp_pltfrm_pr_info(NULL, "xuhf------%s: enable: %d\n", __FUNCTION__, enable);
+	return img_src->ops->s_streaming(img_src->img_src, enable);
+}
+
+int cif_preisp_img_src_s_power(
+	struct cif_preisp_img_src *img_src,
+	bool on)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+
+	cif_preisp_pltfrm_pr_info(NULL, "xuhf------%s: on: %d\n", __FUNCTION__, on);
+	return img_src->ops->s_power(img_src->img_src, on);
+}
+
+int cif_preisp_img_src_enum_strm_fmts(
+	struct cif_preisp_img_src *img_src,
+	u32 index,
+	struct cif_preisp_strm_fmt_desc *strm_fmt_desc)
+{
+	cif_preisp_pltfrm_pr_info(NULL, "xuhf------%s: img_src: %p\n", __FUNCTION__, img_src);
+
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+
+	return img_src->ops->enum_strm_fmts(img_src->img_src,
+		index, strm_fmt_desc);
+}
+
+int cif_preisp_img_src_s_strm_fmt(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_strm_fmt *strm_fmt)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+	return img_src->ops->s_strm_fmt(img_src->img_src, strm_fmt);
+}
+
+int cif_preisp_img_src_g_ctrl(
+	struct cif_preisp_img_src *img_src,
+	int id,
+	int *val)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+	return img_src->ops->g_ctrl(img_src->img_src, id, val);
+}
+
+int cif_preisp_img_src_s_ctrl(
+	struct cif_preisp_img_src *img_src,
+	int id,
+	int val)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+	return img_src->ops->s_ctrl(img_src->img_src, id, val);
+}
+
+int cif_preisp_img_src_s_ext_ctrls(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_img_src_ext_ctrl *ctrl)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+	return img_src->ops->s_ext_ctrls(img_src->img_src, ctrl);
+}
+
+long cif_preisp_img_src_ioctl(
+	struct cif_preisp_img_src *img_src,
+	unsigned int cmd,
+	void *arg)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return -EINVAL;
+	}
+	return img_src->ops->ioctl(img_src->img_src, cmd, arg);
+}
+
+const char *cif_preisp_img_src_g_name(
+	struct cif_preisp_img_src *img_src)
+{
+	if (NULL == img_src) {
+		cif_preisp_pltfrm_pr_err(NULL, "img_src is NULL\n");
+		return ERR_PTR(-EINVAL);
+	}
+	return img_src->ops->g_name(img_src->img_src);
+}
+
+void *cif_preisp_img_src_g_img_src(
+	struct cif_preisp_img_src *img_src)
+{
+	if (img_src) {
+		return img_src->img_src;
+	}
+
+	return NULL;
+}
+
+int cif_preisp_img_src_s_frame_interval(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl)
+{
+	if (img_src)
+		return img_src->ops->s_frame_interval(
+			img_src->img_src,
+			frm_intrvl);
+	return -EINVAL;
+}
+
+int cif_preisp_img_src_g_frame_interval(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl)
+{
+	if (img_src)
+		return img_src->ops->g_frame_interval(
+			img_src->img_src,
+			frm_intrvl);
+	return -EINVAL;
+}
+
diff --git a/drivers/media/platform/preisp_driver/cif-preisp_img_src.h b/drivers/media/platform/preisp_driver/cif-preisp_img_src.h
new file mode 100644
index 0000000..f6ecb5e
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp_img_src.h
@@ -0,0 +1,90 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef _CIF_PREISP_IMG_SRC_H
+#define _CIF_PREISP_IMG_SRC_H
+
+struct cif_preisp_img_src;
+struct cif_preisp_strm_fmt_desc;
+struct cif_preisp_strm_fmt;
+enum cif_preisp_pix_fmt;
+struct cif_preisp_frm_intrvl;
+struct pltfrm_soc_cfg;
+
+struct cif_preisp_img_src_ctrl {
+	unsigned int id;
+	int val;
+};
+
+struct cif_preisp_img_src_ext_ctrl {
+	int cnt;
+	unsigned int class;
+	struct cif_preisp_img_src_ctrl *ctrls;
+};
+
+struct cif_preisp_img_src *cif_preisp_img_src_to_img_src(
+	CIF_PREISP_PLTFRM_DEVICE dev,
+	struct pltfrm_soc_cfg *soc_cfg);
+
+int cif_preisp_img_src_s_streaming(
+	struct cif_preisp_img_src *img_src,
+	bool enable);
+
+int cif_preisp_img_src_s_power(
+	struct cif_preisp_img_src *img_src,
+	bool on);
+
+int cif_preisp_img_src_enum_strm_fmts(
+	struct cif_preisp_img_src *img_src,
+	u32 index,
+	struct cif_preisp_strm_fmt_desc *strm_fmt_desc);
+
+int cif_preisp_img_src_s_strm_fmt(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_strm_fmt *strm_fmt);
+
+int cif_preisp_img_src_g_ctrl(
+	struct cif_preisp_img_src *img_src,
+	int id,
+	int *val);
+
+int cif_preisp_img_src_s_ctrl(
+	struct cif_preisp_img_src *img_src,
+	int id,
+	int val);
+
+const char *cif_preisp_img_src_g_name(
+	struct cif_preisp_img_src *img_src);
+
+int cif_preisp_img_src_s_ext_ctrls(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_img_src_ext_ctrl *ctrls);
+
+long cif_preisp_img_src_ioctl(
+	struct cif_preisp_img_src *img_src,
+	unsigned int cmd,
+	void *arg);
+void *cif_preisp_img_src_g_img_src(
+	struct cif_preisp_img_src *img_src);
+
+int cif_preisp_img_src_s_frame_interval(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl);
+
+int cif_preisp_img_src_g_frame_interval(
+	struct cif_preisp_img_src *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl);
+#endif
diff --git a/drivers/media/platform/preisp_driver/cif-preisp_img_src_ops.h b/drivers/media/platform/preisp_driver/cif-preisp_img_src_ops.h
new file mode 100644
index 0000000..09be54c
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp_img_src_ops.h
@@ -0,0 +1,98 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef _CIF_PREISP_IMG_SRC_OPS_H
+#define _CIF_PREISP_IMG_SRC_OPS_H
+#include <linux/platform_data/rk_isp11_platform.h>
+#include "cif-preisp_img_src_v4l2-subdev.h"
+
+struct cif_preisp_img_src_ops {
+	void * (*to_img_src)(
+		CIF_PREISP_PLTFRM_DEVICE dev,
+		struct pltfrm_soc_cfg *soc_cfg);
+	int (*s_streaming)(
+		void *img_src,
+		bool enable);
+	int (*s_power)(
+		void *img_src,
+		bool on);
+	int (*enum_strm_fmts)(
+		void *img_src,
+		u32 index,
+		struct cif_preisp_strm_fmt_desc *strm_fmt_desc);
+	int (*s_strm_fmt)(
+		void *img_src,
+		struct cif_preisp_strm_fmt *strm_fmt);
+	int (*g_ctrl)(
+		void *img_src,
+		int id,
+		int *val);
+	const char * (*g_name)(
+		void *img_src);
+	int (*s_ctrl)(
+		void *img_src,
+		int id,
+		int val);
+	int (*s_ext_ctrls)(
+		void *img_src,
+	    struct cif_preisp_img_src_ext_ctrl *ctrl);
+	long (*ioctl)(
+		void *img_src,
+		unsigned int cmd,
+		void *arg);
+	int (*s_frame_interval)(
+		void *img_src,
+		struct cif_preisp_frm_intrvl *frm_intrvl);
+	int (*g_frame_interval)(
+		void *img_src,
+		struct cif_preisp_frm_intrvl *frm_intrvl);
+};
+
+const struct {
+	const char *device_type;
+	struct cif_preisp_img_src_ops ops;
+} cif_preisp_img_src_ops[] = {
+	{
+		.device_type = CIF_PREISP_IMG_SRC_V4L2_I2C_SUBDEV,
+		.ops = {
+			.to_img_src =
+				cif_preisp_img_src_v4l2_i2c_subdev_to_img_src,
+			.s_streaming =
+				cif_preisp_img_src_v4l2_subdev_s_streaming,
+			.s_power =
+				cif_preisp_img_src_v4l2_subdev_s_power,
+			.enum_strm_fmts =
+				cif_preisp_img_src_v4l2_subdev_enum_strm_fmts,
+			.s_strm_fmt =
+				cif_preisp_img_src_v4l2_subdev_s_strm_fmt,
+			.g_ctrl =
+				cif_preisp_img_src_v4l2_subdev_g_ctrl,
+			.g_name =
+				cif_preisp_img_src_v4l2_subdev_g_name,
+			.s_ctrl =
+				cif_preisp_img_src_v4l2_subdev_s_ctrl,
+			.s_ext_ctrls =
+				cif_preisp_img_src_v4l2_subdev_s_ext_ctrls,
+			.ioctl =
+				cif_preisp_img_src_v4l2_subdev_ioctl,
+			.s_frame_interval =
+				cif_preisp_img_src_v4l2_subdev_s_frame_interval,
+			.g_frame_interval =
+				cif_preisp_img_src_v4l2_subdev_g_frame_interval,
+		}
+	},
+};
+#endif
diff --git a/drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.c b/drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.c
new file mode 100644
index 0000000..59c5426
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.c
@@ -0,0 +1,520 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+#include "cif-preisp.h"
+#include <linux/platform_data/rk_isp11_platform.h>
+#include <media/v4l2-controls_rockchip.h>
+#include <linux/slab.h>
+/* ===================== */
+/* Image Source */
+/* ===================== */
+void *cif_preisp_img_src_v4l2_i2c_subdev_to_img_src(
+	struct device *dev,
+	struct pltfrm_soc_cfg *soc_cfg)
+{
+	int ret = 0;
+	struct i2c_client *client;
+	struct v4l2_subdev *subdev;
+
+	client = i2c_verify_client(dev);
+	if (IS_ERR_OR_NULL(client)) {
+		cif_preisp_pltfrm_pr_err(dev,
+			"not an I2C device\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	subdev = i2c_get_clientdata(client);
+	if (IS_ERR_OR_NULL(subdev))
+		return subdev;
+
+	ret = v4l2_subdev_call(subdev,
+		core,
+		ioctl,
+		PLTFRM_CIFCAM_ATTACH,
+		(void *)soc_cfg);
+	if (ret != 0)
+		goto err;
+
+	return (void *)subdev;
+err:
+	cif_preisp_pltfrm_pr_err(NULL, "failed with error %d\n", ret);
+	return ERR_PTR(ret);
+}
+
+static enum cif_preisp_pix_fmt img_src_v4l2_subdev_pix_fmt2cif_preisp_pix_fmt(
+	int img_src_pix_fmt)
+{
+	switch (img_src_pix_fmt) {
+	case V4L2_MBUS_FMT_Y8_1X8:
+		#if (CIF_PREISP_PIX_FMT_Y_AS_BAYER)
+		return CIF_BAYER_SBGGR8;
+		#else
+		return CIF_YUV400;
+		#endif
+	case V4L2_MBUS_FMT_Y10_1X10:
+		#if (CIF_PREISP_PIX_FMT_Y_AS_BAYER)
+		return CIF_BAYER_SBGGR10;
+		#else
+		return CIF_Y10;
+		#endif
+	case V4L2_MBUS_FMT_Y12_1X12:
+		#if (CIF_PREISP_PIX_FMT_Y_AS_BAYER)
+		return CIF_BAYER_SBGGR12;
+		#else
+		return CIF_Y12;
+		#endif
+
+	case V4L2_MBUS_FMT_YUYV8_1_5X8:
+	case V4L2_MBUS_FMT_YUYV8_2X8:
+	case V4L2_MBUS_FMT_YUYV10_2X10:
+	case V4L2_MBUS_FMT_YUYV8_1X16:
+	case V4L2_MBUS_FMT_YUYV10_1X20:
+		return CIF_YUV422I;
+	case V4L2_MBUS_FMT_UYVY8_1_5X8:
+	case V4L2_MBUS_FMT_UYVY8_2X8:
+	case V4L2_MBUS_FMT_UYVY8_1X16:
+		return CIF_UYV422I;
+	case V4L2_MBUS_FMT_RGB565_2X8_BE:
+	case V4L2_MBUS_FMT_RGB565_2X8_LE:
+		return CIF_RGB565;
+	case V4L2_MBUS_FMT_RGB666_1X18:
+		return CIF_RGB666;
+	case V4L2_MBUS_FMT_RGB888_1X24:
+	case V4L2_MBUS_FMT_RGB888_2X12_BE:
+	case V4L2_MBUS_FMT_RGB888_2X12_LE:
+		return CIF_RGB888;
+	case V4L2_MBUS_FMT_SBGGR8_1X8:
+		return CIF_BAYER_SBGGR8;
+	case V4L2_MBUS_FMT_SGBRG8_1X8:
+		return CIF_BAYER_SGBRG8;
+	case V4L2_MBUS_FMT_SGRBG8_1X8:
+		return CIF_BAYER_SGRBG8;
+	case V4L2_MBUS_FMT_SRGGB8_1X8:
+		return CIF_BAYER_SRGGB8;
+	case V4L2_MBUS_FMT_SBGGR10_ALAW8_1X8:
+	case V4L2_MBUS_FMT_SBGGR10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_BE:
+	case V4L2_MBUS_FMT_SBGGR10_2X8_PADHI_LE:
+	case V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_BE:
+	case V4L2_MBUS_FMT_SBGGR10_2X8_PADLO_LE:
+	case V4L2_MBUS_FMT_SBGGR10_1X10:
+		return CIF_BAYER_SBGGR10;
+	case V4L2_MBUS_FMT_SGBRG10_ALAW8_1X8:
+	case V4L2_MBUS_FMT_SGBRG10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SGBRG10_1X10:
+		return CIF_BAYER_SGBRG10;
+	case V4L2_MBUS_FMT_SGRBG10_ALAW8_1X8:
+	case V4L2_MBUS_FMT_SGRBG10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SGRBG10_1X10:
+		return CIF_BAYER_SGRBG10;
+	case V4L2_MBUS_FMT_SRGGB10_ALAW8_1X8:
+	case V4L2_MBUS_FMT_SRGGB10_DPCM8_1X8:
+	case V4L2_MBUS_FMT_SRGGB10_1X10:
+		return CIF_BAYER_SRGGB10;
+	case V4L2_MBUS_FMT_SBGGR12_1X12:
+	    return CIF_BAYER_SBGGR12;
+	case V4L2_MBUS_FMT_SGBRG12_1X12:
+		return CIF_BAYER_SGBRG12;
+	case V4L2_MBUS_FMT_SGRBG12_1X12:
+		return CIF_BAYER_SGRBG12;
+	case V4L2_MBUS_FMT_SRGGB12_1X12:
+		return CIF_BAYER_SRGGB12;
+	case V4L2_MBUS_FMT_JPEG_1X8:
+		return CIF_JPEG;
+	default:
+		return CIF_UNKNOWN_FORMAT;
+	}
+}
+
+static int cif_preisp_pix_fmt2img_src_v4l2_subdev_pix_fmt(
+	enum cif_preisp_pix_fmt cif_preisp_pix_fmt)
+{
+	switch (cif_preisp_pix_fmt) {
+	case CIF_Y10:
+		return V4L2_MBUS_FMT_Y10_1X10;
+	case CIF_Y12:
+		return V4L2_MBUS_FMT_Y12_1X12;
+	case CIF_YUV400:
+		return V4L2_MBUS_FMT_Y8_1X8;
+	case CIF_YUV422I:
+		return V4L2_MBUS_FMT_YUYV8_2X8;
+	case CIF_UYV422I:
+		return V4L2_MBUS_FMT_UYVY8_2X8;
+	case CIF_RGB565:
+		return V4L2_MBUS_FMT_RGB565_2X8_LE;
+	case CIF_RGB666:
+		return V4L2_MBUS_FMT_RGB666_1X18;
+	case CIF_RGB888:
+		return V4L2_MBUS_FMT_RGB888_1X24;
+	case CIF_BAYER_SBGGR8:
+		#if (CIF_PREISP_PIX_FMT_Y_AS_BAYER)
+		return V4L2_MBUS_FMT_Y8_1X8;
+		#else
+		return V4L2_MBUS_FMT_SBGGR8_1X8;
+		#endif
+	case CIF_BAYER_SGBRG8:
+		return V4L2_MBUS_FMT_SGBRG8_1X8;
+	case CIF_BAYER_SGRBG8:
+		return V4L2_MBUS_FMT_SGRBG8_1X8;
+	case CIF_BAYER_SRGGB8:
+		return V4L2_MBUS_FMT_SRGGB8_1X8;
+	case CIF_BAYER_SBGGR10:
+		#if (CIF_PREISP_PIX_FMT_Y_AS_BAYER)
+		return V4L2_MBUS_FMT_Y10_1X10;
+		#else
+		return V4L2_MBUS_FMT_SBGGR10_1X10;
+		#endif
+	case CIF_BAYER_SGBRG10:
+		return V4L2_MBUS_FMT_SGBRG10_1X10;
+	case CIF_BAYER_SGRBG10:
+		return V4L2_MBUS_FMT_SGRBG10_1X10;
+	case CIF_BAYER_SRGGB10:
+		return V4L2_MBUS_FMT_SRGGB10_1X10;
+	case CIF_BAYER_SBGGR12:
+		#if (CIF_PREISP_PIX_FMT_Y_AS_BAYER)
+		return V4L2_MBUS_FMT_Y12_1X12;
+		#else
+		return V4L2_MBUS_FMT_SBGGR12_1X12;
+		#endif
+	case CIF_BAYER_SGBRG12:
+		return V4L2_MBUS_FMT_SGBRG12_1X12;
+	case CIF_BAYER_SGRBG12:
+		return V4L2_MBUS_FMT_SGRBG12_1X12;
+	case CIF_BAYER_SRGGB12:
+		return V4L2_MBUS_FMT_SRGGB12_1X12;
+	case CIF_JPEG:
+		return V4L2_MBUS_FMT_JPEG_1X8;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int cif_preisp_v4l2_cid2v4l2_cid(u32 cif_preisp_cid)
+{
+	switch (cif_preisp_cid) {
+	case CIF_PREISP_CID_FLASH_MODE:
+		return V4L2_CID_FLASH_LED_MODE;
+	case CIF_PREISP_CID_AUTO_GAIN:
+		return V4L2_CID_AUTOGAIN;
+	case CIF_PREISP_CID_AUTO_EXPOSURE:
+		return V4L2_EXPOSURE_AUTO;
+	case CIF_PREISP_CID_AUTO_WHITE_BALANCE:
+		return V4L2_CID_AUTO_WHITE_BALANCE;
+	case CIF_PREISP_CID_BLACK_LEVEL:
+		return V4L2_CID_BLACK_LEVEL;
+	case CIF_PREISP_CID_WB_TEMPERATURE:
+		return V4L2_CID_WHITE_BALANCE_TEMPERATURE;
+	case CIF_PREISP_CID_EXPOSURE_TIME:
+		return V4L2_CID_EXPOSURE;
+	case CIF_PREISP_CID_ANALOG_GAIN:
+		return V4L2_CID_GAIN;
+	case CIF_PREISP_CID_FOCUS_ABSOLUTE:
+		return V4L2_CID_FOCUS_ABSOLUTE;
+	case CIF_PREISP_CID_AUTO_N_PRESET_WHITE_BALANCE:
+		return V4L2_CID_AUTO_N_PRESET_WHITE_BALANCE;
+	case CIF_PREISP_CID_SCENE_MODE:
+		return V4L2_CID_SCENE_MODE;
+	case CIF_PREISP_CID_ISO_SENSITIVITY:
+		return V4L2_CID_ISO_SENSITIVITY;
+	case CIF_PREISP_CID_AUTO_FPS:
+		return RK_V4L2_CID_AUTO_FPS;
+	case CIF_PREISP_CID_VBLANKING:
+		return RK_V4L2_CID_VBLANKING;
+	case CIF_PREISP_CID_HFLIP:
+		return V4L2_CID_HFLIP;
+	case CIF_PREISP_CID_VFLIP:
+		return V4L2_CID_VFLIP;
+	case CIF_PREISP_CID_BAND_STOP_FILTER:
+		return V4L2_CID_BAND_STOP_FILTER;
+	default:
+		cif_preisp_pltfrm_pr_err(NULL,
+			"unknown/unsupported CIF ISP20 ID %d\n",
+			cif_preisp_cid);
+		break;
+	}
+
+	return -EINVAL;
+}
+
+int cif_preisp_img_src_v4l2_subdev_s_streaming(
+	void *img_src,
+	bool enable)
+{
+	struct v4l2_subdev *subdev = img_src;
+
+	if (enable)
+		return v4l2_subdev_call(subdev, video, s_stream, 1);
+	else
+		return v4l2_subdev_call(subdev, video, s_stream, 0);
+}
+
+int cif_preisp_img_src_v4l2_subdev_s_power(
+	void *img_src,
+	bool on)
+{
+	struct v4l2_subdev *subdev = img_src;
+
+	if (on)
+		return v4l2_subdev_call(subdev, core, s_power, 1);
+	else
+		return v4l2_subdev_call(subdev, core, s_power, 0);
+}
+
+int cif_preisp_img_src_v4l2_subdev_enum_strm_fmts(
+	void *img_src,
+	u32 index,
+	struct cif_preisp_strm_fmt_desc *strm_fmt_desc)
+{
+	int ret;
+	struct v4l2_subdev *subdev = img_src;
+	struct v4l2_frmivalenum fie = {.index = index};
+	struct pltfrm_cam_defrect defrect;
+	v4l2_std_id std;
+
+	ret = v4l2_subdev_call(subdev, video, querystd, &std);
+	if (!IS_ERR_VALUE(ret))
+		strm_fmt_desc->std_id = std;
+	else
+		strm_fmt_desc->std_id = 0;
+
+	ret = v4l2_subdev_call(subdev, video,
+		enum_frameintervals, &fie);
+	if (!IS_ERR_VALUE(ret)) {
+		strm_fmt_desc->discrete_intrvl = true;
+		strm_fmt_desc->min_intrvl.numerator =
+			fie.discrete.numerator;
+		strm_fmt_desc->min_intrvl.denominator =
+			fie.discrete.denominator;
+		strm_fmt_desc->discrete_frmsize = true;
+		strm_fmt_desc->min_frmsize.width = fie.width;
+		strm_fmt_desc->min_frmsize.height = fie.height;
+		strm_fmt_desc->pix_fmt =
+			img_src_v4l2_subdev_pix_fmt2cif_preisp_pix_fmt(
+				fie.pixel_format);
+
+		defrect.width = fie.width;
+		defrect.height = fie.height;
+		memset(&defrect.defrect, 0x00, sizeof(struct v4l2_rect));
+		v4l2_subdev_call(subdev,
+			core,
+			ioctl,
+			PLTFRM_CIFCAM_G_DEFRECT,
+			(void *)&defrect);
+		if ((defrect.defrect.width == 0) ||
+			(defrect.defrect.height == 0)) {
+			strm_fmt_desc->defrect.left = 0;
+			strm_fmt_desc->defrect.top = 0;
+			strm_fmt_desc->defrect.width = fie.width;
+			strm_fmt_desc->defrect.height = fie.height;
+		} else
+			strm_fmt_desc->defrect = defrect.defrect;
+
+	}
+
+	return ret;
+}
+
+int cif_preisp_img_src_v4l2_subdev_s_strm_fmt(
+	void *img_src,
+	struct cif_preisp_strm_fmt *strm_fmt)
+{
+	int ret = 0;
+	struct v4l2_subdev *subdev = img_src;
+	struct v4l2_mbus_framefmt format;
+
+	format.code = cif_preisp_pix_fmt2img_src_v4l2_subdev_pix_fmt(
+		strm_fmt->frm_fmt.pix_fmt);
+	format.width = strm_fmt->frm_fmt.width;
+	format.height = strm_fmt->frm_fmt.height;
+	ret = v4l2_subdev_call(subdev, video, s_mbus_fmt, &format);
+	if (IS_ERR_VALUE(ret))
+		goto err;
+
+	return 0;
+err:
+	pr_err("img_src.%s ERR: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+int cif_preisp_img_src_v4l2_subdev_s_frame_interval(
+	void *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl)
+{
+	int ret = 0;
+	struct v4l2_subdev *subdev = img_src;
+	struct v4l2_subdev_frame_interval interval;
+
+	interval.interval.numerator = frm_intrvl->numerator;
+	interval.interval.denominator = frm_intrvl->denominator;
+
+	ret = v4l2_subdev_call(subdev, video, s_frame_interval, &interval);
+	if (IS_ERR_VALUE(ret))
+		goto err;
+
+	return 0;
+err:
+	pr_err("img_src.%s ERR: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+int cif_preisp_img_src_v4l2_subdev_g_frame_interval(
+	void *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl)
+{
+	int ret = 0;
+	struct v4l2_subdev *subdev = img_src;
+	struct v4l2_subdev_frame_interval interval;
+
+	interval.interval.numerator = 0;
+	interval.interval.denominator = 0;
+
+	ret = v4l2_subdev_call(subdev, video, g_frame_interval, &interval);
+	if (IS_ERR_VALUE(ret))
+		goto err;
+
+	frm_intrvl->denominator = interval.interval.denominator;
+	frm_intrvl->numerator = interval.interval.numerator;
+
+	return 0;
+err:
+	pr_err("img_src.%s ERR: failed with error %d\n", __func__, ret);
+	return ret;
+}
+
+int cif_preisp_img_src_v4l2_subdev_g_ctrl(
+	void *img_src,
+	int id,
+	int *val)
+{
+	struct v4l2_control ctrl;
+	int ret;
+	struct v4l2_subdev *subdev = img_src;
+
+	ctrl.id = cif_preisp_v4l2_cid2v4l2_cid(id);
+
+	if (IS_ERR_VALUE(ctrl.id))
+		return (int)ctrl.id;
+
+	ret = v4l2_subdev_call(subdev, core, g_ctrl, &ctrl);
+	if (!IS_ERR_VALUE(ret)) {
+		*val = ctrl.value;
+	}
+
+	return ret;
+}
+
+int cif_preisp_img_src_v4l2_subdev_s_ctrl(
+	void *img_src,
+	int id,
+	int val)
+{
+	struct v4l2_control ctrl;
+	struct v4l2_subdev *subdev = img_src;
+
+	ctrl.value = val;
+	ctrl.id = cif_preisp_v4l2_cid2v4l2_cid(id);
+
+	if (IS_ERR_VALUE(ctrl.id))
+		return (int)ctrl.id;
+
+	return v4l2_subdev_call(subdev, core, s_ctrl, &ctrl);
+}
+
+const char *cif_preisp_img_src_v4l2_subdev_g_name(
+	void *img_src)
+{
+	struct v4l2_subdev *subdev = img_src;
+
+	return (char *)subdev->name;
+}
+
+int cif_preisp_img_src_v4l2_subdev_s_ext_ctrls(
+	void *img_src,
+	struct cif_preisp_img_src_ext_ctrl *ctrl)
+{
+	struct v4l2_ext_controls ctrls;
+	struct v4l2_ext_control *controls;
+	int i;
+	int ret;
+	struct v4l2_subdev *subdev = img_src;
+
+	if (ctrl->cnt == 0)
+		return -EINVAL;
+
+	controls = kmalloc(ctrl->cnt * sizeof(struct v4l2_ext_control),
+		GFP_KERNEL);
+
+	if (!controls)
+		return -ENOMEM;
+
+	for (i = 0; i < ctrl->cnt; i++) {
+		controls[i].id = ctrl->ctrls[i].id;
+		controls[i].value = ctrl->ctrls[i].val;
+	}
+
+	ctrls.count = ctrl->cnt;
+	ctrls.controls = controls;
+	ctrls.ctrl_class = ctrl->class;
+	ctrls.reserved[0] = 0;
+	ctrls.reserved[1] = 0;
+
+	ret = v4l2_subdev_call(subdev,
+		core, s_ext_ctrls, &ctrls);
+
+	kfree(controls);
+
+	return ret;
+}
+
+long cif_preisp_img_src_v4l2_subdev_ioctl(
+	void *img_src,
+	unsigned int cmd,
+	void *arg)
+{
+	struct v4l2_subdev *subdev = img_src;
+	long ret = -EINVAL;
+
+	switch (cmd) {
+	case RK_VIDIOC_SENSOR_MODE_DATA:
+	case RK_VIDIOC_CAMERA_MODULEINFO:
+
+	case PLTFRM_CIFCAM_G_ITF_CFG:
+	case PLTFRM_CIFCAM_G_DEFRECT:
+	case PLTFRM_CIFCAM_ATTACH:
+	case PLTFRM_CIFCAM_R_LIGHTSENSOR:
+		ret = v4l2_subdev_call(subdev,
+			core,
+			ioctl,
+			cmd,
+			arg);
+
+		break;
+	default:
+		break;
+	}
+
+	if (IS_ERR_VALUE(ret))
+		pr_err("img_src.%s subdev call(cmd: 0x%x) failed with error %ld\n",
+		__func__, cmd, ret);
+
+	return ret;
+}
diff --git a/drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.h b/drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.h
new file mode 100644
index 0000000..e13e8cf
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/cif-preisp_img_src_v4l2-subdev.h
@@ -0,0 +1,72 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef _CIF_PREISP_IMG_SRC_V4L2_SUBDEV_H
+#define _CIF_PREISP_IMG_SRC_V4L2_SUBDEV_H
+
+#define CIF_PREISP_IMG_SRC_V4L2_I2C_SUBDEV  "v4l2-i2c-subdev"
+
+void *cif_preisp_img_src_v4l2_i2c_subdev_to_img_src(
+	struct device *dev,
+	struct pltfrm_soc_cfg *soc_cfg);
+
+int cif_preisp_img_src_v4l2_subdev_s_streaming(
+	void *img_src,
+	bool enable);
+
+int cif_preisp_img_src_v4l2_subdev_s_power(
+	void *img_src,
+	bool on);
+
+int cif_preisp_img_src_v4l2_subdev_enum_strm_fmts(
+	void *img_src,
+	u32 index,
+	struct cif_preisp_strm_fmt_desc *strm_fmt_desc);
+
+int cif_preisp_img_src_v4l2_subdev_s_strm_fmt(
+	void *img_src,
+	struct cif_preisp_strm_fmt *strm_fmt);
+
+int cif_preisp_img_src_v4l2_subdev_g_ctrl(
+	void *img_src,
+	int id,
+	int *val);
+
+int cif_preisp_img_src_v4l2_subdev_s_ctrl(
+	void *img_src,
+	int id,
+	int val);
+
+const char *cif_preisp_img_src_v4l2_subdev_g_name(
+	void *img_src);
+
+int cif_preisp_img_src_v4l2_subdev_s_ext_ctrls(
+	void *img_src,
+	struct cif_preisp_img_src_ext_ctrl *ctrl);
+
+long cif_preisp_img_src_v4l2_subdev_ioctl(
+	void *img_src,
+	unsigned int cmd,
+	void *arg);
+
+int cif_preisp_img_src_v4l2_subdev_s_frame_interval(
+	void *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl);
+
+int cif_preisp_img_src_v4l2_subdev_g_frame_interval(
+	void *img_src,
+	struct cif_preisp_frm_intrvl *frm_intrvl);
+#endif
diff --git a/drivers/media/platform/preisp_driver/isp-fw.c b/drivers/media/platform/preisp_driver/isp-fw.c
new file mode 100644
index 0000000..53a5ac9
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/isp-fw.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/firmware.h>
+#include <linux/delay.h>
+
+#include "isp-fw.h"
+#include "spi2apb.h"
+
+static int spi_read_wait(struct spi_device *spi,
+        const struct rkl_section *sec)
+{
+    int32_t value = 0;
+    int try = 0;
+    int ret = 0;
+
+    do {
+        ret = spi2apb_safe_r32(spi, sec->wait_addr, &value);
+
+        if (!ret && value == sec->wait_value)
+            break;
+
+        if (try++ == sec->timeout) {
+            ret = -1;
+            dev_err(&spi->dev, "read 0x%x is %x != %x timeout\n",
+                    sec->wait_addr, value, sec->wait_value);
+            break;
+        }
+        mdelay(sec->wait_time);
+    } while (1);
+
+    return ret;
+}
+
+static int spi_boot_request(struct spi_device *spi,
+        const struct rkl_section * sec)
+{
+    struct rkl_boot_request boot_req;
+    int try = 0;
+    int ret = 0;
+
+    //send boot request to dsp for ddr init
+    boot_req.flag = sec->flag;
+    boot_req.loadAddr = sec->load_addr;
+    boot_req.bootLen = sec->size;
+    boot_req.status = 1;
+    boot_req.cmd = 2;
+
+    ret = spi2apb_safe_write(spi, BOOT_REQUEST_ADDR,
+            (int32_t*)&boot_req, sizeof(boot_req));
+    if (ret)
+        return ret;
+
+    if (sec->flag & BOOT_FLAG_READ_WAIT) {
+        //waitting for dsp init ddr done
+        do {
+            ret = spi2apb_safe_read(spi, BOOT_REQUEST_ADDR,
+                    (int32_t*)&boot_req, sizeof(boot_req));
+
+            if (!ret && boot_req.status == 0)
+                break;
+
+            if (try++ == sec->timeout) {
+                ret = -1;
+                dev_err(&spi->dev, "boot_request timeout\n");
+                break;
+            }
+            mdelay(sec->wait_time);
+        } while (1);
+    }
+
+    return ret;
+}
+
+static int spi_download_section(struct spi_device *spi,
+        const uint8_t *data, const struct rkl_section *sec)
+{
+    int ret = 0;
+
+    dev_info(&spi->dev, "offset:%x,size:%x,addr:%x,"
+            "wait_time:%x,timeout:%x,crc:%x,flag:%x,type:%x",
+            sec->offset, sec->size, sec->load_addr, sec->wait_time,
+            sec->timeout, sec->crc_16, sec->flag, sec->type);
+    if (sec->size > 0) {
+        ret = spi2apb_safe_write(spi, sec->load_addr,
+                (int32_t*)(data + sec->offset), sec->size);
+        if (ret)
+            return ret;
+    }
+
+    if (sec->flag & BOOT_FLAG_BOOT_REQUEST) {
+        ret = spi_boot_request(spi, sec);
+    } else if (sec->flag & BOOT_FLAG_READ_WAIT) {
+        ret = spi_read_wait(spi, sec);
+    }
+
+    return ret;
+}
+
+/**
+ * spi_download_fw: - rk preisp firmware download through spi
+ *
+ * @spi: spi device
+ * @fw_name: name of firmware file, NULL for default firmware name
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ **/
+int spi_download_fw(struct spi_device *spi, const char *fw_name)
+{
+    const struct rkl_header * head;
+    const struct firmware *fw;
+    int i = 0;
+    int ret = 0;
+
+    if (fw_name == NULL)
+        fw_name = RKL_DEFAULT_FW_NAME;
+
+    dev_info(&spi->dev, "before request firmware");
+    ret = request_firmware(&fw, fw_name, &spi->dev);
+    if (ret) {
+        dev_err(&spi->dev, "request firmware %s failed!", fw_name);
+        return ret;
+    }
+
+    head = (const struct rkl_header *) fw->data;
+
+    dev_info(&spi->dev, "request firmware %s (version:%s) success!", fw_name, head->version);
+
+    for (i = 0; i < head->section_count; i++) {
+        ret = spi_download_section(spi, fw->data, &head->sections[i]);
+        if (ret)
+            break;
+    }
+
+    release_firmware(fw);
+    return ret;
+}
diff --git a/drivers/media/platform/preisp_driver/isp-fw.h b/drivers/media/platform/preisp_driver/isp-fw.h
new file mode 100644
index 0000000..bb52eaa
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/isp-fw.h
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __ISP_FIRMWARE_H__
+#define __ISP_FIRMWARE_H__
+
+#include <linux/types.h>
+#include <linux/firmware.h>
+#include "spi2apb.h"
+
+#define RKL_MAX_SECTION_NUM 10
+
+struct rkl_section {
+    union {
+        uint32_t offset;
+        uint32_t wait_value;
+    };
+    uint32_t size;
+    union {
+        uint32_t load_addr;
+        uint32_t wait_addr;
+    };
+    uint16_t wait_time;
+    uint16_t timeout;
+    uint16_t crc_16;
+    uint8_t  flag;
+    uint8_t  type;
+};
+
+struct rkl_header {
+    char version[32];
+    uint32_t header_size;
+    uint32_t section_count;
+    struct rkl_section sections[RKL_MAX_SECTION_NUM];
+};
+
+#define BOOT_FLAG_CRC           (1<<0)
+#define BOOT_FLAG_EXE           (1<<1)
+#define BOOT_FLAG_LOAD_PMEM     (1<<2)
+#define BOOT_FLAG_ACK           (1<<3)
+#define BOOT_FLAG_READ_WAIT     (1<<4)
+#define BOOT_FLAG_BOOT_REQUEST  (1<<5)
+
+struct rkl_boot_request {
+    uint32_t flag;
+    uint32_t loadAddr;
+    uint32_t bootLen;
+    uint8_t status;
+    uint8_t dummy[2];
+    uint8_t cmd;
+};
+
+#define BOOT_REQUEST_ADDR 0x18000010
+#define BOOT_REQUEST_WAIT_DELAY_MS 1
+#define BOOT_REQUEST_TIMEOUT 10
+
+#define DSP_HEAD_ADDR 0x60000000
+
+#define RKL_DEFAULT_FW_NAME "preisp.rkl"
+
+/**
+ * spi_download_fw: - rk preisp firmware download through spi
+ *
+ * @spi: spi device
+ * @fw_name: name of firmware file, NULL for default firmware name
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ **/
+int spi_download_fw(struct spi_device *spi, const char *fw_name);
+
+#endif
diff --git a/drivers/media/platform/preisp_driver/msg-queue.c b/drivers/media/platform/preisp_driver/msg-queue.c
new file mode 100644
index 0000000..7d4de80
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/msg-queue.c
@@ -0,0 +1,468 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "msg-queue.h"
+
+/**
+ * msq_init - Initialize msg queue
+ *
+ * @q: the msg queue to initialize
+ * @size: size of msg queue buf
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_init(struct msg_queue *q, int size)
+{
+    uint32_t *buf = kmalloc(size, GFP_KERNEL);
+
+    q->buf_head = buf;
+    q->buf_tail = buf + size / sizeof(uint32_t);
+    q->cur_send = buf;
+    q->cur_recv = buf;
+
+    return 0;
+}
+
+/**
+ * msq_release - release msg queue buf
+ *
+ * @q: the msg queue to release
+ */
+void msq_release(struct msg_queue *q)
+{
+    kfree(q->buf_head);
+    q->buf_head = NULL;
+    q->buf_tail = NULL;
+    q->cur_send = NULL;
+    q->cur_recv = NULL;
+}
+
+/**
+ * msq_is_empty - tests whether a msg queue is empty
+ *
+ * @q: the msg queue to test
+ *
+ * It returns true on msg queue is empty, else false.
+ */
+int msq_is_empty(const struct msg_queue *q)
+{
+    return q->cur_send == q->cur_recv;
+}
+
+/**
+ * msq_total_size - get msg queue buf total size
+ *
+ * @q: msg queue
+ *
+ * It returns size of msg queue buf, unit 4 bytes.
+ */
+uint32_t msq_total_size(const struct msg_queue *q)
+{
+    return q->buf_tail - q->buf_head;
+}
+
+/**
+ * msq_tail_free_size - get msg queue tail unused buf size
+ *
+ * @q: msg queue
+ *
+ * It returns size of msg queue tail unused buf size, unit 4 bytes
+ */
+uint32_t msq_tail_free_size(const struct msg_queue *q)
+{
+    if (q->cur_send >= q->cur_recv) {
+        return (q->buf_tail - q->cur_send);
+    }
+
+    return q->cur_recv - q->cur_send;
+}
+
+/**
+ * msq_head_free_size - get msg queue head unused buf size
+ *
+ * @q: msg queue
+ *
+ * It returns size of msg queue head unused buf size, unit 4 bytes
+ */
+uint32_t msq_head_free_size(const struct msg_queue *q)
+{
+    if (q->cur_send >= q->cur_recv) {
+        return (q->cur_recv - q->buf_head);
+    }
+
+    return 0;
+}
+
+/**
+ * msq_send_msg - send a msg to msg queue
+ *
+ * @q: msg queue
+ * @m: a msg to queue
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_send_msg(struct msg_queue *q, const struct msg *m)
+{
+    int ret = 0;
+    if (msq_tail_free_size(q) > m->size) {
+        uint32_t * next_send;
+
+        memcpy(q->cur_send, m, m->size * sizeof(uint32_t));
+        next_send = q->cur_send + m->size;
+        if (next_send == q->buf_tail) {
+            next_send = q->buf_head;
+        }
+        q->cur_send = next_send;
+    } else if (msq_head_free_size(q) > m->size) {
+        *q->cur_send = 0; //set size to 0 for skip to head mark
+        memcpy(q->buf_head, m, m->size * sizeof(uint32_t));
+        q->cur_send = q->buf_head + m->size;
+    } else {
+        ret = -1;
+    }
+
+    return ret;
+}
+
+/**
+ * msq_recv_msg - receive a msg from msg queue
+ *
+ * @q: msg queue
+ * @m: a msg pointer buf [out]
+ *
+ * need call msq_recv_msg_free to free msg after msg use done
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_recv_msg(struct msg_queue *q, struct msg **m)
+{
+    *m = NULL;
+    if (msq_is_empty(q))
+        return -1;
+
+    //skip to head when size is 0
+    if (*q->cur_recv == 0) {
+        *m = (struct msg*)q->buf_head;
+    } else {
+        *m = (struct msg*)q->cur_recv;
+    }
+
+    return 0;
+}
+
+/**
+ * msq_free_received_msg - free a received msg to msg queue
+ *
+ * @q: msg queue
+ * @m: a msg
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_free_received_msg(struct msg_queue *q, const struct msg *m)
+{
+    //skip to head when size is 0
+    if (*q->cur_recv == 0) {
+        q->cur_recv = q->buf_head + m->size;
+    } else {
+        uint32_t *next_recv;
+
+        next_recv = q->cur_recv + m->size;
+        if (next_recv == q->buf_tail) {
+            next_recv = q->buf_head;
+        }
+        q->cur_recv = next_recv;
+    }
+
+    return 0;
+}
+
+/**
+ * dsp_msq_init - init AP <-> DSP msg queue
+ *
+ * @spi: spi device
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_init(struct spi_device *spi)
+{
+    int err = 0;
+    struct dsp_msg_queue queue;
+    queue.buf_head = (DSP_R_MSG_QUEUE_ADDR + sizeof(queue));
+    queue.buf_tail = (DSP_R_MSG_QUEUE_ADDR + sizeof(queue) + 16*1024);
+    queue.cur_recv = queue.buf_head;
+    queue.cur_send = queue.buf_head;
+
+    err = spi2apb_safe_write(spi, DSP_R_MSG_QUEUE_ADDR,
+            (int32_t*)&queue, sizeof(queue));
+
+    queue.buf_head = DSP_S_MSG_QUEUE_ADDR + sizeof(queue);
+    queue.buf_tail = DSP_S_MSG_QUEUE_ADDR + sizeof(queue) + 16*1024;
+    queue.cur_recv = queue.buf_head;
+    queue.cur_send = queue.buf_head;
+
+    err = spi2apb_safe_write(spi, DSP_S_MSG_QUEUE_ADDR,
+            (int32_t*)&queue, sizeof(queue));
+    return err;
+}
+
+/**
+ * dsp_msq_is_empty - tests whether a msg queue is empty
+ *
+ * @q: the msg queue to test
+ *
+ * It returns true on msg queue is empty, else false.
+ */
+int dsp_msq_is_empty(const struct dsp_msg_queue *q)
+{
+    return q->cur_send == q->cur_recv;
+}
+
+/**
+ * dsp_msq_total_size - get msg queue buf total size
+ *
+ * @q: msg queue
+ *
+ * It returns size of msg queue buf, unit byte.
+ */
+uint32_t dsp_msq_total_size(const struct dsp_msg_queue *q)
+{
+    return q->buf_tail - q->buf_head;
+}
+
+/**
+ * dsp_msq_tail_free_size - get msg queue tail unused buf size
+ *
+ * @q: msg queue
+ *
+ * It returns size of msg queue tail unused buf size, unit byte
+ */
+uint32_t dsp_msq_tail_free_size(const struct dsp_msg_queue *q)
+{
+    if (q->cur_send >= q->cur_recv) {
+        return (q->buf_tail - q->cur_send);
+    }
+
+    return q->cur_recv - q->cur_send;
+}
+
+/**
+ * dsp_msq_head_free_size - get msg queue head unused buf size
+ *
+ * @q: msg queue
+ *
+ * It returns size of msg queue head unused buf size, unit byte
+ */
+uint32_t dsp_msq_head_free_size(const struct dsp_msg_queue *q)
+{
+    if (q->cur_send >= q->cur_recv) {
+        return (q->cur_recv - q->buf_head);
+    }
+
+    return 0;
+}
+
+/**
+ * dsp_msq_read_head - read dsp msg queue head
+ *
+ * @spi: spi device
+ * @addr: msg queue head addr
+ * @m: msg queue pointer
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_read_head(struct spi_device *spi,
+        uint32_t addr, struct dsp_msg_queue *q)
+{
+    int err = 0;
+    int32_t reg;
+
+    err = spi2apb_safe_r32(spi, DSP_PMU_SYS_REG0, &reg);
+
+    if (err || ((reg & DSP_MSG_QUEUE_OK_MASK) != DSP_MSG_QUEUE_OK_TAG)) {
+        //dev_warn(&spi->dev, "dsp msg queue head not init!\n");
+        return -1;
+    }
+
+    err = spi2apb_safe_read(spi, addr, (int32_t*)q, sizeof(*q));
+    return err;
+}
+
+/**
+ * dsp_msq_send_msg - send a msg to AP -> DSP msg queue
+ *
+ * @spi: spi device
+ * @m: a msg to send
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_send_msg(struct spi_device *spi, const struct msg *m)
+{
+    int err = 0;
+    struct dsp_msg_queue queue;
+    struct dsp_msg_queue *q = &queue;
+    uint32_t msg_size = m->size * sizeof(uint32_t);
+
+    err = dsp_msq_read_head(spi, DSP_R_MSG_QUEUE_ADDR, q);
+    if (err)
+        return err;
+
+    if (dsp_msq_tail_free_size(q) > msg_size) {
+        uint32_t next_send;
+
+        err = spi2apb_safe_write(spi, q->cur_send, (int32_t*)m, msg_size);
+        next_send = q->cur_send + msg_size;
+        if (next_send == q->buf_tail) {
+            next_send = q->buf_head;
+        }
+        q->cur_send = next_send;
+    } else if (dsp_msq_head_free_size(q) > msg_size) {
+        //set size to 0 for skip to head mark
+        err = spi2apb_safe_w32(spi, q->cur_send, 0);
+        if (err)
+            return err;
+
+        err = spi2apb_safe_write(spi, q->buf_head, (int32_t*)m, msg_size);
+
+        q->cur_send = q->buf_head + msg_size;
+    } else {
+        return -1;
+    }
+
+    if (err)
+        return err;
+
+    err = spi2apb_safe_w32(spi, DSP_R_MSG_QUEUE_ADDR +
+            (uint8_t*)&q->cur_send - (uint8_t*)q, q->cur_send);
+
+    spi2apb_interrupt_request(spi, PREISP_IRQ_TYPE_MSG);
+
+    return err;
+}
+
+/**
+ * dsp_msq_recv_query - query next msg size from DSP -> AP msg queue
+ *
+ * @q: msg queue
+ * @size: msg size buf [out]
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_recv_query(struct spi_device *spi, int32_t *size)
+{
+    struct dsp_msg_queue queue;
+    struct dsp_msg_queue *q = &queue;
+    int err = 0;
+
+    err = dsp_msq_read_head(spi, DSP_S_MSG_QUEUE_ADDR, q);
+    if (err)
+        return err;
+
+    *size = 0;
+    if (dsp_msq_is_empty(q))
+        return 0;
+
+    //skip to head when size is 0
+    err = spi2apb_safe_r32(spi, q->cur_recv, size);
+    if (err)
+        return err;
+
+    if (*size == 0) {
+        err = spi2apb_safe_r32(spi, (int32_t)q->buf_head, size);
+    }
+
+    return err;
+}
+
+/**
+ * dsp_msq_recv_msg - receive a msg from DSP -> AP msg queue
+ *
+ * @q: msg queue
+ * @m: a msg pointer buf [out]
+ *
+ * need call dsp_msq_recv_msg_free to free msg after msg use done
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_recv_msg(struct spi_device *spi, struct msg **m)
+{
+    struct dsp_msg_queue queue;
+    struct dsp_msg_queue *q = &queue;
+    uint32_t size = 0, msg_size = 0;
+    uint32_t recv_addr = 0;
+    uint32_t next_recv_addr = 0;
+    int err = 0;
+
+    *m = NULL;
+
+    err = dsp_msq_read_head(spi, DSP_S_MSG_QUEUE_ADDR, q);
+    if (err)
+        return err;
+
+    if (dsp_msq_is_empty(q))
+        return -1;
+
+    //skip to head when size is 0
+    err = spi2apb_safe_r32(spi, (int32_t)q->cur_recv, (int32_t*)&size);
+    if (err)
+        return err;
+    if (size == 0) {
+        err = spi2apb_safe_r32(spi, (int32_t)q->buf_head,
+                (int32_t*)&size);
+        if (err)
+            return err;
+
+        msg_size = size * sizeof(uint32_t);
+        recv_addr = q->buf_head;
+        next_recv_addr = q->buf_head + msg_size;
+    } else {
+        msg_size = size * sizeof(uint32_t);
+        recv_addr = q->cur_recv;
+        next_recv_addr = q->cur_recv + msg_size;
+        if (next_recv_addr == q->buf_tail) {
+            next_recv_addr = q->buf_head;
+        }
+    }
+
+    if (msg_size > dsp_msq_total_size(q))
+        return -2;
+
+    *m = (struct msg*)kmalloc(msg_size, GFP_KERNEL);
+    err = spi2apb_safe_read(spi, recv_addr, (int32_t*)*m, msg_size);
+    if (err == 0) {
+        err = spi2apb_safe_w32(spi, DSP_S_MSG_QUEUE_ADDR +
+            (uint8_t*)&q->cur_recv - (uint8_t*)q,next_recv_addr);
+    }
+
+    if (err) {
+        kfree(*m);
+    }
+
+    return err;
+}
+
+/**
+ * dsp_msq_free_received_msg - free a received msg
+ *
+ * @q: msg queue
+ * @m: a msg
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_free_received_msg(const struct msg *m)
+{
+    if (m != NULL)
+        kfree(m);
+
+    return 0;
+}
diff --git a/drivers/media/platform/preisp_driver/msg-queue.h b/drivers/media/platform/preisp_driver/msg-queue.h
new file mode 100644
index 0000000..ab24cba
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/msg-queue.h
@@ -0,0 +1,243 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __RK_PREISP_MSG_H__
+#define __RK_PREISP_MSG_H__
+
+#include <linux/types.h>
+#include <linux/string.h>
+#include "spi2apb.h"
+
+#define DSP_R_MSG_QUEUE_ADDR 0x60050000
+#define DSP_S_MSG_QUEUE_ADDR 0x60050010
+
+#define MSG_QUEUE_DEFAULT_SIZE 8*1024
+
+typedef struct msg_queue {
+    uint32_t* buf_head; //msg buffer head
+    uint32_t* buf_tail; //msg buffer tail
+    uint32_t* cur_send; //current msg send postition
+    uint32_t* cur_recv; //current msg receive position
+} msg_queue_t;
+
+#define DSP_PMU_SYS_REG0            0x120000f0
+#define DSP_MSG_QUEUE_OK_MASK       0xffff0001
+#define DSP_MSG_QUEUE_OK_TAG        0x16080001
+
+typedef struct dsp_msg_queue {
+    uint32_t buf_head; //msg buffer head
+    uint32_t buf_tail; //msg buffer tail
+    uint32_t cur_send; //current msg send postition
+    uint32_t cur_recv; //current msg receive position
+} dsp_msg_queue_t;
+
+typedef struct msg {
+    uint32_t size; // unit 4 bytes
+    uint16_t type; // msg identification
+    int8_t  camera_id;
+    int8_t  sync;
+} msg_t;
+
+enum {
+    id_msg_set_sys_mode_bypass_t = 0x0200,
+    id_msg_set_sys_mode_standby_t,
+
+    id_msg_set_log_level_t = 0x0250,
+
+    //dsp -> ap
+    id_msg_do_i2c_t = 0x0390,
+    //ap -> dsp
+    id_msg_do_i2c_ret_t,
+
+    id_msg_dsp_log_t = 0x0400,
+};
+
+typedef msg_t msg_set_sys_mode_standby_t;
+
+enum {
+    LOG_ERROR,
+    LOG_WARN,
+    LOG_INFO,
+    LOG_DEBUG,
+};
+
+typedef struct {
+    uint32_t size;
+    uint16_t type;
+    int8_t  core_id;
+    int8_t  log_level;
+} msg_dsp_log_t;
+
+typedef msg_dsp_log_t msg_set_log_level_t;
+
+//dsp -> ap
+typedef struct {
+    uint16_t addr;
+    uint16_t flags;
+    uint16_t len;
+    uint8_t  buf[6];
+} do_i2c_msg_t;
+
+typedef struct {
+    uint32_t size;
+    uint16_t type;
+    int16_t  nr;
+    uint16_t scl_rate;
+    uint16_t num_msg;
+} msg_do_i2c_head_t;
+
+#define AP_I2C_ONCE_MAX_NUM 20
+typedef struct {
+    msg_do_i2c_head_t head;
+    do_i2c_msg_t msg[AP_I2C_ONCE_MAX_NUM];
+} msg_do_i2c_t;
+
+//ap -> dsp
+typedef struct {
+    uint32_t size;
+    uint16_t type;
+    int16_t  nr;
+    uint16_t addr;
+    uint16_t len;
+    uint8_t  buf[8];
+} msg_do_i2c_ret_t;
+
+
+#define MSG(TYPE, var) TYPE var; \
+    var.size = sizeof(TYPE)/4;\
+    var.type = id_ ## TYPE;
+
+#define PREISP_IRQ_TYPE_MSG 0x12345678
+
+/**
+ * msq_init - Initialize msg queue
+ *
+ * @q: the msg queue to initialize
+ * @size: size of msg queue buf
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_init(struct msg_queue *q, int size);
+
+/**
+ * msq_release - release msg queue buf
+ *
+ * @q: the msg queue to release
+ */
+void msq_release(struct msg_queue *q);
+
+/**
+ * msq_is_empty - tests whether a msg queue is empty
+ *
+ * @q: the msg queue to test
+ *
+ * It returns true on msg queue is empty, else false.
+ */
+int msq_is_empty(const struct msg_queue *q);
+
+/**
+ * msq_send_msg - send a msg to msg queue
+ *
+ * @q: msg queue
+ * @m: a msg to queue
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_send_msg(struct msg_queue *q, const struct msg *m);
+
+/**
+ * msq_recv_msg - receive a msg from msg queue
+ *
+ * @q: msg queue
+ * @m: a msg pointer buf [out]
+ *
+ * need call msq_free_received_msg to free msg after msg use done
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_recv_msg(struct msg_queue *q, struct msg **m);
+
+/**
+ * msq_free_received_msg - free a received msg
+ *
+ * @q: msg queue
+ * @m: a msg
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int msq_free_received_msg(struct msg_queue *q, const struct msg *m);
+
+/**
+ * dsp_msq_init - init AP <-> DSP msg queue
+ *
+ * @spi: spi device
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_init(struct spi_device *spi);
+
+/**
+ * dsp_msq_read_head - read dsp msg queue head
+ *
+ * @spi: spi device
+ * @addr: msg queue head addr
+ * @m: msg queue pointer
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_read_head(struct spi_device *spi,
+        uint32_t addr, struct dsp_msg_queue *q);
+
+/**
+ * dsp_msq_send_msg - send a msg to AP -> DSP msg queue
+ *
+ * @spi: spi device
+ * @m: a msg to send
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_send_msg(struct spi_device *spi, const struct msg *m);
+
+/**
+ * dsp_msq_recv_query - query next msg size from DSP -> AP msg queue
+ *
+ * @q: msg queue
+ * @size: msg size buf [out]
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_recv_query(struct spi_device *spi, int32_t *size);
+
+/**
+ * dsp_msq_recv_msg - receive a msg from DSP -> AP msg queue
+ *
+ * @q: msg queue
+ * @m: a msg pointer buf [out]
+ *
+ * need call dsp_msq_free_received_msg to free msg after msg use done
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_recv_msg(struct spi_device *spi, struct msg **m);
+
+/**
+ * dsp_msq_free_received_msg - free a received msg
+ *
+ * @q: msg queue
+ * @m: a msg
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int dsp_msq_free_received_msg(const struct msg *m);
+
+#endif
diff --git a/drivers/media/platform/preisp_driver/spi-rkpreisp.c b/drivers/media/platform/preisp_driver/spi-rkpreisp.c
new file mode 100644
index 0000000..9324022
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/spi-rkpreisp.c
@@ -0,0 +1,1524 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/poll.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/compat.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <asm/uaccess.h>
+#include <linux/random.h>
+#include <linux/delay.h>
+#include <linux/ctype.h>
+#include <linux/gpio.h>
+#include <linux/of_gpio.h>
+#include <linux/clk.h>
+#include <linux/regulator/consumer.h>
+#include <linux/wakelock.h>
+
+#include "spi-rkpreisp.h"
+#include "isp-fw.h"
+#include "ap-i2c.h"
+#include "cif-preisp.h"
+
+#define ENABLE_CACHE_FIRMWARE 0
+
+#define DEBUG_MSG_LOOP_TEST 0
+
+#define INVALID_ID -1
+
+#define PREISP_MCLK_RATE 24*1000*1000ul
+
+#define PREISP_WAKEUP_TIMEOUT_MS 100
+#define PREISP_REQUEST_SLEEP_TIMEOUT_MS 100
+
+enum {
+    AUTO_ARG_TYPE_STR,
+    AUTO_ARG_TYPE_INT32,
+};
+
+struct auto_arg {
+    int type;
+    union {
+        int32_t m_int32;
+        const char * m_str;
+    };
+};
+
+struct auto_args {
+    int argc;
+    struct auto_arg *argv;
+};
+
+void preisp_set_spi_speed(struct spi_rk_preisp_data *pdata, uint32_t hz)
+{
+    pdata->spi->max_speed_hz = hz;
+}
+
+void preisp_client_list_init(preisp_client_list *s)
+{
+    mutex_init(&s->mutex);
+    INIT_LIST_HEAD(&s->list);
+}
+
+preisp_client * preisp_client_new(void)
+{
+    preisp_client *c =
+        (preisp_client *)kzalloc(sizeof(preisp_client), GFP_KERNEL);
+    c->id = INVALID_ID;
+    INIT_LIST_HEAD(&c->list);
+    msq_init(&c->q, MSG_QUEUE_DEFAULT_SIZE);
+    init_waitqueue_head(&c->wait);
+    return c;
+}
+
+void preisp_client_release(preisp_client *c)
+{
+    msq_release(&c->q);
+    kfree(c);
+}
+
+preisp_client* preisp_client_find(preisp_client_list *s, preisp_client *c)
+{
+    preisp_client *client = NULL;
+
+    list_for_each_entry(client, &s->list, list) {
+        if (c == client) {
+            return c;
+        }
+    }
+    return NULL;
+}
+
+int preisp_client_connect(struct spi_rk_preisp_data *pdata, preisp_client *c)
+{
+    preisp_client_list *s = &pdata->clients;;
+    mutex_lock(&s->mutex);
+    if (preisp_client_find(s, c)) {
+        mutex_unlock(&s->mutex);
+        return -1;
+    }
+
+    list_add_tail(&c->list, &s->list);
+    mutex_unlock(&s->mutex);
+
+    return 0;
+}
+
+void preisp_client_disconnect(struct spi_rk_preisp_data *pdata, preisp_client *c)
+{
+    preisp_client_list *s = &pdata->clients;;
+    mutex_lock(&s->mutex);
+    if (preisp_client_find(s, c)) {
+        list_del_init(&c->list);
+    }
+    mutex_unlock(&s->mutex);
+}
+
+void spi_cs_set_value(struct spi_rk_preisp_data *pdata, int value)
+{
+    int8_t null_cmd = 0;
+    struct spi_transfer null_cmd_packet = {
+        .tx_buf = &null_cmd,
+        .len    = sizeof(null_cmd),
+        .cs_change = !value,
+    };
+    struct spi_message  m;
+
+    spi_message_init(&m);
+    spi_message_add_tail(&null_cmd_packet, &m);
+    spi_sync(pdata->spi, &m);
+}
+
+void rkpreisp_hw_init(struct spi_device *spi)
+{
+    spi2apb_safe_w32(spi, 0x12008098, 0xff004000);
+}
+
+int preisp_send_msg_to_dsp(struct spi_rk_preisp_data *pdata, const struct msg *m)
+{
+    int ret = -1;
+
+    mutex_lock(&pdata->power_lock);
+    if (atomic_read(&pdata->power_on_cnt) > 0 &&
+        atomic_read(&pdata->wake_sleep_cnt) > 0) {
+        mutex_lock(&pdata->send_msg_lock);
+        ret = dsp_msq_send_msg(pdata->spi, m);
+        mutex_unlock(&pdata->send_msg_lock);
+    }
+    mutex_unlock(&pdata->power_lock);
+
+    return ret;
+}
+
+int rkpreisp_set_log_level(struct spi_rk_preisp_data *pdata, int level)
+{
+    int ret = 0;
+    MSG(msg_set_log_level_t, m);
+
+    m.log_level = level;
+    ret = preisp_send_msg_to_dsp(pdata, (struct msg*)&m);
+    return ret;
+}
+
+int rkpreisp_request_sleep_nolock(struct spi_rk_preisp_data *pdata, int32_t mode)
+{
+    int ret;
+    int try = 0;
+
+    MSG(msg_set_sys_mode_standby_t, m);
+
+    if (atomic_dec_return(&pdata->wake_sleep_cnt) == 0) {
+        if (mode >= PREISP_SLEEP_MODE_MAX || mode < 0) {
+            dev_warn(pdata->dev, "Unkown sleep mode %d\n", mode);
+            return -1;
+        }
+        dev_info(pdata->dev,"request sleep\n");
+
+        if (mode == PREISP_SLEEP_MODE_BYPASS) {
+            m.type = id_msg_set_sys_mode_bypass_t;
+            pdata->sleep_mode = PREISP_SLEEP_MODE_BYPASS;
+        } else {
+            pdata->sleep_mode = PREISP_SLEEP_MODE_STANDBY;
+        }
+
+        if (pdata->wakeup_gpio > 0) {
+            gpio_set_value(pdata->wakeup_gpio, !pdata->wakeup_active);
+        }
+        mutex_lock(&pdata->send_msg_lock);
+        ret = dsp_msq_send_msg(pdata->spi, (struct msg*)&m);
+        mutex_unlock(&pdata->send_msg_lock);
+
+        do {
+            if (pdata->sleep_state_flag) {
+                ret = 0;
+                pdata->sleep_state_flag = 0;
+                mdelay(5);
+                break;
+            }
+            if (try++ == PREISP_REQUEST_SLEEP_TIMEOUT_MS) {
+                ret = -1;
+                dev_err(pdata->dev, "request sleep timeout\n");
+                break;
+            }
+            mdelay(1);
+        } while (1);
+
+        dev_info(pdata->dev, "request dsp enter %s mode. ret:%d",
+                mode == PREISP_SLEEP_MODE_BYPASS ? "bypass" : "sleep", ret);
+    } else if (atomic_read(&pdata->wake_sleep_cnt) < 0) {
+        atomic_set(&pdata->wake_sleep_cnt, 0);
+    }
+
+    return ret;
+}
+
+int rkpreisp_request_sleep(struct spi_rk_preisp_data *pdata, int32_t mode)
+{
+    int ret;
+
+    mutex_lock(&pdata->power_lock);
+    ret = rkpreisp_request_sleep_nolock(pdata, mode);
+    mutex_unlock(&pdata->power_lock);
+
+    return ret;
+}
+
+static int rkpreisp_download_fw(struct spi_rk_preisp_data *pdata, char *fw_name)
+{
+    int ret;
+    //request rkpreisp enter slave mode
+    spi_cs_set_value(pdata, 0);
+    if (pdata->wakeup_gpio > 0) {
+        gpio_set_value(pdata->wakeup_gpio, pdata->wakeup_active);
+    }
+    mdelay(3);
+    if (pdata->reset_gpio > 0) {
+        gpio_set_value(pdata->reset_gpio, pdata->reset_active);
+    }
+    mdelay(5);
+    spi_cs_set_value(pdata, 1);
+    preisp_set_spi_speed(pdata, pdata->min_speed_hz);
+    spi2apb_switch_to_msb(pdata->spi);
+    rkpreisp_hw_init(pdata->spi);
+
+    preisp_set_spi_speed(pdata, pdata->max_speed_hz);
+    //download system firmware
+    ret = spi_download_fw(pdata->spi, fw_name);
+    if (ret) {
+        dev_err(pdata->dev, "download firmware failed!");
+    } else {
+        dev_info(pdata->dev, "download firmware success!");
+    }
+
+#if ENABLE_CACHE_FIRMWARE
+    uncache_firmware(RKL_DEFAULT_FW_NAME);
+#endif
+
+    enable_irq(pdata->irq);
+    if (pdata->sleepst_irq > 0) {
+        enable_irq(pdata->sleepst_irq);
+    }
+
+    return ret;
+}
+
+static int rkpreisp_reset(struct spi_rk_preisp_data *pdata, char *fw_name)
+{
+    int ret = 0;
+    disable_irq(pdata->irq);
+    if (pdata->sleepst_irq > 0) {
+        disable_irq(pdata->sleepst_irq);
+    }
+    if (pdata->reset_gpio > 0) {
+        gpio_set_value(pdata->reset_gpio, !pdata->reset_active);
+    }
+    mdelay(3);
+    ret = rkpreisp_download_fw(pdata, fw_name);
+
+    return ret;
+}
+
+int rkpreisp_wakeup_nolock(struct spi_rk_preisp_data *pdata)
+{
+    int32_t reg = 0;
+    int try = 0, ret = 0;
+
+    if (atomic_inc_return(&pdata->wake_sleep_cnt) == 1) {
+        /* enable vdd core regulator */
+        if (!IS_ERR(pdata->vdd_core_regu)) {
+            if (regulator_is_enabled(pdata->vdd_core_regu) <= 0) {
+                ret = regulator_enable(pdata->vdd_core_regu);
+            }
+        }
+        if (pdata->wakeup_gpio > 0) {
+            gpio_set_value(pdata->wakeup_gpio, pdata->wakeup_active);
+        } else {
+            dev_info(pdata->dev, "please config wakeup gpio first!");
+        }
+
+        //waiting for dsp wakeup
+        mdelay(10);
+
+        do {
+            ret = spi2apb_safe_r32(pdata->spi, DSP_PMU_SYS_REG0, &reg);
+
+            if (!ret && ((reg & DSP_MSG_QUEUE_OK_MASK) == DSP_MSG_QUEUE_OK_TAG)) {
+                dev_info(pdata->dev, "wakeup dsp.");
+                break;
+            }
+
+            if (try++ == PREISP_WAKEUP_TIMEOUT_MS) {
+                dev_err(pdata->dev, "wakeup timeout, restart preisp\n");
+                ret = rkpreisp_reset(pdata, RKL_DEFAULT_FW_NAME);
+                break;
+            }
+            mdelay(1);
+        } while (1);
+    }
+
+    return ret;
+}
+
+int rkpreisp_wakeup(struct spi_rk_preisp_data *pdata)
+{
+    int ret = 0;
+
+    mutex_lock(&pdata->power_lock);
+    ret = rkpreisp_wakeup_nolock(pdata);
+    mutex_unlock(&pdata->power_lock);
+
+    return ret;
+}
+
+int rkpreisp_power_on(struct spi_rk_preisp_data *pdata)
+{
+    int ret = 0;
+    mutex_lock(&pdata->power_lock);
+
+    if (atomic_inc_return(&pdata->power_on_cnt) == 1) {
+        dev_info(pdata->dev, "dsp power on!");
+        //do power/clk on
+        if (pdata->mclk != NULL) {
+            clk_prepare_enable(pdata->mclk);
+            clk_set_rate(pdata->mclk, PREISP_MCLK_RATE);
+        }
+
+        /* enable pvdd-regulator */
+        if (!IS_ERR(pdata->pdvdd_regu)) {
+            if (regulator_is_enabled(pdata->pdvdd_regu) <= 0) {
+                ret = regulator_enable(pdata->pdvdd_regu);
+            }
+        }
+        /* enable vdd-core-regulator */
+        if (!IS_ERR(pdata->vdd_core_regu)) {
+            if (regulator_is_enabled(pdata->vdd_core_regu) <= 0) {
+                ret = regulator_enable(pdata->vdd_core_regu);
+            }
+        }
+        pdata->sleep_mode = 0;
+        /* download fw and start run */
+        ret = rkpreisp_download_fw(pdata, RKL_DEFAULT_FW_NAME);
+
+        pdata->sleep_state_flag = 0;
+        atomic_set(&pdata->wake_sleep_cnt, 1);
+    } else {
+        ret = rkpreisp_wakeup_nolock(pdata);
+    }
+    mutex_unlock(&pdata->power_lock);
+
+    if (!ret)
+        rkpreisp_set_log_level(pdata, pdata->log_level);
+
+    return ret;
+}
+
+int rkpreisp_power_off(struct spi_rk_preisp_data *pdata)
+{
+    int ret = 0;
+    mutex_lock(&pdata->power_lock);
+
+    if (atomic_dec_return(&pdata->power_on_cnt) == 0) {
+#if ENABLE_CACHE_FIRMWARE
+        cache_firmware(RKL_DEFAULT_FW_NAME);
+#endif
+        //do power/clk off
+        dev_info(pdata->dev, "dsp power off!");
+        disable_irq(pdata->irq);
+        if (pdata->sleepst_irq > 0) {
+            disable_irq(pdata->sleepst_irq);
+        }
+
+        /* disable vdd-core-regulator */
+        if (!IS_ERR(pdata->vdd_core_regu)) {
+            if (regulator_is_enabled(pdata->vdd_core_regu) > 0) {
+                regulator_disable(pdata->vdd_core_regu);
+            }
+        }
+        /* disable pdvdd-regulator */
+        if (!IS_ERR(pdata->pdvdd_regu)) {
+            if (regulator_is_enabled(pdata->pdvdd_regu) > 0) {
+                regulator_disable(pdata->pdvdd_regu);
+            }
+        }
+        if (pdata->wakeup_gpio > 0) {
+            gpio_set_value(pdata->wakeup_gpio, !pdata->wakeup_active);
+        }
+        if (pdata->reset_gpio > 0) {
+            gpio_set_value(pdata->reset_gpio, !pdata->reset_active);
+        }
+        spi_cs_set_value(pdata, 0);
+        if (pdata->mclk != NULL) {
+            clk_disable_unprepare(pdata->mclk);
+        }
+        atomic_set(&pdata->wake_sleep_cnt, 0);
+    } else if (atomic_read(&pdata->power_on_cnt) < 0) {
+        atomic_set(&pdata->power_on_cnt, 0);
+    } else {
+        ret = rkpreisp_request_sleep_nolock(pdata, PREISP_SLEEP_MODE_STANDBY);
+    }
+    mutex_unlock(&pdata->power_lock);
+
+    return ret;
+}
+
+static void fw_nowait_power_on(const struct firmware *fw, void *context)
+{
+    int ret = 0;
+    struct spi_rk_preisp_data *pdata = context;
+
+    ret = rkpreisp_power_on(pdata);
+    if (!ret) {
+        mdelay(10); /*delay for dsp boot*/
+        rkpreisp_request_sleep(pdata, PREISP_SLEEP_MODE_STANDBY);
+    }
+    if (fw) {
+        release_firmware(fw);
+    }
+    if(pdata->is_resume_processing == true)
+    {
+        dev_info(pdata->dev,"resume done!\n");
+        wake_unlock(&pdata->resume_wake_lock);
+        pdata->is_resume_processing = false;
+    }
+}
+
+int parse_arg(const char *s, struct auto_arg *arg)
+{
+    if (s[0] == '0' && (s[1] == 'x' || s[1] == 'X')) {
+        long v;
+        v = simple_strtol(s, NULL, 16);
+        arg->type = AUTO_ARG_TYPE_INT32;
+        arg->m_int32 = v;
+    } else if (isdigit(s[0])) {
+        long v;
+        v = simple_strtol(s, NULL, 10);
+        arg->type = AUTO_ARG_TYPE_INT32;
+        arg->m_int32 = v;
+    } else {
+        arg->type = AUTO_ARG_TYPE_STR;
+        arg->m_str = s;
+    }
+
+    return 0;
+}
+
+int parse_auto_args(char *s, struct auto_args *args)
+{
+    int i = 0;
+    char c = 0;
+    int last_is_arg_flag = 0;
+    const char *last_arg;
+
+    args->argc = 0;
+
+    i = -1;
+    do {
+        c = s[++i];
+        if (c == ' ' || c == ',' || c == '\n' || c == '\r' || c == 0) {
+            if (last_is_arg_flag) {
+                args->argc++;
+            }
+            last_is_arg_flag = 0;
+        } else {
+            last_is_arg_flag = 1;
+        }
+    } while(c != 0 && c != '\n' && c != '\r');
+
+    args->argv = (struct auto_arg*)kmalloc(
+            args->argc * sizeof(struct auto_arg), GFP_KERNEL);
+
+    i = -1;
+    last_is_arg_flag = 0;
+    last_arg = s;
+    args->argc = 0;
+    do {
+        c = s[++i];
+        if (c == ' ' || c == ',' || c == '\n' || c == '\r' || c == 0) {
+            if (last_is_arg_flag) {
+                parse_arg(last_arg, args->argv + args->argc++);
+                s[i] = 0;
+            }
+            last_is_arg_flag = 0;
+        } else {
+            if (last_is_arg_flag == 0) {
+                last_arg = s + i;
+            }
+            last_is_arg_flag = 1;
+        }
+    } while(c != 0 && c != '\n' && c != '\r');
+
+    return c == 0 ? i : i+1;
+}
+
+void free_auto_args(struct auto_args *args)
+{
+    kfree(args->argv);
+    args->argc = 0;
+}
+
+void int32_hexdump(const char *prefix, int32_t *data, int len)
+{
+    pr_err("%s\n", prefix);
+    print_hex_dump(KERN_ERR, "offset ", DUMP_PREFIX_OFFSET,
+            16, 4, data, len, false);
+    pr_err("\n");
+}
+
+int do_cmd_write(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int32_t addr;
+    int32_t len = (args->argc - 2) * sizeof(int32_t);
+    int32_t *data;
+    int i;
+
+    if (args->argc < 3 && args->argv[1].type != AUTO_ARG_TYPE_INT32) {
+        dev_err(pdata->dev, "Mis or unknown args!");
+        return -1;
+    }
+
+    len = MIN(len, APB_MAX_OP_BYTES);
+
+    addr = args->argv[1].m_int32;
+    data = (int32_t*)kmalloc(len, GFP_KERNEL);
+    for (i = 0; i < len/4; i++) {
+        if (args->argv[i+2].type != AUTO_ARG_TYPE_INT32) {
+            dev_err(pdata->dev, "Unknown args!");
+            kfree(data);
+            return -1;
+        }
+
+        data[i] = args->argv[i+2].m_int32;
+    }
+
+    spi2apb_write(pdata->spi, addr, data, len);
+
+    kfree(data);
+
+    dev_info(pdata->dev, "write addr: 0x%x, len: %d bytes", addr, len);
+    return 0;
+}
+
+int do_cmd_read(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int32_t addr;
+    int32_t len;
+    int32_t *data;
+
+    if (args->argc < 3 && args->argv[1].type != AUTO_ARG_TYPE_INT32) {
+        dev_err(pdata->dev, "Mis or unknown args!");
+        return -1;
+    }
+
+    addr = args->argv[1].m_int32;
+    if (args->argc == 2) {
+        len = 32;
+    } else {
+        if (args->argv[2].type != AUTO_ARG_TYPE_INT32) {
+            dev_err(pdata->dev, "Unknown args!");
+            return -1;
+        }
+        len = args->argv[2].m_int32 * sizeof(int32_t);
+        len = MIN(len, APB_MAX_OP_BYTES);
+    }
+
+    data = (int32_t*)kmalloc(len, GFP_KERNEL);
+
+    dev_info(pdata->dev, "\nread addr: %x, len: %d bytes", addr, len);
+    spi2apb_read(pdata->spi, addr, data, len);
+    int32_hexdump("read data:", data, len);
+    kfree(data);
+
+    return 0;
+}
+
+int do_cmd_set_spi_rate(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    if (args->argc < 2 && args->argv[1].type != AUTO_ARG_TYPE_INT32) {
+        dev_err(pdata->dev, "Mis or unknown args!");
+        return -1;
+    }
+
+    pdata->max_speed_hz = args->argv[1].m_int32;
+    dev_info(pdata->dev, "set spi max speed to %d!", pdata->max_speed_hz);
+
+    if (args->argc == 3 && args->argv[2].type == AUTO_ARG_TYPE_INT32) {
+        pdata->min_speed_hz = args->argv[2].m_int32;
+        dev_info(pdata->dev, "set spi min speed to %d!", pdata->min_speed_hz);
+    }
+
+    return 0;
+}
+
+int do_cmd_query(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int32_t state;
+
+    spi2apb_operation_query(pdata->spi, &state);
+    dev_info(pdata->dev, "state %x", state);
+    return 0;
+}
+
+int do_cmd_download_fw(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int ret = 0;
+    const char *fw_name = NULL;
+
+    if (args->argc == 2 && args->argv[1].type == AUTO_ARG_TYPE_STR) {
+        fw_name = args->argv[1].m_str;
+    }
+
+    ret = spi_download_fw(pdata->spi, fw_name);
+    if (ret)
+        dev_err(pdata->dev, "download firmware failed!");
+    else
+        dev_info(pdata->dev, "download firmware success!");
+    return 0;
+}
+
+int do_cmd_fast_write(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int ret = 0;
+    int32_t reg;
+
+    if (args->argc != 2 && args->argv[1].type != AUTO_ARG_TYPE_INT32) {
+        dev_err(pdata->dev, "Mis or unknown args!");
+        return -1;
+    }
+
+    reg = args->argv[1].m_int32;
+
+    ret = spi2apb_interrupt_request(pdata->spi, reg);
+    dev_info(pdata->dev, "interrupt request reg1:%x ret:%x", reg, ret);
+
+    return 0;
+}
+
+int do_cmd_fast_read(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int32_t state;
+    spi2apb_state_query(pdata->spi, &state);
+    dev_info(pdata->dev, "dsp state %x", state);
+
+    return 0;
+}
+
+int do_cmd_queue_init(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int state = 0;
+    state = dsp_msq_init(pdata->spi);
+    dev_info(pdata->dev, "message queue init state: %d", state);
+
+    return 0;
+}
+
+int do_cmd_send_msg(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    struct msg *m;
+    int ret = 0;
+    int msg_len;
+    int i = 0;
+
+    if (args->argc < 2) {
+        dev_err(pdata->dev, "need more args");
+        return -1;
+    }
+
+    msg_len = args->argc * sizeof(uint32_t);
+
+    m = (struct msg *)kmalloc(msg_len, GFP_KERNEL);
+    m->size = msg_len / 4;
+    for (i = 1; i < m->size; i++) {
+        if (args->argv[i].type != AUTO_ARG_TYPE_INT32) {
+            dev_err(pdata->dev, "Unknown args!");
+            kfree(m);
+            return -1;
+        }
+
+        *((int32_t*)m + i) = args->argv[i].m_int32;
+    }
+
+    ret = preisp_send_msg_to_dsp(pdata, m);
+
+    dev_info(pdata->dev, "send msg len: %d, ret: %x",
+            m->size, ret);
+
+    kfree(m);
+
+    return 0;
+}
+
+int do_cmd_recv_msg(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    struct msg *m;
+    char buf[256] = "";
+    int ret = 0;
+
+    ret = dsp_msq_recv_msg(pdata->spi, &m);
+    if (ret || m == NULL)
+        return 0;
+
+    dev_info(pdata->dev, "\nrecv msg len: %d, ret: %x",
+            m->size, ret);
+    int32_hexdump("recv msg:", (int32_t*)m, m->size * 4);
+
+    dev_info(pdata->dev, buf);
+
+    dsp_msq_free_received_msg(m);
+
+    return 0;
+}
+
+int do_cmd_power_on(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int ret;
+    ret = rkpreisp_power_on(pdata);
+    dev_info(pdata->dev, "do cmd power on, count++");
+    return ret;
+}
+
+int do_cmd_power_off(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int ret;
+    ret = rkpreisp_power_off(pdata);
+    dev_info(pdata->dev, "do cmd power off, count--");
+    return ret;
+}
+
+int do_cmd_set_dsp_log_level(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    int ret;
+
+    if (args->argc != 2 && args->argv[1].type != AUTO_ARG_TYPE_INT32) {
+        dev_err(pdata->dev, "Mis or unknown args!");
+        return -1;
+    }
+
+    pdata->log_level = args->argv[1].m_int32;
+    ret = rkpreisp_set_log_level(pdata, pdata->log_level);
+
+    dev_info(pdata->dev, "set dsp log level %d, ret: %d",
+            pdata->log_level, ret);
+
+    return ret;
+}
+
+int do_cmd_request_bypass(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    return rkpreisp_request_sleep(pdata, PREISP_SLEEP_MODE_BYPASS);
+}
+
+int do_cmd_request_sleep(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    return rkpreisp_request_sleep(pdata, PREISP_SLEEP_MODE_STANDBY);
+}
+
+int do_cmd_version(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    dev_info(pdata->dev, "driver version: %s", RKPREISP_VERSION);
+    return 0;
+}
+
+int do_cmd_wakeup(struct spi_rk_preisp_data *pdata,
+        const struct auto_args *args)
+{
+    return rkpreisp_wakeup(pdata);
+}
+
+int do_cmd(struct spi_rk_preisp_data *pdata,
+    const struct auto_args *args)
+{
+    const char * s;
+    if (args->argv->type != AUTO_ARG_TYPE_STR)
+        return 0;
+
+    s = args->argv->m_str;
+    //echo bypass > /dev/rk_preisp
+    if (!strcmp(s, "bypass")) return do_cmd_request_bypass(pdata, args);
+    //echo c > /dev/rk_preisp
+    if (!strcmp(s, "c")) return do_cmd_recv_msg(pdata, args);
+    //echo f [fw_name] > /dev/rk_preisp
+    if (!strcmp(s, "f")) return do_cmd_download_fw(pdata, args);
+    //echo fw reg1 > /dev/rk_preisp
+    if (!strcmp(s, "fw")) return do_cmd_fast_write(pdata, args);
+    //echo fr > /dev/rk_preisp
+    if (!strcmp(s, "fr")) return do_cmd_fast_read(pdata, args);
+    //echo i > /dev/rk_preisp
+    if (!strcmp(s, "i")) return do_cmd_queue_init(pdata, args);
+    //echo log level > /dev/rk_preisp
+    if (!strcmp(s, "log")) return do_cmd_set_dsp_log_level(pdata, args);
+    //echo on > /dev/rk_preisp
+    if (!strcmp(s, "on")) return do_cmd_power_on(pdata, args);
+    //echo off > /dev/rk_preisp
+    if (!strcmp(s, "off")) return do_cmd_power_off(pdata, args);
+    //echo q > /dev/rk_preisp
+    if (!strcmp(s, "q")) return do_cmd_query(pdata, args);
+    //echo r addr [length] > /dev/rk_preisp
+    if (!strcmp(s, "r")) return do_cmd_read(pdata, args);
+    //echo rate > /dev/rk_preisp
+    if (!strcmp(s, "rate")) return do_cmd_set_spi_rate(pdata, args);
+    //echo s type,... > /dev/rk_preisp
+    if (!strcmp(s, "s")) return do_cmd_send_msg(pdata, args);
+    //echo sleep > /dev/rk_preisp
+    if (!strcmp(s, "sleep")) return do_cmd_request_sleep(pdata, args);
+    //echo v > /dev/rk_preisp
+    if (!strcmp(s, "v")) return do_cmd_version(pdata, args);
+    //echo w addr value,... > /dev/rk_preisp
+    if (!strcmp(s, "w")) return do_cmd_write(pdata, args);
+    //echo wake > /dev/rk_preisp
+    if (!strcmp(s, "wake")) return do_cmd_wakeup(pdata, args);
+
+    return 0;
+}
+
+static int rkpreisp_open(struct inode *inode, struct file *file)
+{
+    struct spi_rk_preisp_data *pdata =
+        container_of(file->private_data, struct spi_rk_preisp_data, misc);
+
+    preisp_client *client = preisp_client_new();
+    client->private_data = pdata;
+    file->private_data = client;
+    rkpreisp_power_on(pdata);
+    return 0;
+}
+
+static int rkpreisp_release(struct inode *inode, struct file *file)
+{
+    preisp_client *client = file->private_data;
+    struct spi_rk_preisp_data *pdata = client->private_data;
+
+    preisp_client_disconnect(pdata, client);
+    preisp_client_release(client);
+    rkpreisp_power_off(pdata);
+    return 0;
+}
+
+static ssize_t rkpreisp_write(struct file *file,
+        const char __user *user_buf, size_t count, loff_t *ppos)
+{
+    char *buf;
+    struct auto_args args;
+    int i;
+    preisp_client *client = file->private_data;
+    struct spi_rk_preisp_data *pdata = client->private_data;
+
+    buf = (char *)kmalloc(count + 1, GFP_KERNEL);
+    if(copy_from_user(buf, user_buf, count))
+        return -EFAULT;
+    buf[count] = 0;
+
+    i = 0;
+    while (buf[i] != 0) {
+        i += parse_auto_args(buf + i, &args);
+        if (args.argc == 0)
+            continue;
+
+        do_cmd(pdata, &args);
+        free_auto_args(&args);
+    }
+
+    kfree(buf);
+
+    return count;
+}
+
+static void print_dsp_log(struct spi_rk_preisp_data *pdata, msg_dsp_log_t *log)
+{
+    char *str = (char *)(log);
+    str[log->size * sizeof(int32_t) - 1] = 0;
+    str += sizeof(msg_dsp_log_t);
+
+    dev_info(pdata->dev, "DSP%d: %s", log->core_id, str);
+}
+
+static void dispatch_received_msg(struct spi_rk_preisp_data *pdata,
+        struct msg *msg)
+{
+    preisp_client *client;
+
+#if DEBUG_DUMP_ALL_SEND_RECV_MSG == 1
+    int32_hexdump("recv msg:", (int32_t*)msg, msg->size*4);
+#endif
+
+    if (msg->type == id_msg_dsp_log_t) {
+        print_dsp_log(pdata, (msg_dsp_log_t*)msg);
+    } else if (msg->type == id_msg_do_i2c_t) {
+        ap_i2c_do_xfer(pdata->spi, (msg_do_i2c_t*)msg);
+    } else {
+        mutex_lock(&pdata->clients.mutex);
+        list_for_each_entry(client, &pdata->clients.list, list) {
+            if (client->id == msg->camera_id) {
+                msq_send_msg(&client->q, msg);
+                wake_up_interruptible(&client->wait);
+            }
+        }
+        mutex_unlock(&pdata->clients.mutex);
+    }
+}
+
+static long rkpreisp_ioctl(struct file *file,
+        unsigned int cmd, unsigned long arg)
+{
+    int ret = 0;
+    void __user *ubuf = (void __user *)arg;
+    preisp_client *client = file->private_data;
+    struct spi_rk_preisp_data *pdata = client->private_data;
+
+    switch (cmd) {
+    case PREISP_POWER_ON:
+        ret = rkpreisp_power_on(pdata);
+        break;
+    case PREISP_POWER_OFF:
+        ret = rkpreisp_power_off(pdata);
+        break;
+    case PREISP_REQUEST_SLEEP: {
+        int sleep_mode = arg;
+        ret = rkpreisp_request_sleep(pdata, sleep_mode);
+        break;
+    }
+    case PREISP_WAKEUP:
+        ret = rkpreisp_wakeup(pdata);
+        break;
+    case PREISP_DOWNLOAD_FW: {
+        char fw_name[PREISP_FW_NAME_LEN];
+        if (strncpy_from_user(fw_name, ubuf, PREISP_FW_NAME_LEN) <= 0) {
+            ret = -EINVAL;
+            break;
+        }
+        dev_info(pdata->dev, "download fw:%s", fw_name);
+        ret = spi_download_fw(pdata->spi, fw_name);
+        break;
+    }
+    case PREISP_RESET_FW: {
+        char fw_name[PREISP_FW_NAME_LEN];
+        if (strncpy_from_user(fw_name, ubuf, PREISP_FW_NAME_LEN) <= 0) {
+            ret = -EINVAL;
+            break;
+        }
+        dev_info(pdata->dev, "reset fw:%s", fw_name);
+        ret = rkpreisp_reset(pdata, fw_name);
+        break;
+    }
+    case PREISP_APB_WRITE: {
+        struct preisp_apb_pkt pkt;
+        int32_t *data;
+
+        if (copy_from_user(&pkt, ubuf, sizeof(pkt))) {
+            ret = -EINVAL;
+            break;
+        }
+        pkt.data_len = MIN(pkt.data_len, APB_MAX_OP_BYTES);
+        data = kmalloc(pkt.data_len, GFP_KERNEL);
+        if (copy_from_user(data, (void __user*)pkt.data, pkt.data_len)) {
+            kfree(data);
+            ret = -EINVAL;
+            break;
+        }
+        ret = spi2apb_safe_write(pdata->spi, pkt.addr, data, pkt.data_len);
+        kfree(data);
+        break;
+    }
+    case PREISP_APB_READ: {
+        struct preisp_apb_pkt pkt;
+        int32_t *data;
+
+        if (copy_from_user(&pkt, ubuf, sizeof(pkt))) {
+            ret = -EINVAL;
+            break;
+        }
+        pkt.data_len = MIN(pkt.data_len, APB_MAX_OP_BYTES);
+        data = kmalloc(pkt.data_len, GFP_KERNEL);
+        ret = spi2apb_safe_read(pdata->spi, pkt.addr, data, pkt.data_len);
+        if (ret) {
+            kfree(data);
+            break;
+        }
+        ret = copy_to_user((void __user*)pkt.data, data, pkt.data_len);
+
+        kfree(data);
+        break;
+    }
+    case PREISP_ST_QUERY: {
+        int32_t state;
+        ret = spi2apb_state_query(pdata->spi, &state);
+        if (ret)
+            break;
+
+        ret = put_user(state, (int32_t __user *)ubuf);
+        break;
+    }
+    case PREISP_IRQ_REQUEST: {
+        int int_num = arg;
+        ret = spi2apb_interrupt_request(pdata->spi, int_num);
+        break;
+    }
+    case PREISP_SEND_MSG: {
+        struct msg *msg;
+        uint32_t len;
+
+        if (get_user(len, (uint32_t __user*)ubuf)) {
+            ret = -EINVAL;
+            break;
+        }
+        len = len * sizeof(int32_t);
+        msg = kmalloc(len, GFP_KERNEL);
+        if (copy_from_user(msg, ubuf, len)) {
+            kfree(msg);
+            ret = -EINVAL;
+            break;
+        }
+#if DEBUG_DUMP_ALL_SEND_RECV_MSG == 1
+        int32_hexdump("send msg:", (int32_t*)msg, len);
+#endif
+
+#if DEBUG_MSG_LOOP_TEST == 0
+        ret = preisp_send_msg_to_dsp(pdata, msg);
+#else
+        dispatch_received_msg(pdata, msg);
+#endif
+        kfree(msg);
+        break;
+    }
+    case PREISP_QUERY_MSG: {
+        struct msg *msg;
+        ret = msq_recv_msg(&client->q, &msg);
+        if (ret)
+            break;
+
+        ret = put_user(msg->size, (uint32_t __user*)ubuf);
+        break;
+    }
+    case PREISP_RECV_MSG: {
+        struct msg *msg;
+        ret = msq_recv_msg(&client->q, &msg);
+        if (ret)
+            break;
+        ret = copy_to_user(ubuf, msg, msg->size * sizeof(uint32_t));
+        msq_free_received_msg(&client->q, msg);
+        break;
+    }
+    case PREISP_CLIENT_CONNECT:
+    {
+        int id = arg;
+        client->id = id;
+        ret = preisp_client_connect(pdata, client);
+        break;
+    }
+    case PREISP_CLIENT_DISCONNECT:
+    {
+        preisp_client_disconnect(pdata, client);
+        client->id = INVALID_ID;
+        break;
+    }
+    default:
+        ret = -EINVAL;
+        break;
+    }
+
+    return ret;
+}
+
+static unsigned int rkpreisp_poll(struct file *file, poll_table *wait)
+{
+    preisp_client *client = file->private_data;
+    unsigned int mask = 0;
+
+    poll_wait(file, &client->wait, wait);
+
+    if (!msq_is_empty(&client->q))
+        mask |= POLLIN;
+
+    return mask;
+}
+
+static const struct file_operations rkpreisp_fops = {
+    .owner = THIS_MODULE,
+    .open = rkpreisp_open,
+    .release = rkpreisp_release,
+    .write = rkpreisp_write,
+    .poll = rkpreisp_poll,
+    .unlocked_ioctl = rkpreisp_ioctl,
+    .compat_ioctl = rkpreisp_ioctl,
+};
+
+static irqreturn_t rkpreisp_threaded_isr(int irq, void *dev_id)
+{
+    struct spi_rk_preisp_data *pdata = dev_id;
+    struct msg *msg;
+
+    BUG_ON(irq != pdata->irq);
+
+    mutex_lock(&pdata->power_lock);
+    if (atomic_read(&pdata->power_on_cnt) > 0 &&
+        atomic_read(&pdata->wake_sleep_cnt) > 0) {
+        while (!dsp_msq_recv_msg(pdata->spi, &msg) && msg != NULL) {
+            dispatch_received_msg(pdata, msg);
+            dsp_msq_free_received_msg(msg);
+        }
+    }
+    mutex_unlock(&pdata->power_lock);
+
+    return IRQ_HANDLED;
+}
+
+static irqreturn_t rkpreisp_sleep_isr(int irq, void *dev_id)
+{
+    struct spi_rk_preisp_data *pdata = dev_id;
+
+    BUG_ON(irq != pdata->sleepst_irq);
+    pr_info("dsp enter sleep done!");
+
+    /* disable vdd-core-regulator */
+    if (!IS_ERR(pdata->vdd_core_regu) && pdata->sleep_mode == PREISP_SLEEP_MODE_STANDBY ) {
+        if (regulator_is_enabled(pdata->vdd_core_regu) > 0) {
+            regulator_disable(pdata->vdd_core_regu);
+        }
+    }
+
+    pdata->sleep_state_flag = 1;
+
+    return IRQ_HANDLED;
+}
+
+static int rkpreisp_parse_dt_property(struct device *dev,
+                  struct spi_rk_preisp_data *pdata)
+{
+    int ret = 0;
+    struct device_node *node = dev->of_node;
+    enum of_gpio_flags flags;
+    const char * regu_name;
+
+    if (!node)
+        return -ENODEV;
+
+    of_property_read_u32(node, "spi-max-frequency",
+            &pdata->max_speed_hz);
+
+    ret = of_property_read_u32(node, "spi-min-frequency",
+            &pdata->min_speed_hz);
+    if (ret) {
+        dev_warn(dev, "can not get spi-min-frequency!");
+        pdata->min_speed_hz = pdata->max_speed_hz / 2;
+    }
+
+    pdata->mclk = devm_clk_get(dev, "mclk");
+    if (IS_ERR(pdata->mclk)) {
+        dev_warn(dev, "can not get mclk, error %ld\n", PTR_ERR(pdata->mclk));
+        pdata->mclk = NULL;
+    }
+
+    ret = of_get_named_gpio_flags(node, "reset-gpio", 0, &flags);
+    if (ret <= 0) {
+        dev_warn(dev, "can not find property reset-gpio, error %d\n", ret);
+    }
+
+    pdata->reset_gpio = ret;
+    pdata->reset_active = 1;
+    if (flags == OF_GPIO_ACTIVE_LOW) {
+        pdata->reset_active = 0;
+    }
+
+    if (pdata->reset_gpio > 0) {
+        ret = devm_gpio_request(dev, pdata->reset_gpio, "preisp-reset");
+        if (ret) {
+            dev_err(dev, "gpio %d request error %d\n", pdata->reset_gpio, ret);
+            return ret;
+        }
+
+        ret = gpio_direction_output(pdata->reset_gpio, !pdata->reset_active);
+        if (ret) {
+            dev_err(dev, "gpio %d direction output error %d\n",
+                    pdata->reset_gpio, ret);
+            return ret;
+        }
+    }
+
+    ret = of_get_named_gpio_flags(node, "irq-gpio", 0, NULL);
+    if (ret <= 0) {
+        dev_warn(dev, "can not find property irq-gpio, error %d\n", ret);
+        return ret;
+    }
+
+    pdata->irq_gpio = ret;
+
+    ret = devm_gpio_request(dev, pdata->irq_gpio, "preisp-irq");
+    if (ret) {
+        dev_err(dev, "gpio %d request error %d\n", pdata->irq_gpio, ret);
+        return ret;
+    }
+
+    ret = gpio_direction_input(pdata->irq_gpio);
+    if (ret) {
+        dev_err(dev, "gpio %d direction input error %d\n",
+                pdata->irq_gpio, ret);
+        return ret;
+    }
+
+    ret = gpio_to_irq(pdata->irq_gpio);
+    if (ret < 0) {
+        dev_err(dev, "Unable to get irq number for GPIO %d, error %d\n",
+            pdata->irq_gpio, ret);
+        return ret;
+    }
+    pdata->irq = ret;
+    ret = request_threaded_irq(pdata->irq, NULL, rkpreisp_threaded_isr,
+            IRQF_TRIGGER_RISING | IRQF_ONESHOT, "preisp-irq", pdata);
+    if (ret) {
+        dev_err(dev, "cannot request thread irq: %d\n", ret);
+        return ret;
+    }
+
+    disable_irq(pdata->irq);
+
+    /* for pdvdd-regulator */
+    ret = of_property_read_string(node, "pdvdd-regulator", &regu_name);
+    if(!ret) {
+        pdata->pdvdd_regu = regulator_get(dev, regu_name);
+        if (!IS_ERR(pdata->pdvdd_regu)) {
+            //regulator_set_voltage(pdata->pdvdd_regu,1000000,1000000); //for adjustable regulator
+            dev_info(dev, "regulator: %s, voltage:%d\n", regu_name, regulator_get_voltage(pdata->pdvdd_regu));
+            /* disable regulator */
+            if (regulator_is_enabled(pdata->pdvdd_regu) > 0) {
+                regulator_disable(pdata->pdvdd_regu);
+            }
+        } else {
+            dev_warn(dev,"get regulator: %s fail\n", regu_name);
+        }
+    } else {
+        pdata->pdvdd_regu = ERR_PTR(-EPERM);
+        dev_warn(dev, "no pdvdd-regulator found\n");
+    }
+
+    /* for vdd-core-regulator */
+    ret = of_property_read_string(node, "vdd-core-regulator", &regu_name);
+    if(!ret) {
+        pdata->vdd_core_regu = regulator_get(dev, regu_name);
+        if (!IS_ERR(pdata->vdd_core_regu)) {
+            //regulator_set_voltage(pdata->vdd_core_regu,1000000,1000000); //for adjustable regulator
+            dev_info(dev, "regulator: %s, voltage:%d\n", regu_name, regulator_get_voltage(pdata->vdd_core_regu));
+            /* disable regulator */
+            if (regulator_is_enabled(pdata->vdd_core_regu) > 0) {
+                regulator_disable(pdata->vdd_core_regu);
+            }
+        } else {
+            dev_warn(dev,"get regulator: %s fail\n", regu_name);
+        }
+    } else {
+        pdata->vdd_core_regu = ERR_PTR(-EPERM);
+        dev_warn(dev, "no vdd-core-regulator found\n");
+    }
+
+    pdata->sleepst_gpio = -1;
+    pdata->sleepst_irq = -1;
+    pdata->wakeup_gpio = -1;
+
+    ret = of_get_named_gpio_flags(node, "sleepst-gpio", 0, NULL);
+    if (ret <= 0) {
+        dev_warn(dev, "can not find property sleepst-gpio, error %d\n", ret);
+        return 0;
+    }
+
+    pdata->sleepst_gpio = ret;
+
+    ret = devm_gpio_request(dev, pdata->sleepst_gpio, "preisp-sleep-irq");
+    if (ret) {
+        dev_err(dev, "gpio %d request error %d\n", pdata->sleepst_gpio, ret);
+        return 0;
+    }
+
+    ret = gpio_direction_input(pdata->sleepst_gpio);
+    if (ret) {
+        dev_err(dev, "gpio %d direction input error %d\n",
+                pdata->sleepst_gpio, ret);
+        return ret;
+    }
+
+    ret = gpio_to_irq(pdata->sleepst_gpio);
+    if (ret < 0) {
+        dev_err(dev, "Unable to get irq number for GPIO %d, error %d\n",
+            pdata->sleepst_gpio, ret);
+        return ret;
+    }
+    pdata->sleepst_irq = ret;
+    ret = request_any_context_irq(pdata->sleepst_irq, rkpreisp_sleep_isr,
+            IRQF_TRIGGER_RISING, "preisp-sleep-irq", pdata);
+    disable_irq(pdata->sleepst_irq);
+
+    ret = of_get_named_gpio_flags(node, "wakeup-gpio", 0, &flags);
+    if (ret <= 0) {
+        dev_warn(dev, "can not find property wakeup-gpio, error %d\n", ret);
+    }
+
+    pdata->wakeup_gpio = ret;
+    pdata->wakeup_active = 1;
+    if (flags == OF_GPIO_ACTIVE_LOW) {
+        pdata->wakeup_active = 0;
+    }
+
+    if (pdata->wakeup_gpio > 0) {
+        ret = devm_gpio_request(dev, pdata->wakeup_gpio, "preisp-wakeup");
+        if (ret) {
+            dev_err(dev, "gpio %d request error %d\n", pdata->wakeup_gpio, ret);
+            return ret;
+        }
+
+        ret = gpio_direction_output(pdata->wakeup_gpio, !pdata->wakeup_active);
+        if (ret) {
+            dev_err(dev, "gpio %d direction output error %d\n",
+                    pdata->wakeup_gpio, ret);
+            return ret;
+        }
+    }
+
+    ret = of_property_read_u32(node, "firmware-nowait-mode", &pdata->fw_nowait_mode);
+    if (ret) {
+        dev_warn(dev, "can not get firmware-nowait-mode!");
+        pdata->fw_nowait_mode = 0;
+    }
+
+    return ret;
+}
+
+static int spi_rk_preisp_probe(struct spi_device *spi)
+{
+    struct spi_rk_preisp_data *data;
+    int err;
+
+    dev_info(&spi->dev, "rk preisp spi probe start, verison:%s",
+            RKPREISP_VERSION);
+    data = devm_kzalloc(&spi->dev, sizeof(*data), GFP_KERNEL);
+    if (!data) {
+        return -ENOMEM;
+    }
+    atomic_set(&data->power_on_cnt, 0);
+    atomic_set(&data->wake_sleep_cnt, 0);
+    preisp_client_list_init(&data->clients);
+    mutex_init(&data->send_msg_lock);
+    mutex_init(&data->power_lock);
+    wake_lock_init(&data->resume_wake_lock, WAKE_LOCK_SUSPEND, "Preisp_Wake_Lock");
+
+    data->spi = spi;
+    data->dev = &spi->dev;
+    rkpreisp_parse_dt_property(data->dev, data);
+
+    spi_set_drvdata(spi, data);
+    data->log_level = LOG_INFO;
+
+    data->misc.minor = MISC_DYNAMIC_MINOR;
+    data->misc.name = "rk_preisp";
+    data->misc.fops = &rkpreisp_fops;
+
+    err = misc_register(&data->misc);
+    if (err < 0) {
+        dev_err(data->dev, "Error: misc_register returned %d", err);
+    }
+
+    err = cif_preisp_create(data);
+    if (err) {
+        dev_err(data->dev, "cif_preisp img_srcs init failed!");
+    }
+
+#if ENABLE_CACHE_FIRMWARE
+    cache_firmware(RKL_DEFAULT_FW_NAME);
+#endif
+    if (!data->fw_nowait_mode) {
+        return 0;
+    }
+
+    err = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+            RKL_DEFAULT_FW_NAME, data->dev, GFP_KERNEL, data, fw_nowait_power_on);
+    if (err) {
+        dev_err(data->dev, "request firmware nowait failed!");
+    }
+
+    return 0;
+}
+
+static int spi_rk_preisp_remove(struct spi_device *spi)
+{
+    struct spi_rk_preisp_data *data = spi_get_drvdata(spi);
+#if ENABLE_CACHE_FIRMWARE
+    uncache_firmware(RKL_DEFAULT_FW_NAME);
+#endif
+    spi_set_drvdata(spi, NULL);
+    misc_deregister(&data->misc);
+    return 0;
+}
+
+static int spi_rk_preisp_suspend(struct spi_device *spi, pm_message_t mesg)
+{
+    struct spi_rk_preisp_data *pdata = spi_get_drvdata(spi);
+
+    if (!pdata->fw_nowait_mode) {
+        return 0;
+    }
+    rkpreisp_power_off(pdata);
+
+    return 0;
+}
+
+static int spi_rk_preisp_resume(struct spi_device *spi)
+{
+    struct spi_rk_preisp_data *pdata = spi_get_drvdata(spi);
+    int ret = 0;
+
+    if (pdata->wakeup_gpio > 0) {
+        gpio_direction_output(pdata->wakeup_gpio, !pdata->wakeup_active);
+    }
+    if (pdata->reset_gpio > 0) {
+        gpio_direction_output(pdata->reset_gpio, !pdata->reset_active);
+    }
+    if (!pdata->fw_nowait_mode)
+        return 0;
+
+    wake_lock(&pdata->resume_wake_lock);
+    pdata->is_resume_processing = true;
+    ret = request_firmware_nowait(THIS_MODULE, FW_ACTION_HOTPLUG,
+            RKL_DEFAULT_FW_NAME, pdata->dev, GFP_KERNEL, pdata, fw_nowait_power_on);
+    if (ret) {
+        dev_err(pdata->dev, "request firmware nowait failed!");
+        wake_unlock(&pdata->resume_wake_lock);
+    }
+    return ret;
+}
+
+/*
+dts:
+    spi_rk_preisp@xx {
+        compatible =  "rockchip,spi_rk_preisp";
+        reg = <x>;
+        spi-max-frequency = <48000000>;
+        //spi-cpol;
+        //spi-cpha;
+        firmware-nowait-mode = <0>;
+        reset-gpio = <&gpio6 GPIO_A0 GPIO_ACTIVE_HIGH>;
+        irq-gpio = <&gpio6 GPIO_A2 GPIO_ACTIVE_HIGH>;
+        clocks = <&xxx>;
+        clock-names = "mclk";
+        //pdvdd-regulator = "preisp-pdvdd";
+        vdd-core-regulator = "preisp-vdd-core";
+
+    };
+*/
+
+static const struct of_device_id spi_rk_preisp_dt_match[] = {
+    { .compatible = "rockchip,spi_rk_preisp", },
+    {},
+};
+MODULE_DEVICE_TABLE(of, spi_rk_preisp_dt_match);
+
+static struct spi_driver spi_rk_preisp_driver = {
+    .driver = {
+        .name   = "spi_rk_preisp",
+        .owner  = THIS_MODULE,
+        .of_match_table = of_match_ptr(spi_rk_preisp_dt_match),
+    },
+    .probe      = spi_rk_preisp_probe,
+    .remove     = spi_rk_preisp_remove,
+    .suspend    = spi_rk_preisp_suspend,
+    .resume     = spi_rk_preisp_resume,
+};
+module_rkprespi_driver(spi_rk_preisp_driver);
+
+MODULE_AUTHOR("Tusson <dusong@rock-chips.com>");
+MODULE_DESCRIPTION("Rockchip spi interface for PreIsp");
+MODULE_LICENSE("GPL");
diff --git a/drivers/media/platform/preisp_driver/spi-rkpreisp.h b/drivers/media/platform/preisp_driver/spi-rkpreisp.h
new file mode 100644
index 0000000..cbba64b
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/spi-rkpreisp.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __SPI_RK_PREISP_H__
+#define __SPI_RK_PREISP_H__
+
+#include <linux/miscdevice.h>
+#include <linux/types.h>
+#include "spi2apb.h"
+#include "msg-queue.h"
+
+#define RKPREISP_VERSION "1.0.11"
+
+#define PREISP_FW_NAME_LEN 128
+
+struct preisp_apb_pkt {
+    int32_t  data_len;
+    int32_t  addr;
+    int32_t* data;
+};
+
+enum {
+    PREISP_SLEEP_MODE_BYPASS = 0,
+    PREISP_SLEEP_MODE_STANDBY,
+    PREISP_SLEEP_MODE_MAX
+};
+
+#define PREISP_POWER_ON     _IO('p',   1)
+#define PREISP_POWER_OFF    _IO('p',   2)
+#define PREISP_REQUEST_SLEEP _IOW('p',  3, int32_t)
+#define PREISP_WAKEUP       _IO('p',   4)
+#define PREISP_DOWNLOAD_FW  _IOW('p',  5, char[PREISP_FW_NAME_LEN])
+#define PREISP_APB_WRITE    _IOW('p',  6, struct preisp_apb_pkt)
+#define PREISP_APB_READ     _IOR('p',  7, struct preisp_apb_pkt)
+#define PREISP_ST_QUERY     _IOR('p',  8, int32_t)
+#define PREISP_IRQ_REQUEST  _IOW('p',  9, int32_t)
+#define PREISP_SEND_MSG     _IOW('p', 11, int32_t)
+#define PREISP_QUERY_MSG    _IOR('p', 12, int32_t)
+#define PREISP_RECV_MSG     _IOR('p', 13, int32_t)
+#define PREISP_CLIENT_CONNECT    _IOW('p', 15, int32_t)
+#define PREISP_CLIENT_DISCONNECT  _IO('p', 16)
+#define PREISP_RESET_FW     _IOW('p',  17, char[PREISP_FW_NAME_LEN])
+
+#define DEBUG_POLL_MODE_READ_MSG 0
+#define DEBUG_DUMP_ALL_SEND_RECV_MSG 0
+
+/**
+ * rk_module_driver() - Helper macro for drivers that don't do anything
+ * special in module init/exit. This eliminates a lot of boilerplate.
+ * Each module may only use this macro once, and calling it replaces
+ * module_init() and module_exit().
+ *
+ * @__driver: driver name
+ * @__register: register function for this driver type
+ * @__unregister: unregister function for this driver type
+ * @...: Additional arguments to be passed to __register and __unregister.
+ *
+ * Use this macro to construct bus specific macros for registering
+ * drivers, and do not use it on its own.
+ */
+#define rk_module_driver(__driver, __register, __unregister, ...) \
+static int __init __driver##_init(void) \
+{ \
+	return __register(&(__driver) , ##__VA_ARGS__); \
+} \
+device_initcall_sync(__driver##_init); \
+static void __exit __driver##_exit(void) \
+{ \
+	__unregister(&(__driver) , ##__VA_ARGS__); \
+} \
+module_exit(__driver##_exit);
+
+/**
+ * module_rkprespi_driver() - Helper macro for registering a SPI driver
+ * @__spi_driver: spi_driver struct
+ *
+ * Helper macro for RKPRESPI drivers which do not do anything special in module
+ * init/exit. This eliminates a lot of boilerplate. Each module may only
+ * use this macro once, and calling it replaces module_init() and module_exit()
+ */
+#define module_rkprespi_driver(__spi_driver) \
+	rk_module_driver(__spi_driver, spi_register_driver, \
+			spi_unregister_driver)
+
+enum cif_preisp_cfg_cmd {
+	CIF_PREISP_STREAM = 0,
+	CIF_PREISP_POWER = 1,
+	CIF_PREISP_ENUM_STRM_FMTS = 2,
+	CIF_PREISP_STRM_FMT_DESC = 3,
+	CIF_PREISP_S_FRMAE_INTERVAL = 4,
+	CIF_PREISP_G_FRMAE_INTERVAL = 5,
+	CIF_PREISP_SUBDEV_G_CTRL = 6,
+	CIF_PREISP_SUBDEV_S_CTRL = 7,
+	CIF_PREISP_S_EXT_CTRL = 8,
+	CIF_PREISP_IOCTL = 9,
+	CIF_PREISP_POWER_ON = 10,
+	CIF_PREISP_POWER_OFF = 11,
+	CIF_PREISP_INIT_SENSOR = 12,
+	CIF_PREISP_SET_SIZE = 13,
+	CIF_PREISP_STREAM_IN_ON = 14,
+	CIF_PREISP_STREAM_IN_OFF = 15,
+	CIF_PREISP_STREAM_OUT_ON = 16,
+	CIF_PREISP_STREAM_OUT_OFF = 17,
+	CIF_PREISP_CLIENT_NEW = 18,
+	CIF_PREISP_CLIENT_RELEASE = 19,
+	CIF_PREISP_CLIENT_CONNECT = 20,
+	CIF_PREISP_CLIENT_DISCONNECT = 21,
+	CIF_PREISP
+};
+
+struct cif_preisp_cfg_para {
+	enum cif_preisp_cfg_cmd cmd;
+	int id;
+	void *cfg_para;
+};
+
+typedef struct {
+    int8_t id;
+    struct msg_queue q;
+    struct list_head list;
+    wait_queue_head_t wait;
+    void *private_data;
+} preisp_client;
+
+typedef struct {
+    struct mutex mutex;
+    struct list_head list;
+} preisp_client_list;
+
+struct spi_rk_preisp_data {
+    struct miscdevice misc;
+    struct spi_device *spi;
+    struct device *dev;
+    preisp_client_list clients;
+    int reset_gpio;
+    int reset_active;
+    int irq_gpio;
+    int irq;
+    int sleepst_gpio;
+    int sleepst_irq;
+    int sleep_mode;
+    int wakeup_gpio;
+    int wakeup_active;
+    struct clk *mclk;
+    atomic_t power_on_cnt;
+    atomic_t wake_sleep_cnt;
+    struct mutex send_msg_lock;
+    struct mutex power_lock;
+    struct wake_lock resume_wake_lock;
+    uint32_t max_speed_hz;
+    uint32_t min_speed_hz;
+    uint32_t fw_nowait_mode;
+    struct regulator *pdvdd_regu;
+    struct regulator *vdd_core_regu;
+    int log_level;
+    int sleep_state_flag;
+    bool is_resume_processing;
+
+    preisp_client *rkpreisp_client[10];   
+    struct cif_preisp_img_src *img_src_array[10];
+    unsigned int img_src_cnt;
+    struct pltfrm_soc_cfg *soc_cfg;
+    int (*cif_preisp_cfg)(struct device *, struct cif_preisp_cfg_para *);
+};
+
+int preisp_send_msg_to_dsp(struct spi_rk_preisp_data *pdata, const struct msg *m);
+preisp_client* preisp_client_new(void);
+void preisp_client_release(preisp_client *c);
+int preisp_client_connect(struct spi_rk_preisp_data *pdata, preisp_client *c);
+void preisp_client_disconnect(struct spi_rk_preisp_data *pdata, preisp_client *c);
+int rkpreisp_power_on(struct spi_rk_preisp_data *pdata);
+int rkpreisp_power_off(struct spi_rk_preisp_data *pdata);
+#endif
diff --git a/drivers/media/platform/preisp_driver/spi2apb.c b/drivers/media/platform/preisp_driver/spi2apb.c
new file mode 100644
index 0000000..25f8262
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/spi2apb.c
@@ -0,0 +1,528 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/delay.h>
+#include "spi2apb.h"
+
+static DEFINE_MUTEX(spi2apb_lock);
+
+uint8_t int8_msb2lsb(uint8_t src)
+{
+    int i;
+    uint8_t dst = 0;
+
+    for (i = 0; i < 8; i++) {
+        uint8_t t = 0;
+        t = (((src >> i) & 0x01) << (7 - i));
+        dst |= t;
+    }
+
+    return dst;
+}
+
+uint32_t int32_msb2lsb(uint32_t src)
+{
+    uint32_t dst = 0;
+    int i;
+
+    for (i = 0; i < 4; i++) {
+        int shift = i * 8;
+        dst = dst | (int8_msb2lsb((src >> shift) & 0xff) << shift);
+    }
+
+    return dst;
+}
+
+int spi2apb_lsb_w32(struct spi_device *spi,
+        int32_t addr, int32_t data)
+{
+    int32_t write_cmd = APB_CMD_WRITE;
+    struct spi_transfer write_cmd_packet = {
+        .tx_buf = &write_cmd,
+        .len    = sizeof(write_cmd),
+    };
+    struct spi_transfer addr_packet = {
+        .tx_buf = &addr,
+        .len    = sizeof(addr),
+    };
+    struct spi_transfer data_packet = {
+        .tx_buf = &data,
+        .len    = sizeof(data),
+    };
+    struct spi_message  m;
+
+    write_cmd = int32_msb2lsb(write_cmd);
+    addr = int32_msb2lsb(addr);
+    data = int32_msb2lsb(data);
+
+    spi_message_init(&m);
+    spi_message_add_tail(&write_cmd_packet, &m);
+    spi_message_add_tail(&addr_packet, &m);
+    spi_message_add_tail(&data_packet, &m);
+    return spi_sync(spi, &m);
+}
+
+#define SPI_CTRL0   0x11060000
+#define SPI_ENR     0x11060008
+
+/**
+ * spi2apb_switch_to_msb - SPI2APB set Fist bit mode to MSB
+ *
+ * @spi: spi device
+ * Context: can sleep
+ *
+ */
+void spi2apb_switch_to_msb(struct spi_device *spi)
+{
+    mutex_lock(&spi2apb_lock);
+    spi2apb_lsb_w32(spi, SPI_ENR, 0);
+    spi2apb_lsb_w32(spi, SPI_CTRL0, 0x108002);
+    mutex_unlock(&spi2apb_lock);
+}
+
+/**
+ * _spi2apb_write - SPI2APB synchronous write
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+static int _spi2apb_write(struct spi_device *spi,
+        int32_t addr, const int32_t *data, size_t data_len)
+{
+    int32_t write_cmd = APB_CMD_WRITE;
+    struct spi_transfer write_cmd_packet = {
+        .tx_buf = &write_cmd,
+        .len    = sizeof(write_cmd),
+    };
+    struct spi_transfer addr_packet = {
+        .tx_buf = &addr,
+        .len    = sizeof(addr),
+    };
+    struct spi_transfer data_packet = {
+        .tx_buf = data,
+        .len    = data_len,
+    };
+    struct spi_message  m;
+
+    spi_message_init(&m);
+    spi_message_add_tail(&write_cmd_packet, &m);
+    spi_message_add_tail(&addr_packet, &m);
+    spi_message_add_tail(&data_packet, &m);
+    return spi_sync(spi, &m);
+}
+
+/**
+ * spi2apb_write - SPI2APB synchronous write
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_write(struct spi_device *spi,
+        int32_t addr, const int32_t *data, size_t data_len)
+{
+    int ret = 0;
+    mutex_lock(&spi2apb_lock);
+    ret = _spi2apb_write(spi, addr, data, data_len);
+    mutex_unlock(&spi2apb_lock);
+    return ret;
+}
+
+/**
+ * spi2apb_w32 - SPI2APB synchronous 32-bit write
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_w32(struct spi_device *spi,
+        int32_t addr, int32_t data)
+{
+    return spi2apb_write(spi, addr, &data, 4);
+}
+
+/**
+ * _spi2apb_read - SPI2APB synchronous read
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer [out]
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+static int _spi2apb_read(struct spi_device *spi,
+        int32_t addr, int32_t *data, size_t data_len)
+{
+    int32_t real_len = MIN(data_len, APB_MAX_OP_BYTES);
+    int32_t read_cmd = APB_CMD_READ | (real_len << 14 & 0xffff0000);
+    int32_t read_begin_cmd = APB_CMD_READ_BEGIN;
+    int32_t dummy = 0;
+    struct spi_transfer read_cmd_packet = {
+        .tx_buf = &read_cmd,
+        .len    = sizeof(read_cmd),
+    };
+    struct spi_transfer addr_packet = {
+        .tx_buf = &addr,
+        .len    = sizeof(addr),
+    };
+    struct spi_transfer read_dummy_packet = {
+        .tx_buf = &dummy,
+        .len    = sizeof(dummy),
+    };
+    struct spi_transfer read_begin_cmd_packet = {
+        .tx_buf = &read_begin_cmd,
+        .len    = sizeof(read_begin_cmd),
+    };
+    struct spi_transfer data_packet = {
+        .rx_buf = data,
+        .len    = data_len,
+    };
+    struct spi_message  m;
+
+    spi_message_init(&m);
+    spi_message_add_tail(&read_cmd_packet, &m);
+    spi_message_add_tail(&addr_packet, &m);
+    spi_message_add_tail(&read_dummy_packet, &m);
+    spi_message_add_tail(&read_begin_cmd_packet, &m);
+    spi_message_add_tail(&data_packet, &m);
+    return spi_sync(spi, &m);
+}
+
+/**
+ * spi2apb_read - SPI2APB synchronous read
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer [out]
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_read(struct spi_device *spi,
+        int32_t addr, int32_t *data, size_t data_len)
+{
+    int ret = 0;
+    mutex_lock(&spi2apb_lock);
+    ret = _spi2apb_read(spi, addr, data, data_len);
+    mutex_unlock(&spi2apb_lock);
+    return ret;
+}
+
+/**
+ * spi2apb_r32 - SPI2APB synchronous 32-bit read
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data buffer [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_r32(struct spi_device *spi,
+        int32_t addr, int32_t *data)
+{
+    return spi2apb_read(spi, addr, data, 4);
+}
+
+/**
+ * _spi2apb_operation_query - SPI2APB last operation state query
+ *
+ * @spi: device from which data will be read
+ * @state: last operation state [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+static int _spi2apb_operation_query(struct spi_device *spi, int32_t *state)
+{
+    int32_t query_cmd = APB_CMD_QUERY;
+    struct spi_transfer query_cmd_packet = {
+        .tx_buf = &query_cmd,
+        .len    = sizeof(query_cmd),
+    };
+    struct spi_transfer state_packet = {
+        .rx_buf = state,
+        .len    = sizeof(*state),
+    };
+    struct spi_message  m;
+
+    spi_message_init(&m);
+    spi_message_add_tail(&query_cmd_packet, &m);
+    spi_message_add_tail(&state_packet, &m);
+    spi_sync(spi, &m);
+
+    return ((*state & APB_OP_STATE_ID_MASK) == APB_OP_STATE_ID) ? 0 : -1;
+}
+
+/**
+ * spi2apb_operation_query - SPI2APB last operation state query
+ *
+ * @spi: device from which data will be read
+ * @state: last operation state [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_operation_query(struct spi_device *spi, int32_t *state)
+{
+    int ret = 0;
+    mutex_lock(&spi2apb_lock);
+    ret = _spi2apb_operation_query(spi, state);
+    mutex_unlock(&spi2apb_lock);
+    return ret;
+}
+
+/**
+ * spi2apb_state_query - SPI2APB system state query
+ *
+ * @spi: spi device
+ * @state: system state [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_state_query(struct spi_device *spi, int32_t *state)
+{
+    int ret = 0;
+    int32_t query_cmd = APB_CMD_QUERY_REG2;
+    struct spi_transfer query_cmd_packet = {
+        .tx_buf = &query_cmd,
+        .len    = sizeof(query_cmd),
+    };
+    struct spi_transfer state_packet = {
+        .rx_buf = state,
+        .len    = sizeof(*state),
+    };
+    struct spi_message  m;
+
+    mutex_lock(&spi2apb_lock);
+    spi_message_init(&m);
+    spi_message_add_tail(&query_cmd_packet, &m);
+    spi_message_add_tail(&state_packet, &m);
+    ret = spi_sync(spi, &m);
+    mutex_unlock(&spi2apb_lock);
+    return ret;
+}
+
+/**
+ * spi2apb_interrupt_request - SPI2APB request a dsp interrupt
+ *
+ * @spi: spi device
+ * @interrupt_num: interrupt identification
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_interrupt_request(struct spi_device *spi,
+        int32_t interrupt_num)
+{
+    int ret = 0;
+    int32_t write_reg1_cmd = APB_CMD_WRITE_REG1;
+    struct spi_transfer write_reg1_cmd_packet = {
+        .tx_buf = &write_reg1_cmd,
+        .len    = sizeof(write_reg1_cmd),
+    };
+    struct spi_transfer reg1_packet = {
+        .tx_buf = &interrupt_num,
+        .len    = sizeof(interrupt_num),
+    };
+    struct spi_message  m;
+
+    mutex_lock(&spi2apb_lock);
+    spi_message_init(&m);
+    spi_message_add_tail(&write_reg1_cmd_packet, &m);
+    spi_message_add_tail(&reg1_packet, &m);
+    ret = spi_sync(spi, &m);
+    mutex_unlock(&spi2apb_lock);
+    return 0;
+}
+
+/**
+ * _spi2apb_safe_write - SPI2APB synchronous write with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+static int _spi2apb_safe_write(struct spi_device *spi,
+        int32_t addr, const int32_t *data, size_t data_len)
+{
+    int32_t state = 0;
+    int32_t try = 0;
+
+    do {
+        int ret = 0;
+        mutex_lock(&spi2apb_lock);
+        _spi2apb_write(spi, addr, data, data_len);
+        ret = _spi2apb_operation_query(spi, &state);
+        mutex_unlock(&spi2apb_lock);
+        if (ret != 0) {
+            return -1;
+        } else if ((state & APB_OP_STATE_MASK) == 0) {
+            break;
+        }
+
+        if (try++ == APB_SAFE_OPERATION_TRY_MAX)
+            break;
+        udelay(APB_SAFE_OPERATION_TRY_DELAY_US);
+    } while (1);
+
+    return (state & APB_OP_STATE_MASK);
+}
+
+/**
+ * spi2apb_safe_write - SPI2APB synchronous write with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_write(struct spi_device *spi,
+        int32_t addr, const int32_t *data, size_t data_len)
+{
+    int ret = 0;
+    while (data_len > 0) {
+        size_t slen = MIN(data_len, APB_MAX_OP_BYTES);
+
+        ret = _spi2apb_safe_write(spi, addr, data, slen);
+        if (ret)
+            break;
+
+        data_len = data_len - slen;
+        data = (int32_t*)((int8_t*)data + slen);
+        addr += slen;
+    }
+    return ret;
+}
+
+/**
+ * spi2apb_safe_w32 - SPI2APB synchronous 32-bit write with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_w32(struct spi_device *spi,
+        int32_t addr, int32_t data)
+{
+    return _spi2apb_safe_write(spi, addr, &data, 4);
+}
+
+/**
+ * _spi2apb_safe_read - SPI2APB synchronous read with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer [out]
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+static int _spi2apb_safe_read(struct spi_device *spi,
+        int32_t addr, int32_t *data, size_t data_len)
+{
+    int32_t state = 0;
+    int32_t try = 0;
+
+    do {
+        int ret = 0;
+        mutex_lock(&spi2apb_lock);
+        _spi2apb_read(spi, addr, data, data_len);
+        ret = _spi2apb_operation_query(spi, &state);
+        mutex_unlock(&spi2apb_lock);
+        if (ret != 0) {
+            return -1;
+        } else if ((state & APB_OP_STATE_MASK) == 0) {
+            break;
+        }
+
+        if (try++ == APB_SAFE_OPERATION_TRY_MAX)
+            break;
+        udelay(APB_SAFE_OPERATION_TRY_DELAY_US);
+    } while (1);
+
+    return (state & APB_OP_STATE_MASK);
+}
+
+/**
+ * spi2apb_safe_read - SPI2APB synchronous read with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer [out]
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_read(struct spi_device *spi,
+        int32_t addr, int32_t *data, size_t data_len)
+{
+    int ret = 0;
+    while (data_len > 0) {
+        size_t slen = MIN(data_len, APB_MAX_OP_BYTES);
+
+        ret = _spi2apb_safe_read(spi, addr, data, slen);
+        if (ret)
+            break;
+
+        data_len = data_len - slen;
+        data = (int32_t*)((int8_t*)data + slen);
+        addr += slen;
+    }
+    return ret;
+}
+
+/**
+ * spi2apb_safe_r32 - SPI2APB synchronous 32-bit read with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data buffer [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_r32(struct spi_device *spi,
+        int32_t addr, int32_t *data)
+{
+    return _spi2apb_safe_read(spi, addr, data, 4);
+}
diff --git a/drivers/media/platform/preisp_driver/spi2apb.h b/drivers/media/platform/preisp_driver/spi2apb.h
new file mode 100644
index 0000000..bac37d10
--- /dev/null
+++ b/drivers/media/platform/preisp_driver/spi2apb.h
@@ -0,0 +1,196 @@
+/*
+ * Copyright (C) Fuzhou Rockchip Electronics Co.Ltd
+ * Author: Tusson <dusong@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __RK_PREISP_SPI2APB_H__
+#define __RK_PREISP_SPI2APB_H__
+
+#include <linux/spi/spi.h>
+
+#define APB_CMD_WRITE                   0x00000011
+#define APB_CMD_WRITE_REG0              0X00010011
+#define APB_CMD_WRITE_REG1              0X00020011
+#define APB_CMD_READ                    0x00000077
+#define APB_CMD_READ_BEGIN              0x000000AA
+#define APB_CMD_QUERY                   0x000000FF
+#define APB_CMD_QUERY_REG2              0x000001FF
+
+#define APB_OP_STATE_ID_MASK           (0xffff0000)
+#define APB_OP_STATE_ID                (0X16080000)
+
+#define APB_OP_STATE_MASK              (0x0000ffff)
+#define APB_OP_STATE_WRITE_ERROR       (0x01 << 0)
+#define APB_OP_STATE_WRITE_OVERFLOW    (0x01 << 1)
+#define APB_OP_STATE_WRITE_UNFINISHED  (0x01 << 2)
+#define APB_OP_STATE_READ_ERROR        (0x01 << 8)
+#define APB_OP_STATE_READ_UNDERFLOW    (0x01 << 9)
+#define APB_OP_STATE_PRE_READ_ERROR    (0x01 << 10)
+
+#define APB_MAX_OP_BYTES             60000
+
+#ifndef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+/**
+ * spi2apb_switch_to_msb - SPI2APB set Fist bit mode to MSB
+ *
+ * @spi: spi device
+ * Context: can sleep
+ *
+ */
+void spi2apb_switch_to_msb(struct spi_device *spi);
+
+/**
+ * spi2apb_write - SPI2APB synchronous write
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_write(struct spi_device *spi, int32_t addr,
+        const int32_t *data, size_t data_len);
+
+/**
+ * spi2apb_w32 - SPI2APB synchronous 32-bit write
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_w32(struct spi_device *spi,
+        int32_t addr, int32_t data);
+
+/**
+ * spi2apb_read - SPI2APB synchronous read
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer [out]
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_read(struct spi_device *spi, int32_t addr,
+        int32_t *data, size_t data_len);
+
+/**
+ * spi2apb_r32 - SPI2APB synchronous 32-bit read
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data buffer [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_r32(struct spi_device *spi, int32_t addr, int32_t *data);
+
+/**
+ * spi2apb_operation_query - SPI2APB last operation state query
+ *
+ * @spi: spi device
+ * @state: last operation state [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_operation_query(struct spi_device *spi, int32_t *state);
+
+/**
+ * spi2apb_state_query - SPI2APB system state query
+ *
+ * @spi: spi device
+ * @state: system state [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_state_query(struct spi_device *spi, int32_t *state);
+
+/**
+ * spi2apb_interrupt_request - SPI2APB request a dsp interrupt
+ *
+ * @spi: spi device
+ * @interrupt_num: interrupt identification
+ * Context: can sleep
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int spi2apb_interrupt_request(struct spi_device *spi,
+        int32_t interrupt_num);
+
+
+#define APB_SAFE_OPERATION_TRY_MAX 3
+#define APB_SAFE_OPERATION_TRY_DELAY_US 10
+
+/**
+ * spi2apb_safe_write - SPI2APB synchronous write with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_write(struct spi_device *spi,
+        int32_t addr, const int32_t *data, size_t data_len);
+
+/**
+ * spi2apb_safe_w32 - SPI2APB synchronous 32-bit write with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_w32(struct spi_device *spi, int32_t addr, int32_t data);
+
+/**
+ * spi2apb_safe_read - SPI2APB synchronous read with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: data buffer [out]
+ * @data_len: data buffer size, in bytes
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_read(struct spi_device *spi,
+        int32_t addr, int32_t *data, size_t data_len);
+
+/**
+ * spi2apb_safe_r32 - SPI2APB synchronous 32-bit read with state check
+ *
+ * @spi: spi device
+ * @addr: apb resource address
+ * @data: 32-bit data buffer [out]
+ * Context: can sleep
+ *
+ * It returns zero on success, else operation state code.
+ */
+int spi2apb_safe_r32(struct spi_device *spi, int32_t addr, int32_t *data);
+
+#endif
diff --git a/drivers/media/platform/rk-isp11/Makefile b/drivers/media/platform/rk-isp11/Makefile
index 402117b..02c3d6d 100644
--- a/drivers/media/platform/rk-isp11/Makefile
+++ b/drivers/media/platform/rk-isp11/Makefile
@@ -1,3 +1,3 @@
 
 obj-$(CONFIG_VIDEO_RK_CIF_ISP11) += video_cif_isp11.o
-video_cif_isp11-objs += cif_isp11.o cif_isp11_img_src.o cif_isp11_img_src_v4l2-subdev.o cif_isp11_isp.o cif_isp11_pltfrm.o cif_isp11_rv1108.o cif_isp11_v4l2.o
+video_cif_isp11-objs += cif_isp11.o cif_isp11_img_src.o cif_isp11_img_src_v4l2-subdev.o cif_isp11_img_src_spi-subdev.o cif_isp11_isp.o cif_isp11_pltfrm.o cif_isp11_rv1108.o cif_isp11_v4l2.o
diff --git a/drivers/media/platform/rk-isp11/cif_isp11.c b/drivers/media/platform/rk-isp11/cif_isp11.c
index 1798f87..cfaa897 100644
--- a/drivers/media/platform/rk-isp11/cif_isp11.c
+++ b/drivers/media/platform/rk-isp11/cif_isp11.c
@@ -1174,6 +1174,12 @@ static int cif_isp11_img_src_select_strm_fmt(
 		if (IS_ERR_VALUE(cif_isp11_img_src_enum_strm_fmts(dev->img_src,
 			index, &strm_fmt_desc)))
 			break;
+		cif_isp11_pltfrm_pr_info(
+			dev->dev,
+			"----------requesting format %s %dx%d\n",
+			cif_isp11_pix_fmt_string(strm_fmt_desc.pix_fmt),
+			strm_fmt_desc.min_frmsize.width,
+			strm_fmt_desc.min_frmsize.height);
 		if (!strm_fmt_desc.discrete_frmsize) {
 			if (strm_fmt_desc.min_frmsize.width >= target_width)
 				img_src_width = strm_fmt_desc.min_frmsize.width;
@@ -1268,7 +1274,7 @@ static int cif_isp11_img_src_select_strm_fmt(
 		goto err;
 	}
 
-	cif_isp11_pltfrm_pr_dbg(
+	cif_isp11_pltfrm_pr_info(
 		dev->dev,
 		"requesting format %s %dx%d(%d,%d,%d,%d)@%d/%dfps from %s\n",
 		cif_isp11_pix_fmt_string(request_strm_fmt.frm_fmt.pix_fmt),
@@ -6188,7 +6194,7 @@ struct cif_isp11_device *cif_isp11_create(
 	CIF_ISP11_PLTFRM_DEVICE pdev,
 	void (*sof_event)(struct cif_isp11_device *dev, __u32 frame_sequence),
 	void (*requeue_bufs)(struct cif_isp11_device *dev,
-					enum cif_isp11_stream_id stream_id),
+	enum cif_isp11_stream_id stream_id),
 	struct pltfrm_soc_cfg *soc_cfg)
 {
 	int ret;
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_img_src.c b/drivers/media/platform/rk-isp11/cif_isp11_img_src.c
index 5b8978b..2cd3625 100644
--- a/drivers/media/platform/rk-isp11/cif_isp11_img_src.c
+++ b/drivers/media/platform/rk-isp11/cif_isp11_img_src.c
@@ -43,7 +43,7 @@ struct cif_isp11_img_src *cif_isp11_img_src_to_img_src(
 
 	img_src->ops = NULL;
 	for (i = 0; i < ARRAY_SIZE(cif_isp11_img_src_ops); i++) {
-		if (!strcmp(device_type, cif_isp11_img_src_ops->device_type)) {
+		if (!strcmp(device_type, cif_isp11_img_src_ops[i].device_type)) {
 			img_src->ops = &cif_isp11_img_src_ops[i].ops;
 			break;
 		}
@@ -160,6 +160,7 @@ long cif_isp11_img_src_ioctl(
 		cif_isp11_pltfrm_pr_err(NULL, "img_src is NULL\n");
 		return -EINVAL;
 	}
+
 	return img_src->ops->ioctl(img_src->img_src, cmd, arg);
 }
 
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_img_src_ops.h b/drivers/media/platform/rk-isp11/cif_isp11_img_src_ops.h
index 1976f67..a705096 100644
--- a/drivers/media/platform/rk-isp11/cif_isp11_img_src_ops.h
+++ b/drivers/media/platform/rk-isp11/cif_isp11_img_src_ops.h
@@ -18,6 +18,7 @@
 #define _CIF_ISP11_IMG_SRC_OPS_H
 #include <linux/platform_data/rk_isp11_platform.h>
 #include "cif_isp11_img_src_v4l2-subdev.h"
+#include "cif_isp11_img_src_spi-subdev.h"
 
 struct cif_isp11_img_src_ops {
 	void * (*to_img_src)(
@@ -94,6 +95,34 @@ const struct {
 				cif_isp11_img_src_v4l2_subdev_g_frame_interval,
 		}
 	},
+	{
+		.device_type = CIF_ISP11_IMG_SRC_SPI_SUBDEV,
+		.ops = {
+			.to_img_src =
+				cif_isp11_img_src_spi_subdev_to_img_src,
+			.s_streaming =
+				cif_isp11_img_src_spi_subdev_s_streaming,
+			.s_power =
+				cif_isp11_img_src_spi_subdev_s_power,
+			.enum_strm_fmts =
+				cif_isp11_img_src_spi_subdev_enum_strm_fmts,
+			.s_strm_fmt =
+				cif_isp11_img_src_spi_subdev_s_strm_fmt,
+			.g_ctrl =
+				cif_isp11_img_src_spi_subdev_g_ctrl,
+			.g_name =
+				cif_isp11_img_src_spi_subdev_g_name,
+			.s_ctrl =
+				cif_isp11_img_src_spi_subdev_s_ctrl,
+			.s_ext_ctrls =
+				cif_isp11_img_src_spi_subdev_s_ext_ctrls,
+			.ioctl =
+				cif_isp11_img_src_spi_subdev_ioctl,
+			.s_frame_interval =
+				cif_isp11_img_src_spi_subdev_s_frame_interval,
+			.g_frame_interval =
+				cif_isp11_img_src_spi_subdev_g_frame_interval,
+		}
+	},
 };
-
 #endif
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.c b/drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.c
new file mode 100644
index 0000000..9d38419
--- /dev/null
+++ b/drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.c
@@ -0,0 +1,255 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#include <linux/kernel.h>
+#include <linux/i2c.h>
+#include <media/v4l2-subdev.h>
+#include <media/v4l2-common.h>
+#include <media/v4l2-ioctl.h>
+#include "cif_isp11.h"
+#include <linux/platform_data/rk_isp11_platform.h>
+#include <media/v4l2-controls_rockchip.h>
+#include <linux/slab.h>
+#include <linux/spi/spi.h>
+#include "cif_isp11_img_src_spi-subdev.h"
+
+/* ===================== */
+/* Image Source */
+/* ===================== */
+void *cif_isp11_img_src_spi_subdev_to_img_src(
+	struct device *dev,
+	struct pltfrm_soc_cfg *soc_cfg)
+{
+	int ret = 0;
+	struct spi_device *spi_client;
+	struct spi_rk_preisp_data *subdev;
+
+	spi_client = to_spi_device(dev);
+	if (IS_ERR_OR_NULL(spi_client)) {
+		cif_isp11_pltfrm_pr_err(dev,
+			"not an spi device\n");
+		ret = -EINVAL;
+		goto err;
+	}
+
+	subdev = spi_get_drvdata(spi_client);
+	if (IS_ERR_OR_NULL(subdev)) {
+		cif_isp11_pltfrm_pr_err(dev,
+			"not an spi subdev\n");
+		goto err;
+	}
+
+	cif_isp11_pltfrm_pr_info(NULL, "subdev name: %s\n", subdev->misc.name);
+
+	return (void *)subdev;
+err:
+	cif_isp11_pltfrm_pr_err(NULL, "failed with error %d\n", ret);
+	return ERR_PTR(ret);
+}
+
+int cif_isp11_img_src_spi_subdev_s_streaming(
+	void *img_src,
+	bool enable)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cfg_para.cmd = CIF_PREISP_STREAM;
+	cfg_para.cfg_para = (void *)&enable;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_s_power(
+	void *img_src,
+	bool on)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_POWER;
+	cfg_para.cfg_para = (void *)&on;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_enum_strm_fmts(
+	void *img_src,
+	u32 index,
+	struct cif_isp11_strm_fmt_desc *strm_fmt_desc)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_ENUM_STRM_FMTS;
+	cfg_para.id = index;
+	cfg_para.cfg_para = (void *)strm_fmt_desc;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_s_strm_fmt(
+	void *img_src,
+	struct cif_isp11_strm_fmt *strm_fmt)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_STRM_FMT_DESC;
+	cfg_para.cfg_para = (void *)strm_fmt;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_s_frame_interval(
+	void *img_src,
+	struct cif_isp11_frm_intrvl *frm_intrvl)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_S_FRMAE_INTERVAL;
+	cfg_para.cfg_para = (void *)frm_intrvl;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_g_frame_interval(
+	void *img_src,
+	struct cif_isp11_frm_intrvl *frm_intrvl)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_G_FRMAE_INTERVAL;
+	cfg_para.cfg_para = (void *)frm_intrvl;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_g_ctrl(
+	void *img_src,
+	int id,
+	int *val)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_SUBDEV_G_CTRL;
+	cfg_para.id = id;
+	cfg_para.cfg_para = (void *)val;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+int cif_isp11_img_src_spi_subdev_s_ctrl(
+	void *img_src,
+	int id,
+	int val)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_SUBDEV_S_CTRL;
+	cfg_para.id = id;
+	cfg_para.cfg_para = (void *)&val;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+const char *cif_isp11_img_src_spi_subdev_g_name(
+	void *img_src)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+
+	return (char *)subdev->misc.name;
+}
+
+int cif_isp11_img_src_spi_subdev_s_ext_ctrls(
+	void *img_src,
+	struct cif_isp11_img_src_ext_ctrl *ctrl)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_S_EXT_CTRL;
+	cfg_para.cfg_para = (void *)ctrl;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
+
+long cif_isp11_img_src_spi_subdev_ioctl(
+	void *img_src,
+	unsigned int cmd,
+	void *arg)
+{
+	struct spi_rk_preisp_data *subdev = img_src;
+	struct cif_preisp_cfg_para cfg_para;
+	int ret = 0;
+
+	cif_isp11_pltfrm_pr_dbg(NULL, "enter %s: xuhf\n", __FUNCTION__);
+
+	cfg_para.cmd = CIF_PREISP_IOCTL;
+	cfg_para.id = cmd;
+	cfg_para.cfg_para = (void *)arg;
+
+	ret = subdev->cif_preisp_cfg(subdev->dev, &cfg_para);
+
+	return ret;
+}
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.h b/drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.h
new file mode 100644
index 0000000..36046aa
--- /dev/null
+++ b/drivers/media/platform/rk-isp11/cif_isp11_img_src_spi-subdev.h
@@ -0,0 +1,122 @@
+/*
+**************************************************************************
+ * Rockchip driver for CIF ISP 1.1
+ * (Based on Intel driver for sofiaxxx)
+ *
+ * Copyright (C) 2015 Intel Mobile Communications GmbH
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd.
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+**************************************************************************
+ */
+
+#ifndef _CIF_ISP11_IMG_SRC_SPI_SUBDEV_H
+#define _CIF_ISP11_IMG_SRC_SPI_SUBDEV_H
+
+#include <linux/miscdevice.h>
+#include <linux/wakelock.h>
+#include "../preisp_driver/spi-rkpreisp.h"
+
+#if 0
+typedef struct {
+    struct mutex mutex;
+    struct list_head list;
+} preisp_client_list_s;
+
+struct cif_preisp_img_src;
+
+typedef struct {
+    struct miscdevice misc;
+    struct spi_device *spi;
+    struct device *dev;
+    preisp_client_list_s clients;
+    int reset_gpio;
+    int reset_active;
+    int irq_gpio;
+    int irq;
+    int sleepst_gpio;
+    int sleepst_irq;
+    int wakeup_gpio;
+    int wakeup_active;
+    struct clk *mclk;
+    struct regmap *grf_base;
+    atomic_t power_on_cnt;
+    atomic_t wake_sleep_cnt;
+    struct mutex send_msg_lock;
+    struct mutex power_lock;
+    struct wake_lock resume_wake_lock;
+    uint32_t max_speed_hz;
+    uint32_t min_speed_hz;
+    uint32_t fw_nowait_mode;
+    struct regulator *pdvdd_regu;
+    struct regulator *vdd_core_regu;
+    int log_level;
+    int sleep_state_flag;
+    bool is_resume_processing;
+
+    struct cif_preisp_img_src *img_src;   
+    struct cif_preisp_img_src *img_src_array[10];
+unsigned int img_src_cnt;
+
+} spi_subdev;
+#else
+
+#endif
+
+#define CIF_ISP11_IMG_SRC_SPI_SUBDEV  "spi_rk_preisp"
+
+void *cif_isp11_img_src_spi_subdev_to_img_src(
+	struct device *dev,
+	struct pltfrm_soc_cfg *soc_cfg);
+
+int cif_isp11_img_src_spi_subdev_s_streaming(
+	void *img_src,
+	bool enable);
+
+int cif_isp11_img_src_spi_subdev_s_power(
+	void *img_src,
+	bool on);
+
+int cif_isp11_img_src_spi_subdev_enum_strm_fmts(
+	void *img_src,
+	u32 index,
+	struct cif_isp11_strm_fmt_desc *strm_fmt_desc);
+
+int cif_isp11_img_src_spi_subdev_s_strm_fmt(
+	void *img_src,
+	struct cif_isp11_strm_fmt *strm_fmt);
+
+int cif_isp11_img_src_spi_subdev_g_ctrl(
+	void *img_src,
+	int id,
+	int *val);
+
+int cif_isp11_img_src_spi_subdev_s_ctrl(
+	void *img_src,
+	int id,
+	int val);
+
+const char *cif_isp11_img_src_spi_subdev_g_name(
+	void *img_src);
+
+int cif_isp11_img_src_spi_subdev_s_ext_ctrls(
+	void *img_src,
+	struct cif_isp11_img_src_ext_ctrl *ctrl);
+
+long cif_isp11_img_src_spi_subdev_ioctl(
+	void *img_src,
+	unsigned int cmd,
+	void *arg);
+
+int cif_isp11_img_src_spi_subdev_s_frame_interval(
+	void *img_src,
+	struct cif_isp11_frm_intrvl *frm_intrvl);
+
+int cif_isp11_img_src_spi_subdev_g_frame_interval(
+	void *img_src,
+	struct cif_isp11_frm_intrvl *frm_intrvl);
+#endif
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_pltfrm.c b/drivers/media/platform/rk-isp11/cif_isp11_pltfrm.c
index ebb1c25..0874f1c 100644
--- a/drivers/media/platform/rk-isp11/cif_isp11_pltfrm.c
+++ b/drivers/media/platform/rk-isp11/cif_isp11_pltfrm.c
@@ -20,6 +20,7 @@
 
 #include <linux/of.h>
 #include <linux/platform_device.h>
+#include <linux/of_platform.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/i2c.h>
@@ -1354,7 +1355,9 @@ int cif_isp11_pltfrm_get_img_src_device(
 {
 	struct device_node *node = NULL;
 	struct device_node *camera_list_node = NULL;
-	struct i2c_client *client = NULL;
+	struct i2c_client *i2c_client = NULL;
+	struct spi_device *spi_client = NULL;
+	struct device *client_dev;
 	int ret = 0;
 	int index, size = 0;
 	const __be32 *phandle;
@@ -1378,6 +1381,9 @@ int cif_isp11_pltfrm_get_img_src_device(
 	}
 
 	for (index = 0; index < size/sizeof(*phandle); index++) {
+		i2c_client = NULL;
+		spi_client = NULL;
+
 		camera_list_node = of_parse_phandle(node,
 			"rockchip,camera-modules-attached", index);
 		of_node_put(node);
@@ -1391,17 +1397,37 @@ int cif_isp11_pltfrm_get_img_src_device(
 		}
 
 		if (!strcmp(camera_list_node->type,
-					"v4l2-i2c-subdev")) {
-			client = of_find_i2c_device_by_node(
+			    "v4l2-i2c-subdev")) {
+			i2c_client = of_find_i2c_device_by_node(
 				camera_list_node);
 			of_node_put(camera_list_node);
-			if (IS_ERR_OR_NULL(client)) {
+			if (IS_ERR_OR_NULL(i2c_client)) {
 				cif_isp11_pltfrm_pr_err(dev,
 					"could not get camera i2c client,"
 					" maybe not yet created, deferring"
 					" device probing...\n");
 				continue;
 			}
+			client_dev = &i2c_client->dev;
+		} else if (!IS_ERR_OR_NULL(camera_list_node =
+			   of_get_next_child(camera_list_node, NULL))) {
+			cif_isp11_pltfrm_pr_info(dev,
+				"device of type %s\n", camera_list_node->type);
+			if (!strcmp(camera_list_node->type,
+				    "spi_rk_preisp")) {
+				spi_client = of_find_spi_by_node(
+					 camera_list_node);
+				of_node_put(camera_list_node);
+				if (IS_ERR_OR_NULL(spi_client)) {
+					cif_isp11_pltfrm_pr_err(dev,
+						"could not get camera spi_rk_preisp,"
+						" maybe not yet created, deferring"
+						" device probing...\n");
+					continue;
+				}
+				cif_isp11_pltfrm_pr_info(dev, "spi_dev irq %d\n", spi_client->irq);
+				client_dev = &spi_client->dev;
+			}
 		} else {
 			cif_isp11_pltfrm_pr_dbg(dev,
 				"device of type %s not supported\n",
@@ -1412,7 +1438,7 @@ int cif_isp11_pltfrm_get_img_src_device(
 
 		img_src_array[num_cameras] =
 			cif_isp11_img_src_to_img_src(
-				&client->dev,
+				client_dev,
 				cif_isp11_dev->soc_cfg);
 		if (!IS_ERR_OR_NULL(img_src_array[num_cameras])) {
 			cif_isp11_pltfrm_pr_info(dev,
@@ -1434,8 +1460,10 @@ int cif_isp11_pltfrm_get_img_src_device(
 	return num_cameras;
 err:
 	dev_err(dev, "failed with error %d\n", ret);
-	if (!IS_ERR_OR_NULL(client))
-		put_device(&client->dev);
+	if (!IS_ERR_OR_NULL(i2c_client))
+		put_device(&i2c_client->dev);
+	if (!IS_ERR_OR_NULL(spi_client))
+		put_device(&spi_client->dev);
 	if (!IS_ERR_OR_NULL(camera_list_node))
 		of_node_put(camera_list_node);
 	return ret;
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_rv1108.c b/drivers/media/platform/rk-isp11/cif_isp11_rv1108.c
index 789c697..97b9bf0 100644
--- a/drivers/media/platform/rk-isp11/cif_isp11_rv1108.c
+++ b/drivers/media/platform/rk-isp11/cif_isp11_rv1108.c
@@ -115,7 +115,7 @@ static struct mipi_dphy_hsfreqrange mipi_dphy_hsfreq_range[] = {
 	{800, 1000, 0x0a}
 };
 
-static struct cif_isp11_rv1108 *rv1108;
+static struct cif_isp11_rv1108 *rv1108 = NULL;
 
 static int mipi_dphy_cfg (struct pltfrm_cam_mipi_config *para)
 {
@@ -260,7 +260,15 @@ static int soc_isp_clk_cfg(int *data_rate)
 {
 	int isp_clk[] = {396, 480, 594};
 	int tmp, i;
-	struct cif_isp11_clk_rst_rv1108 *clk_rst = &rv1108->clk_rst;
+	struct cif_isp11_clk_rst_rv1108 *clk_rst;
+
+	
+	pr_warn("prv1108: %p\n", rv1108);
+	
+	if (IS_ERR_OR_NULL(rv1108))
+		return 0;
+
+	clk_rst = &rv1108->clk_rst;
 
 	tmp = (*data_rate * 10) >> 6;
 	for (i = 0; i < ARRAY_SIZE(isp_clk); i++)
diff --git a/drivers/media/platform/rk-isp11/cif_isp11_v4l2.c b/drivers/media/platform/rk-isp11/cif_isp11_v4l2.c
index 0d1de00..c861ab7 100644
--- a/drivers/media/platform/rk-isp11/cif_isp11_v4l2.c
+++ b/drivers/media/platform/rk-isp11/cif_isp11_v4l2.c
@@ -460,6 +460,13 @@ static int cif_isp11_v4l2_register_imgsrc_subdev(
 
 	for (i = 0; i < dev->img_src_cnt; i++) {
 		if (dev->img_src_array[i] != NULL) {
+			if (!strcmp(cif_isp11_img_src_g_name(dev->img_src_array[i]),
+			    "rk_preisp")) {
+				cif_isp11_pltfrm_pr_warn(dev->dev,
+					"%s is not v4l2 subdev, don't register\n",
+					cif_isp11_img_src_g_name(dev->img_src_array[i]));
+				continue;
+			}
 			sd = (struct v4l2_subdev *)
 				cif_isp11_img_src_g_img_src(
 					dev->img_src_array[i]);
@@ -1721,8 +1728,6 @@ static int cif_isp11_v4l2_drv_probe(struct platform_device *pdev)
 	struct cif_isp11_v4l2_device *cif_isp11_v4l2_dev;
 	int ret;
 
-	cif_isp11_pltfrm_pr_info(NULL, "probing...\n");
-
 	cif_isp11_v4l2_dev = devm_kzalloc(
 				&pdev->dev,
 				sizeof(struct cif_isp11_v4l2_device),
diff --git a/drivers/of/base.c b/drivers/of/base.c
index fb6704e..856a196 100644
--- a/drivers/of/base.c
+++ b/drivers/of/base.c
@@ -1363,8 +1363,7 @@ struct device_node *of_parse_phandle(const struct device_node *np,
 	if (index < 0)
 		return NULL;
 
-	if (__of_parse_phandle_with_args(np, phandle_name, NULL, 0,
-					 index, &args))
+	if (__of_parse_phandle_with_args(np, phandle_name, NULL, 0, index, &args))
 		return NULL;
 
 	return args.np;
diff --git a/drivers/of/platform.c b/drivers/of/platform.c
index 8b35f58..250fc5b 100644
--- a/drivers/of/platform.c
+++ b/drivers/of/platform.c
@@ -22,6 +22,7 @@
 #include <linux/of_irq.h>
 #include <linux/of_platform.h>
 #include <linux/platform_device.h>
+#include <linux/spi/spi.h>
 
 const struct of_device_id of_default_bus_match_table[] = {
 	{ .compatible = "simple-bus", },
@@ -52,6 +53,21 @@ struct platform_device *of_find_device_by_node(struct device_node *np)
 }
 EXPORT_SYMBOL(of_find_device_by_node);
 
+/**
+ * of_find_spi_by_node - Find the spi_device associated with a node
+ * @np: Pointer to device tree node
+ *
+ * Returns spi_device pointer, or NULL if not found
+ */
+struct spi_device *of_find_spi_by_node(struct device_node *np)
+{
+	struct device *dev;
+
+	dev = bus_find_device(&spi_bus_type, NULL, np, of_dev_node_match);
+	return dev ? to_spi_device(dev) : NULL;
+}
+EXPORT_SYMBOL(of_find_spi_by_node);
+
 #if defined(CONFIG_PPC_DCR)
 #include <asm/dcr.h>
 #endif
diff --git a/include/linux/of_platform.h b/include/linux/of_platform.h
index 30ebd76..b8d2f89 100644
--- a/include/linux/of_platform.h
+++ b/include/linux/of_platform.h
@@ -12,6 +12,7 @@
  */
 
 #include <linux/device.h>
+#include <linux/spi/spi.h>
 #include <linux/mod_devicetable.h>
 
 #ifdef CONFIG_OF_DEVICE
@@ -81,6 +82,7 @@ extern struct platform_device *of_device_alloc(struct device_node *np,
 					 const char *bus_id,
 					 struct device *parent);
 extern struct platform_device *of_find_device_by_node(struct device_node *np);
+extern struct spi_device *of_find_spi_by_node(struct device_node *np);
 
 #ifdef CONFIG_OF_ADDRESS /* device reg helpers depend on OF_ADDRESS */
 /* Platform devices and busses creation */
-- 
1.9.1

