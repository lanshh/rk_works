From a81511f6545bf7b55d377d5b5448ea6a98f82ad1 Mon Sep 17 00:00:00 2001
From: Zhaoyifeng <zyf@rock-chips.com>
Date: Thu, 2 Mar 2017 12:09:22 +0800
Subject: [PATCH] block: partitions: add new rk partition

Change-Id: Ieede7ddb4b970e0ab969c1cbf2781b4958347625
Signed-off-by: Zhaoyifeng <zyf@rock-chips.com>
Signed-off-by: Sugar Zhang <sugar.zhang@rock-chips.com>
---
 arch/arm/boot/dts/rv1108-ipc-v10.dts  |  31 +++++++--
 arch/arm/configs/rv1108_ipc_defconfig |   3 +-
 block/partitions/rk.c                 | 122 ++++++++++++++++++++++++++++++----
 block/partitions/rk.h                 |  51 ++++++++++++++
 4 files changed, 186 insertions(+), 21 deletions(-)
 mode change 100755 => 100644 block/partitions/rk.c
 mode change 100755 => 100644 block/partitions/rk.h

diff --git a/arch/arm/boot/dts/rv1108-ipc-v10.dts b/arch/arm/boot/dts/rv1108-ipc-v10.dts
index 39ccdbe..8af7a80 100644
--- a/arch/arm/boot/dts/rv1108-ipc-v10.dts
+++ b/arch/arm/boot/dts/rv1108-ipc-v10.dts
@@ -82,7 +82,8 @@
 	};
 
 	chosen {
-		bootargs = "user_debug=31 rockchip_jtag noinitrd root=/dev/mtdblock3 rootfstype=squashfs";
+		bootargs = "user_debug=31 rockchip_jtag noinitrd root=/dev/mmcblk0p4 rootfstype=squashfs";
+		/* bootargs = "user_debug=31 rockchip_jtag noinitrd root=/dev/mtdblock3 rootfstype=squashfs"; */
 	};
 
 	ion {
@@ -107,6 +108,28 @@
 		};
 	};
 
+	regulators {
+		compatible = "simple-bus";
+		#address-cells = <1>;
+		#size-cells = <0>;
+
+		vccio_flash_1v8_reg: regulator@0 {
+			compatible = "regulator-fixed";
+			regulator-name = "vccio_flash_1v8";
+			regulator-min-microvolt = <1800000>;
+			regulator-max-microvolt = <1800000>;
+			regulator-always-on;
+		};
+
+		vccio_flash_3v3_reg: regulator@1 {
+			compatible = "regulator-fixed";
+			regulator-name = "vccio_flash_3v3";
+			regulator-min-microvolt = <3300000>;
+			regulator-max-microvolt = <3300000>;
+			regulator-always-on;
+		};
+	};
+
 	io-domains {
 		compatible = "rockchip,rv1108-io-voltage-domain";
 		rockchip,grf = <&grf>;
@@ -118,7 +141,7 @@
 		vccio2-supply = <&rk805_ldo2_reg>;
 		vccio3-supply = <&rk805_dcdc4_reg>;
 		vccio5-supply = <&rk805_ldo2_reg>;
-		vccio6-supply = <&rk805_dcdc4_reg>;
+		vccio6-supply = <&vccio_flash_1v8_reg>;
 
 		/* PMU_GRF_IO_VSEL */
 		pmu-supply = <&rk805_dcdc4_reg>;
@@ -456,11 +479,9 @@
 	supports-highspeed;
 	supports-emmc;
 	bootpart-no-access;
-	supports-DDR_MODE;
-	caps2-mmc-hs200;
 	ignore-pm-notify;
 	keep-power-in-suspend;
-	status = "disabled";
+	status = "okay";
 };
 
 &sdmmc {
diff --git a/arch/arm/configs/rv1108_ipc_defconfig b/arch/arm/configs/rv1108_ipc_defconfig
index c74bdb0..0e473ff 100644
--- a/arch/arm/configs/rv1108_ipc_defconfig
+++ b/arch/arm/configs/rv1108_ipc_defconfig
@@ -17,7 +17,6 @@ CONFIG_PROFILING=y
 CONFIG_JUMP_LABEL=y
 CONFIG_MODULES=y
 CONFIG_MODULE_UNLOAD=y
-# CONFIG_LBDAF is not set
 # CONFIG_BLK_DEV_BSG is not set
 CONFIG_PARTITION_ADVANCED=y
 # CONFIG_EFI_PARTITION is not set
@@ -283,6 +282,7 @@ CONFIG_RK_NANDC_NAND=y
 CONFIG_RK_SFC_NOR=y
 CONFIG_RK_SFC_NAND=y
 CONFIG_RK_SFC_NOR_MTD=y
+CONFIG_EXT4_FS=y
 CONFIG_MSDOS_FS=y
 CONFIG_VFAT_FS=y
 CONFIG_TMPFS=y
@@ -312,6 +312,5 @@ CONFIG_CRYPTO_SHA256=y
 CONFIG_CRYPTO_DEV_ROCKCHIP=y
 CONFIG_CRYPTO_DEV_ROCKCHIP_ENCRYPT=y
 CONFIG_CRC_CCITT=y
-CONFIG_CRC16=y
 CONFIG_CRC_ITU_T=y
 CONFIG_LIBCRC32C=y
diff --git a/block/partitions/rk.c b/block/partitions/rk.c
old mode 100755
new mode 100644
index 0a20aba..2b50132
--- a/block/partitions/rk.c
+++ b/block/partitions/rk.c
@@ -291,6 +291,91 @@ static void rkpart_bootmode_fixup(void)
 	saved_command_line = new_command_line;
 }
 
+/*
+ * read_lba(): Read bytes from disk, starting at given LBA
+ * @state
+ * @lba
+ * @buffer
+ * @size_t
+ *
+ * Description: Reads @count bytes from @state->bdev into @buffer.
+ * Returns number of bytes read on success, 0 on error.
+ */
+static size_t read_lba(struct parsed_partitions *state,
+		       u64 lba, u8 *buffer, size_t count)
+{
+	size_t totalreadcount = 0;
+	struct block_device *bdev = state->bdev;
+	sector_t n = lba * (bdev_logical_block_size(bdev) / 512);
+
+	while (count) {
+		int copied = 512;
+		Sector sect;
+		unsigned char *data = read_part_sector(state, n++, &sect);
+
+		if (!data)
+			break;
+		if (copied > count)
+			copied = count;
+		memcpy(buffer, data, copied);
+		put_dev_sector(sect);
+		buffer += copied;
+		totalreadcount += copied;
+		count -= copied;
+	}
+	return totalreadcount;
+}
+
+static int rk_new_part_dectet(sector_t n, struct parsed_partitions *state)
+{
+	int i, part_num = 0;
+	struct rk_part_info *g_part; /* size 2KB */
+	struct rk_part_entey *parts;
+	int size;
+
+	BUILD_BUG_ON_MSG(sizeof(struct rk_part_info) != 4096,
+			 "struct rk_part_info size error");
+
+	size = sizeof(*g_part);
+	g_part = kmalloc(size, GFP_KERNEL | GFP_DMA);
+	if (!g_part)
+		return 0;
+
+	if (read_lba(state, 0, (u8 *)g_part, size) < size) {
+		kfree(g_part);
+		return 0;
+	}
+
+	if (g_part->hdr.ui_fw_tag == RK_PARTITION_TAG) {
+		part_num = g_part->hdr.ui_part_entry_count;
+		parts = g_part->part;
+
+		for (i = 0; i < part_num; i++) {
+			struct partition_meta_info *info;
+			unsigned int label_max;
+
+			if (parts[i].size == SIZE_REMAINING)
+				parts[i].size = n - parts[i].offset;
+
+			info = &state->parts[i + 1].info;
+			put_partition(state, i + 1,
+				      parts[i].offset,
+				      parts[i].size);
+			label_max = min(sizeof(info->volname) - 1,
+					sizeof(parts[i].name));
+			strncpy(info->volname, parts[i].name, label_max);
+			pr_info("%10s: 0x%09llx -- 0x%09llx (%llu MB)\n",
+				parts[i].name,
+				(u64)parts[i].offset * 512,
+				(u64)(parts[i].offset + parts[i].size) * 512,
+				(u64)parts[i].size / 2048);
+		}
+	}
+
+	kfree(g_part);
+	return (part_num > 0);
+}
+
 int rkpart_partition(struct parsed_partitions *state)
 {
 	int num_parts = 0, i;
@@ -300,11 +385,14 @@ int rkpart_partition(struct parsed_partitions *state)
 	if (n < SECTOR_1G)
 		return 0;
 
-        /* ONLY be used by eMMC-disk */
-        if (1 != state->bdev->bd_disk->emmc_disk)
-                return 0;
+	/* ONLY be used by eMMC-disk */
+	if (1 != state->bdev->bd_disk->emmc_disk)
+		return 0;
 
-        /* Fixme: parameter should be coherence with part table */
+	if (rk_new_part_dectet(n, state) == 1)
+		return 1;
+
+	/* Fixme: parameter should be coherence with part table */
 	cmdline = strstr(saved_command_line, "mtdparts=") + 9;
 	cmdline_parsed = 0;
 
@@ -313,16 +401,22 @@ int rkpart_partition(struct parsed_partitions *state)
 		return num_parts;
 
 	for (i = 0; i < num_parts; i++) {
-		put_partition(  state,
-		                i+1,
-                                parts[i].from + FROM_OFFSET,
-                                parts[i].size);
-		strcpy(state->parts[i+1].info.volname, parts[i].name);
-                printk(KERN_INFO "%10s: 0x%09llx -- 0x%09llx (%llu MB)\n", 
-				parts[i].name,
-				(u64)parts[i].from * 512,
-				(u64)(parts[i].from + parts[i].size) * 512,
-				(u64)parts[i].size / 2048);
+		struct partition_meta_info *info;
+		unsigned int label_max;
+
+		info = &state->parts[i + 1].info;
+		put_partition(state,
+			      i + 1,
+			      parts[i].from + FROM_OFFSET,
+			      parts[i].size);
+		label_max = min(sizeof(info->volname) - 1,
+				sizeof(parts[i].name));
+		strncpy(info->volname, parts[i].name, label_max);
+		pr_info("%10s: 0x%09llx -- 0x%09llx (%llu MB)\n",
+			parts[i].name,
+			(u64)parts[i].from * 512,
+			(u64)(parts[i].from + parts[i].size) * 512,
+			(u64)parts[i].size / 2048);
 	}
 
 	rkpart_bootmode_fixup();
diff --git a/block/partitions/rk.h b/block/partitions/rk.h
old mode 100755
new mode 100644
index 25085e7..f681272
--- a/block/partitions/rk.h
+++ b/block/partitions/rk.h
@@ -37,4 +37,55 @@ struct cmdline_rk_partition {
 	int num_parts;
 	struct rk_partition *parts;
 };
+
+#define RK_PARTITION_TAG 0x50464B52
+
+struct data_time {
+	unsigned short year;
+	unsigned char month;
+	unsigned char day;
+	unsigned char hour;
+	unsigned char min;
+	unsigned char sec;
+	unsigned char reserve;
+} __packed;
+
+enum e_partition_type {
+	PART_VENDOR = 1 << 0,
+	PART_IDBLOCK = 1 << 1,
+	PART_KERNEL = 1 << 2,
+	PART_BOOT = 1 << 3,
+	PART_USER = 1 << 31
+};
+
+struct rk_fw_header {
+	unsigned int ui_fw_tag;	/* "RKFP" */
+	struct data_time t_release_data_time;
+	unsigned int ui_fw_ver;
+	unsigned int ui_size;	/* size of sturct,unit of u8 */
+	unsigned int ui_part_entry_offset;	/* unit of sector */
+	unsigned int ui_backup_part_entry_offset;
+	unsigned int ui_part_entry_size;	/* unit of u8 */
+	unsigned int ui_part_entry_count;
+	unsigned int ui_fw_size;	/* unit of u8 */
+	unsigned char reserved[464];
+	unsigned int ui_part_entry_crc;
+	unsigned int ui_header_crc;
+};
+
+struct rk_part_entey {
+	unsigned char name[32];
+	enum e_partition_type em_part_type;
+	unsigned int offset;	/* unit of sector */
+	unsigned int size;	/* unit of sector */
+	unsigned int data_length;	/* unit of u8 */
+	unsigned int part_property;
+	unsigned char reserved[76];
+};
+
+struct rk_part_info {
+	struct rk_fw_header hdr;	/* 0.5KB */
+	struct rk_part_entey part[28];	/* 3.5KB */
+} __packed;
+
 int rkpart_partition(struct parsed_partitions *state);
-- 
1.9.1

