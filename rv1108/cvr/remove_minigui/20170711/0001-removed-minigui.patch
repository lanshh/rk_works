From 48b227459a946c1310fddefa6588850dde6caca5 Mon Sep 17 00:00:00 2001
From: lanshh <lsh@rock-chips.com>
Date: Mon, 10 Jul 2017 12:04:07 +0800
Subject: [PATCH 1/5] removed minigui

Change-Id: I35479f10c5b0c49b21497d4fdd292e55d4054c9b
Signed-off-by: lanshh <lsh@rock-chips.com>
---
 Makefile                 |   11 +
 common.h                 |    2 +-
 menu_commond.h           |    4 +
 noui/camera_ui.c         | 8108 ++++++++++++++++++++++++++++++++++++++++++++++
 noui/camera_ui.h         |   30 +
 noui/camera_ui_def.h     |  329 ++
 noui/camera_ui_res_cn.h  |    6 +
 noui/camera_ui_res_en.h  |   31 +
 noui/camera_ui_res_tw.h  |    6 +
 noui/display_cvr.c       |   34 +
 noui/display_cvr.h       |   20 +
 noui/libvui/fwk_gl_api.h |   96 +
 noui/libvui/fwk_gl_def.h | 3078 ++++++++++++++++++
 noui/libvui/fwk_gl_msg.h |  503 +++
 noui/libvui/fwk_mem.cpp  |  122 +
 noui/libvui/fwk_msg.cpp  |  266 ++
 noui/libvui/msg_api.c    |  119 +
 noui/libvui/vgui_api.c   |  108 +
 noui/libvui/vgui_api.h   |  537 +++
 ueventmonitor/keyboard.c |  327 ++
 ueventmonitor/keyboard.h |   73 +
 videoplay.c              |    4 +
 22 files changed, 13813 insertions(+), 1 deletion(-)
 mode change 100644 => 100755 Makefile
 mode change 100644 => 100755 common.h
 create mode 100644 noui/camera_ui.c
 create mode 100644 noui/camera_ui.h
 create mode 100644 noui/camera_ui_def.h
 create mode 100644 noui/camera_ui_res_cn.h
 create mode 100644 noui/camera_ui_res_en.h
 create mode 100644 noui/camera_ui_res_tw.h
 create mode 100644 noui/display_cvr.c
 create mode 100644 noui/display_cvr.h
 create mode 100644 noui/libvui/fwk_gl_api.h
 create mode 100644 noui/libvui/fwk_gl_def.h
 create mode 100644 noui/libvui/fwk_gl_msg.h
 create mode 100644 noui/libvui/fwk_mem.cpp
 create mode 100644 noui/libvui/fwk_msg.cpp
 create mode 100644 noui/libvui/msg_api.c
 create mode 100644 noui/libvui/vgui_api.c
 create mode 100644 noui/libvui/vgui_api.h
 create mode 100755 ueventmonitor/keyboard.c
 create mode 100755 ueventmonitor/keyboard.h

diff --git a/Makefile b/Makefile
old mode 100644
new mode 100755
index e266c04..e154f51
--- a/Makefile
+++ b/Makefile
@@ -46,9 +46,19 @@ CPPSRCS	 = $(call all-subdir-cpp-files)
 COMPILE_UI_TYPE = CVR
 #COMPILE_UI_TYPE = SDV
 
+COMPILE_NOUI = yes
 UI_RES_DIR =
 DEPENDENT_FILES = ui_resolution.h
 
+ifeq ($(COMPILE_NOUI), yes)
+    INCS += -I../libvui/include -Inoui/libvui
+    CFLAGS += -DUSE_VUI -DWITHOUT_UI
+    LIBS += -ljpeg -lrt
+    Resolution = 960x540 ###Screan Resolution = 960x540; BOARD HX108-v11 Or LCD v30
+    UI_RES_DIR = ui/cvr/res
+    CSRCS = $(wildcard *.c av_wrapper/decoder_demuxing/*.c power/*.c ueventmonitor/*.c \
+            collision/*.c parking_monitor/*.c watermark/*.c storage/*.c  uvc/*.c noui/*.c noui/libvui/*.c)
+else
 ifeq ($(COMPILE_UI_TYPE), CVR)
     #Resolution = 320x240 ###Screan Resolution = 852*480; BOARD VERSION=V10/V11
     #Resolution = 854x480 ###Screan Resolution = 854*480; BOARD VERSION=V10/V11
@@ -70,6 +80,7 @@ else ifeq ($(COMPILE_UI_TYPE), SDV)
             collision/*.c parking_monitor/*.c watermark/*.c storage/*.c uvc/*.c ui/*.c ui/dv/*.c)
 endif
 
+endif
 ui_resolution.h: $(UI_RES_DIR)/ui_$(strip $(Resolution)).h
 	$(Q)install -C $(<) $(@)
 
diff --git a/common.h b/common.h
old mode 100644
new mode 100755
index e711b91..b6fff3a
--- a/common.h
+++ b/common.h
@@ -28,7 +28,7 @@
   { 320, 240, 30 }
 
 //#define USE_CIF_CAMERA
-#define USE_USB_WEBCAM 0
+#define USE_USB_WEBCAM 1
 
 #define TEST_VIDEO_MARK 0
 
diff --git a/menu_commond.h b/menu_commond.h
index 08356f9..1c3df0e 100644
--- a/menu_commond.h
+++ b/menu_commond.h
@@ -18,7 +18,11 @@
 #ifndef __MENUCOMMOND_H__
 #define __MENUCOMMOND_H__
 
+#ifdef WITHOUT_UI
+#include "vgui_api.h"
+#else
 #include <minigui/common.h>
+#endif
 #include "photo_param.h"
 
 
diff --git a/noui/camera_ui.c b/noui/camera_ui.c
new file mode 100644
index 0000000..6d96ed6
--- /dev/null
+++ b/noui/camera_ui.c
@@ -0,0 +1,8108 @@
+/*
+** $Id: helloworld.c 793 2010-07-28 03:36:29Z dongjunjie $
+**
+** Listing 1.1
+**
+** helloworld.c: Sample program for MiniGUI Programming Guide
+**      The first MiniGUI application.
+**
+** Copyright (C) 2004 ~ 2009 Feynman Software.
+**
+** License: GPL
+*/
+
+#include <stdio.h>
+#include <string.h>
+
+#include <stdlib.h>
+#include <stdbool.h>
+#include <stdarg.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <pwd.h>
+#include <errno.h>
+#include <signal.h>
+#include <linux/watchdog.h>
+
+#include <time.h>
+#include <init_hook/init_hook.h>
+#ifdef WITHOUT_UI
+#include "vgui_api.h"
+#include "ueventmonitor/keyboard.h"
+#else
+#include <minigui/common.h>
+#include <minigui/minigui.h>
+#include <minigui/gdi.h>
+#include <minigui/window.h>
+#include <minigui/control.h>
+#include <minigui/rkfb.h>
+#endif
+#ifdef _LANG_ZHCN
+#include "camera_ui_res_cn.h"
+#elif defined _LANG_ZHTW
+#include "camera_ui_res_tw.h"
+#else
+#include "camera_ui_res_en.h"
+#endif
+
+#include "camera_ui.h"
+#include "camera_ui_def.h"
+#include "ueventmonitor/ueventmonitor.h"
+#include "ueventmonitor/usb_sd_ctrl.h"
+#include "wifi_management.h"
+#include "parameter.h"
+#include "fs_manage/fs_manage.h"
+#include "fs_manage/fs_storage.h"
+#include "fs_manage/fs_sdcard.h"
+#include "fs_manage/fs_sdv.h"
+
+#include "common.h"
+#include "videoplay.h"
+#include <dpp/adas.h>
+
+
+#include "audioplay.h"
+#include "audio_dev.h"
+#include <assert.h>
+
+#include <pthread.h>
+
+#include "ui_resolution.h"
+
+#include "watermark.h"
+#include "video.h"
+#include "example/user.h"
+#include "videoplay.h"
+#include "gsensor.h"
+#include "power/thermal.h"
+#include "collision/collision.h"
+#include "parking_monitor/parking_monitor.h"
+
+#include "fwk_protocol/rk_protocol.h"
+#include "fwk_protocol/rk_fwk.h"
+#include "power_manage.h"
+#include "storage/storage.h"
+#include "public_interface.h"
+#include "msg_list_manager.h"
+
+#include "usb_mode.h"
+#include "display_cvr.h"
+
+#include "gps/nmea_parse.h"
+#ifndef WITHOUT_UI
+//#define USE_WATCHDOG
+
+#define BLOCK_PREV_NUM 1   // min
+#define BLOCK_LATER_NUM 1  // min
+
+#define MODE_RECORDING 0
+#define MODE_PHOTO 1
+#define MODE_EXPLORER 2
+#define MODE_PREVIEW 3
+#define MODE_PLAY 4
+#define MODE_USBDIALOG 5
+#define MODE_USBCONNECTION 6
+#define MODE_SUSPEND 7
+//USB
+#define USB_MODE 1
+#define BATTERY_CUSHION 3
+#define USE_KEY_STOP_USB_DIS_SHUTDOWN
+
+#define FW_DEFAULT_MOUNT_FULLNAME "/mnt/sdcard/Firmware.img"
+
+#define PARKINGMONITOR_OFF      0
+#define PARKINGMONITOR_SHUTDOWN_MODE    1
+#define PARKINGMONITOR_SUSPEND_MODE 2
+#define PARKINGMONITOR_MOTION_DETECT    3
+#define PARKINGMONITOR_TIMELAPSE    4
+#define PARKING_RECORD_COUNT        90
+#define MOTION_DETECT_COUNT     30
+#define TIMELAPSE_RECORD_COUNT      30
+#define PARKING_SUSPEND         1
+#define PARKING_SHUTDOWN        2
+
+/* Firmware Status */
+enum {
+    FW_OK = 0,
+    FW_NOTFOUND,
+    FW_INVALID,
+};
+
+static int test_replay;
+static char testpath[256];
+static struct adas_output g_adas_output;
+static short screenoff_time;
+
+//battery stable
+static int last_battery = 1;
+
+static BITMAP A_bmap[3];
+
+RECT msg_rcAB = {A_IMG_X, A_IMG_Y, A_IMG_X + A_IMG_W, A_IMG_Y + A_IMG_H};
+
+RECT adas_rc = {adas_X, adas_Y, adas_W, adas_H};
+
+RECT msg_rcMove = {MOVE_IMG_X, MOVE_IMG_Y, MOVE_IMG_X + MOVE_IMG_W, MOVE_IMG_Y + MOVE_IMG_H};
+
+
+RECT USB_rc = {USB_IMG_X, USB_IMG_Y, USB_IMG_X + USB_IMG_W,
+               USB_IMG_Y + USB_IMG_H
+              };
+
+RECT msg_rcBtt = {BATT_IMG_X, BATT_IMG_Y, BATT_IMG_X + BATT_IMG_W,
+                  BATT_IMG_Y + BATT_IMG_H
+                 };
+
+static BITMAP batt_bmap[5];
+
+RECT msg_rcSD = {TF_IMG_X, TF_IMG_Y, TF_IMG_X + TF_IMG_W,
+                 TF_IMG_Y + TF_IMG_H
+                };
+
+static BITMAP tf_bmap[2];
+
+RECT msg_rcMode = {MODE_IMG_X, MODE_IMG_Y, MODE_IMG_X + MODE_IMG_W,
+                   MODE_IMG_Y + MODE_IMG_H
+                  };
+
+static BITMAP mode_bmap[4];
+
+RECT msg_rcResolution = {RESOLUTION_IMG_X, RESOLUTION_IMG_Y,
+                         RESOLUTION_IMG_X + RESOLUTION_IMG_W,
+                         RESOLUTION_IMG_Y + RESOLUTION_IMG_H
+                        };
+
+static BITMAP resolution_bmap[2];
+
+static BITMAP move_bmap[2];
+
+static BITMAP topbk_bmap;
+
+RECT msg_rcTime = {REC_TIME_X, REC_TIME_Y, REC_TIME_X + REC_TIME_W,
+                   REC_TIME_Y + REC_TIME_H
+                  };
+
+RECT msg_rcRecimg = {REC_IMG_X, REC_IMG_Y, REC_IMG_X + REC_IMG_W,
+                     REC_IMG_Y + REC_IMG_H
+                    };
+static BITMAP recimg_bmap;
+
+RECT msg_motiondetect = {MOTIONDETECT_IMG_X,
+                         MOTIONDETECT_IMG_Y,
+                         MOTIONDETECT_IMG_X + MOTIONDETECT_IMG_W,
+                         MOTIONDETECT_IMG_Y + TIMELAPSE_IMG_H
+                        };
+static BITMAP motiondetect_bmap;
+
+RECT msg_motiondetect_on = {MOTIONDETECT_ON_IMG_X,
+                            MOTIONDETECT_ON_IMG_Y,
+                            MOTIONDETECT_ON_IMG_X + MOTIONDETECT_ON_IMG_W,
+                            MOTIONDETECT_ON_IMG_Y + TIMELAPSE_ON_IMG_H
+                           };
+static BITMAP motiondetect_on_bmap;
+
+RECT msg_timeLapseimg = {TIMELAPSE_IMG_X,
+                         TIMELAPSE_IMG_Y,
+                         TIMELAPSE_IMG_X + TIMELAPSE_IMG_W,
+                         TIMELAPSE_IMG_Y + TIMELAPSE_IMG_H
+                        };
+static BITMAP timelapse_bmap;
+
+RECT msg_timeLapse_on_img = {TIMELAPSE_ON_IMG_X,
+                             TIMELAPSE_ON_IMG_Y,
+                             TIMELAPSE_ON_IMG_X + TIMELAPSE_ON_IMG_W,
+                             TIMELAPSE_ON_IMG_Y + TIMELAPSE_ON_IMG_H
+                            };
+static BITMAP timelapse_on_bmap;
+
+RECT msg_rcMic = {MIC_IMG_X, MIC_IMG_Y, MIC_IMG_X + MIC_IMG_W,
+                  MIC_IMG_Y + MIC_IMG_H
+                 };
+
+static BITMAP mic_bmap[2];
+
+RECT msg_rcSDCAP = {TFCAP_STR_X, TFCAP_STR_Y, TFCAP_STR_X + TFCAP_STR_W,
+                    TFCAP_STR_Y + TFCAP_STR_H
+                   };
+
+RECT msg_rcSYSTIME = {SYSTIME_STR_X, SYSTIME_STR_Y,
+                      SYSTIME_STR_X + SYSTIME_STR_W,
+                      SYSTIME_STR_Y + SYSTIME_STR_H
+                     };
+
+RECT msg_rcFILENAME = {FILENAME_STR_X, FILENAME_STR_Y,
+                       FILENAME_STR_X + FILENAME_STR_W,
+                       FILENAME_STR_Y + FILENAME_STR_H
+                      };
+
+RECT msg_rcWifi = {WIFI_IMG_X, WIFI_IMG_Y, WIFI_IMG_X + WIFI_IMG_W,
+                   WIFI_IMG_Y + WIFI_IMG_H
+                  };
+
+static BITMAP wifi_bmap[5];
+
+RECT msg_rcWatermarkTime = {WATERMARK_TIME_X, WATERMARK_TIME_Y,
+                            WATERMARK_TIME_X + WATERMARK_TIME_W,
+                            WATERMARK_TIME_Y + WATERMARK_TIME_H
+                           };
+
+RECT msg_rcWatermarkLicn = {WATERMARK_LICN_X, WATERMARK_LICN_Y,
+                            WATERMARK_LICN_X + WATERMARK_LICN_W,
+                            WATERMARK_LICN_Y + WATERMARK_LICN_H
+                           };
+
+RECT msg_rcWatermarkImg = {WATERMARK_IMG_X, WATERMARK_IMG_Y,
+                           WATERMARK_IMG_X + WATERMARK_IMG_W,
+                           WATERMARK_IMG_Y + WATERMARK_IMG_H
+                          };
+
+struct bitmap watermark_bmap[7];
+
+/* gps info */
+RECT msg_rcGpsState = {GPS_STATUS_X, GPS_STATUS_Y,
+                       GPS_STATUS_X + GPS_STATUS_W,
+                       GPS_STATUS_Y + GPS_STATUS_H
+                      };
+
+RECT msg_rcGpsSatellite = {GPS_SATELLITE_X, GPS_SATELLITE_Y,
+                           GPS_SATELLITE_X + GPS_SATELLITE_W,
+                           GPS_SATELLITE_Y + GPS_SATELLITE_H
+                          };
+
+RECT msg_rcGpsSpeed = {GPS_SPEED_X, GPS_SPEED_Y,
+                       GPS_SPEED_X + GPS_SPEED_W,
+                       GPS_SPEED_Y + GPS_SPEED_H
+                      };
+
+RECT msg_rcGpsLatitude = {GPS_LATITUDE_X, GPS_LATITUDE_Y,
+                          GPS_LATITUDE_X + GPS_LATITUDE_W,
+                          GPS_LATITUDE_Y + GPS_LATITUDE_H
+                         };
+
+RECT msg_rcGpsLongitude = {GPS_LONGITUDE_X, GPS_LONGITUDE_Y,
+                           GPS_LONGITUDE_X + GPS_LONGITUDE_W,
+                           GPS_LONGITUDE_Y + GPS_LONGITUDE_H
+                          };
+
+RECT msg_rcGpsTime = {GPS_TIME_X, GPS_TIME_Y,
+                      GPS_TIME_X + GPS_TIME_W,
+                      GPS_TIME_Y + GPS_TIME_H
+                     };
+
+static BITMAP play_bmap;
+static pthread_mutex_t set_mutex;
+
+#define ADASFLAG_DRAW               (1 << 0)
+#define ADASFLAG_SETTING            (1 << 1)
+#define ADASFLAG_LINE0_SELECTED     (1 << 2)
+
+/*
+ * bit 2: line[0] selected
+ * bit 1: adas setting flag
+ * bit 0: adas draw flag
+ */
+static int adasFlag = 0;
+static bool takephoto = false;
+
+// menu
+static BITMAP bmp_menu_mp[2];
+static BITMAP bmp_menu_time[2];
+static BITMAP bmp_menu_car[2];
+static BITMAP bmp_menu_setting[2];
+static BITMAP png_menu_debug[2];
+static BITMAP folder_bmap;
+static BITMAP back_bmap;
+static BITMAP usb_bmap;
+static BITMAP filetype_bmap[FILE_TYPE_MAX];
+
+//------------------------------------
+static const char* DSP_IDC[2] = {" IDC ",
+                                 " 畸变校正 "
+                                };
+static const char* video_flip[2] = {" Flip ",
+                                    " 视频翻转 "
+                                   };
+static const char* DSP_3DNR[2] = {" 3DNR ",
+                                  //    "night-vision enhance",
+                                  " 夜视增强 "
+                                 };
+static const char* DISP_CVBSOUT[2] = { " CVBS ",
+                                       " 切换CVBS显示 "
+                                     };
+static const char* DISP_CVBSOUT_PAL[2] = { " PAL ",
+                                           " PAL制式 "
+                                         };
+static const char* DISP_CVBSOUT_NTSC[2] = { " NTSC ",
+                                            " NTSC制式 "
+                                          };
+static const char* fontcamera_ui[2] = {" Front ", " 前置 "};
+static const char* backcamera_ui[2] = {" Back ", " 后置 "};
+static const char* cifcamera_ui[2] = {" CIF ", " cif "};
+
+static const char* str_fw_update[2] = {" Firmware Update ", " 固件升级 "};
+static const char* str_fw_update_test[2] = {" FW_UPDATE TEST ", " 固件升级测试 "};
+static const char* reboot[2] = {" reboot ", " reboot "};
+static const char* recovery_debug[2] = {" recovery ", " recovery拷机  "};
+static const char* standby[2] = {" standby ", " 二级待机 "};
+static const char* mode_change[2] = {" mode change ", " 模式切换 "};
+static const char* video_debug[2] = {" Video ", " video(回放视频) "};
+static const char* beg_end_video[2] = {" beg_end_video ", " 开始/结束录像 "};
+
+static const char* photo_debug[2] = {" photo ", " 录像拍照 "};
+static const char* temp_debug[2] = {" temp control ", " 温度控制 "};
+static const char* DSP_ADAS[2] = {" ADAS ",
+                                  // "lane departure warning",
+                                  " 车道偏离预警 "
+                                 };
+
+static const char* MP[2] = {
+    //  "  MP ",
+    "Resolution", "清晰度"
+};
+static const char* Record_Time[2] = {
+    //  " Record_Time ",
+    "Video length", " 录像时长 "
+};
+static const char* Time_OneMIN[2] = {" 1min ", " 1分钟 "};
+static const char* Time_TMIN[2] = {" 3min ", " 3分钟 "};
+static const char* Time_FMIN[2] = {" 5min ", " 5分钟 "};
+static const char* OFF[2] = {" OFF ", " 关闭 "};
+static const char* ON[2] = {" ON ", " 打开 "};
+static const char* Record_Mode[2] = {
+    //  " Record_Mode ",
+    "Record Mode", " 录像模式 "
+};
+static const char* Front_Record[2] = {
+    //  " Front_Record ",
+    "Front video", " 前镜头录像 "
+};
+static const char* Back_Record[2] = {
+    //  " Back_Record ",
+    "Rear video", " 后镜头录像 "
+};
+static const char* Double_Record[2] = {
+    //  " Double_Record ",
+    "Double video", " 双镜头录像 "
+};
+static const char* setting[2] = {" Setting ", " 设置 "};
+static const char* debug[2] = {" DEBUG ", " DEBUG "};
+
+static const char* WB[2] = {" White Balance ", " 白平衡 "};
+static const char* exposal[2] = {" Exposure ", " 曝光度 "};
+#if ENABLE_MD_IN_MENU
+static const char* auto_detect[2] = {" motion detection ", " 移动侦测 "};
+#endif
+static const char* water_mark[2] = {" Date Stamp ", " 日期标签 "};
+static const char* gps[2] = {" GPS ", " GPS "};
+static const char* record[2] = {" Record Audio ", " 录影音频 "};
+static const char* auto_record[2] = {" Boot record ", " 开机录像 "};
+static const char* language[2] = {" language ", " 语言选择 "};
+static const char* frequency[2] = {" frequency ", " 频率 "};
+static const char* format[2] = {" Format ", " 格式化 "};
+static const char* setdate[2] = {" Date Set ", " 设置日期 "};
+static const char* usbmode[2] = {" USB MODE ", " USB MODE "};
+static const char* fw_ver[2] = {" Version ", " 固件版本 "};
+static const char* recovery[2] = {" Recovery ", " 恢复出厂设置 "};
+static const char* Br_Auto[2] = {" auto ", " 自动 "};
+static const char* Br_Sun[2] = {" Daylight ", " 日光 "};
+static const char* Br_Flu[2] = {" fluorescence ", " 荧光 "};
+static const char* Br_Cloud[2] = {" cloudysky ", " 阴天 "};
+static const char* Br_tun[2] = {" tungsten ", " 灯光 "};
+static const char* HzNum_50[2] = {" 50HZ ", " 50HZ "};
+
+static const char* HzNum_60[2] = {" 60HZ ", " 60HZ "};
+
+static const char* LAN_ENG[2] = {" English ", " English "};
+static const char* LAN_CHN[2] = {" 简体中文 ", " 简体中文 "};
+
+static const char* ExposalData_0[2] = {" -3 ", " -3 "};
+
+static const char* ExposalData_1[2] = {" -2 ", " -2 "};
+
+static const char* ExposalData_2[2] = {" -1 ", " -1 "};
+
+static const char* ExposalData_3[2] = {"  0 ", "  0 "};
+
+static const char* ExposalData_4[2] = {"  1 ", "  1 "};
+
+static const char* backlight[2] = {" Bright ", " 亮度 "};
+
+static const char* collision[2] = {" collision detect ", " 碰撞检测 "};
+static const char* Collision_0[2] = {" close ", " 关闭 "};
+static const char* Collision_1[2] = {" low ", " 低 "};
+static const char* Collision_2[2] = {" middle ", " 中 "};
+static const char* Collision_3[2] = {" hight ", " 高 "};
+static const char* parking_monitor[2] = {" parking monitor ", " 停车录像 "};
+static const char* parkingmonitor_Off[2] = {" off ", " 关闭停车录像 "};
+static const char* Shutdown_On[2] = {" shutdown ", " 关机模式 "};
+static const char* Motion_Detect[2] = {" motion ", " 运动感应 "};
+static const char* Time_Lapse_Record[2] = {" timeLapse ", " 缩时录像 "};
+static const char* screenoffset[2] = {" Auto Off Screen ", " 屏幕自动关闭 "};
+static const char* vbit_rate_vals[6] = {" 1 ", " 2 ",  " 4 ",
+                                        " 5 ", " 6 ", " 8 "
+                                       };
+static const char* vbit_rate_debug[2] = {" video bit rate per pixel ",
+                                         " 视频单像素码率 "
+                                        };
+static const char* wifi[2] = {" WIFI ",
+                              " WIFI "
+                             };
+static const char* time_lapse[LANGUAGE_NUM] =
+{" Timelapse Record ", " 缩时录影 "};
+static const char* time_off[2] = {" OFF ", " 关闭 "};
+static const char* time_one_sec[LANGUAGE_NUM] = {" 1s space ", " 间隔1秒 "};
+static const char* time_five_sec[LANGUAGE_NUM] = {" 5s space ", " 间隔5秒 "};
+static const char* time_ten_sec[LANGUAGE_NUM] = {" 10s space ", " 间隔10秒 "};
+static const char* time_thirty_sec[LANGUAGE_NUM] = {" 30s space ", " 间隔30秒 "};
+static const char* time_sixty_sec[LANGUAGE_NUM] = {" 60s space ", " 间隔60秒 "};
+static const char* video_quality[2] = {" video quality ", " 视频质量 "};
+static const char* quality_hig[2]   = {" high ", " 高 "};
+static const char* quality_mid[2]   = {" middle ", " 中 "};
+static const char* quality_low[2]   = {" low ", " 低 "};
+static const char* license_plate_watermark[2] = {" license plate watermark ", " 车牌水印 "};
+static int battery;
+
+static int cap;
+static int SetMode;
+static int SetCameraMP;
+static HMENU hmnuFor3DNR;
+static HMENU hmnuForADAS;
+static HMENU hwndforpre;
+
+static HWND hWndUSB;
+static HWND hMainWnd;
+static HWND explorer_wnd;
+static HMENU explorer_menu;
+static HMENU hmnuForFRE;
+static HMENU hmnuForLAN;
+static HMENU hmnuForAutoRE;
+static HMENU hmnuForBr;
+static HMENU hmnuForEx;
+static HMENU hmnuForRe;
+static HMENU hmnuForMark;
+static HMENU hmnuMain;
+static HWND hMainWndForPlay;
+static HMENU hmnuForCOLLI;
+static HMENU hmnuForLEAVEREC;
+static HMENU hmnuForAutoOffScreen;
+static HMENU hmnuForVideoQuality;
+static HMENU hmnuForCVBSOUT;
+
+//-------------------------
+static int video_play_state;
+static DWORD bkcolor;
+static int sec;
+static char* explorer_path;
+static pthread_t explorer_update_tid;
+static int explorer_update_run;
+static int explorer_update_reupdate;
+
+#define FILENAME_LEN 128
+static char previewname[FILENAME_LEN];
+static struct file_list* filelist;
+static struct file_node* currentfile;
+static int totalfilenum;
+static int currentfilenum;
+static int preview_isvideo;
+static int videoplay;
+static int adasflagtooff;
+
+// TODO: file path should be read from config_file
+// These files are copied from $ANDROID_PROJECT/frameworks/base/data/sounds.
+static char* capture_sound_file = "/usr/local/share/sounds/camera_click.wav";
+static char* keypress_sound_file = "/usr/local/share/sounds/KeypressStandard.wav";
+
+static struct ui_frame frontcamera[4], backcamera[4], cifcamera[4];
+static int menucreated;
+// debug
+static int reboot_time;
+static int recovery_time;
+static int standby_time;
+static int modechange_time;
+static int video_time;
+static int beg_end_video_time;
+static int photo_time;
+static int fwupdate_test_time;
+
+// int modechange_pre_flage=0;
+//sd
+int param_sd;
+
+/*SHUTDOWN PARAMS*/
+static int gshutdown;
+
+static int key_lock;
+
+static char gparking;
+static char gparking_mode_change;
+static int gparking_gs_active;
+static int gparking_count;
+static int gmotion_detection;
+static int gtimelapse_record;
+
+static long int collision_rec_time;
+
+static struct gps_info ggps_info;
+static struct gps_send_data ggps_send;
+static void gps_info_show(HDC hdc);
+static void gps_ui_control(HWND hWnd, BOOL bEraseBkgnd);
+void gps_send_callback(const char* gpsData, int len, int searchType);
+
+static void initrec(HWND hWnd);
+static void deinitrec(HWND hWnd);
+void changemode(HWND hWnd, int mode);
+void exitvideopreview(void);
+void loadingWaitBmp(HWND hWnd);
+void startrec(HWND hWnd);
+void stoprec(HWND hWnd);
+void unloadingWaitBmp(HWND hWnd);
+
+static int shutdown_deinit(HWND hWnd);
+static int shutdown_usb_disconnect(HWND hWnd);
+void ui_deinit(void);
+
+enum {
+    UI_FORMAT_BGRA_8888 = 0x1000,
+    UI_FORMAT_RGB_565,
+};
+
+/*SHUTDOWN FUNCTION*/
+static int shutdown_deinit(HWND hWnd)
+{
+    if ((gshutdown == 1) || (gshutdown == 2)) {
+        gshutdown = 2; //tell usb disconnect shutdown
+        return -1;
+    }
+    gshutdown = 1;
+
+    power_shutdown();
+
+    return 0;
+}
+
+/* parking record video shutdown or suspend */
+static int parking_record_process(int state)
+{
+    if (state == PARKING_SUSPEND) {
+        printf("parking_record_process: suspend\n");
+        changemode(hMainWnd, MODE_SUSPEND);
+    } else if (state == PARKING_SHUTDOWN) {
+        printf("parking_record_process: shutdown\n");
+        shutdown_deinit(hMainWnd);
+    }
+
+    return 0;
+}
+
+static void gps_info_show(HDC hdc)
+{
+    char info[MAX_GPS_INFO_LEN];
+
+    SetBkColor (hdc, bkcolor);
+
+    memset(info, 0, MAX_GPS_INFO_LEN);
+    snprintf(info, sizeof(info), "status: %c\n", ggps_info.status);
+    TextOut (hdc, GPS_STATUS_X, GPS_STATUS_Y, info);
+
+    memset(info, 0, MAX_GPS_INFO_LEN);
+    snprintf(info, sizeof(info), "Satellites: %02d\n", ggps_info.satellites);
+    TextOut (hdc, GPS_SATELLITE_X, GPS_SATELLITE_Y, info);
+
+    memset(info, 0, MAX_GPS_INFO_LEN);
+    snprintf(info, sizeof(info), "Speed: %lf km/h\n", ggps_info.speed);
+    TextOut (hdc, GPS_SPEED_X, GPS_SPEED_Y, info);
+
+    memset(info, 0, MAX_GPS_INFO_LEN);
+    snprintf(info, sizeof(info), "Latitude: %c-%lf\n",
+            ggps_info.latitude_indicator,
+            gps_degree_minute_to_degree(ggps_info.latitude));
+    TextOut (hdc, GPS_LATITUDE_X, GPS_LATITUDE_Y, info);
+
+    memset(info, 0, MAX_GPS_INFO_LEN);
+    snprintf(info, sizeof(info), "Longitude: %c-%lf\n",
+            ggps_info.longitude_indicator,
+            gps_degree_minute_to_degree(ggps_info.longitude));
+    TextOut (hdc, GPS_LONGITUDE_X, GPS_LONGITUDE_Y, info);
+
+    memset(info, 0, MAX_GPS_INFO_LEN);
+    snprintf(info, sizeof(info), "Time: %04d-%02d-%02d %02d:%02d:%02d\n",
+            ggps_info.date.years, ggps_info.date.months, ggps_info.date.day,
+            ggps_info.date.hour, ggps_info.date.min, ggps_info.date.sec);
+    TextOut (hdc, GPS_TIME_X, GPS_TIME_Y, info);
+}
+
+static void gps_ui_control(HWND hWnd, BOOL bEraseBkgnd)
+{
+    InvalidateRect(hWnd, &msg_rcGpsState, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsSatellite, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsSpeed, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsLatitude, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsLongitude, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsTime, bEraseBkgnd);
+}
+
+void gps_send_callback(const char* gpsData, int len, int searchType)
+{
+    if(gpsData == NULL)
+        return;
+
+    gps_nmea_data_parse(&ggps_info, gpsData, searchType, len);
+}
+
+int collision_event_callback(int cmd, void *msg0, void *msg1)
+{
+    switch (cmd) {
+    case CMD_COLLISION:
+#ifdef CACHE_ENCODEDATA_IN_MEM
+        PostMessage(hMainWnd, MSG_COLLISION,
+                    (WPARAM)msg0, (LPARAM)msg1);
+
+        return COLLISION_CACHE_DURATION;
+#else
+        if ((SetMode == MODE_RECORDING) &&
+            (api_video_get_record_state() == VIDEO_STATE_PREVIEW)) {
+            video_record_blocknotify(BLOCK_PREV_NUM, BLOCK_LATER_NUM);
+            if (collision_rec_time >= COLLISION_CACHE_DURATION) {
+                video_record_savefile();
+                collision_rec_time = 0;
+                return COLLISION_CACHE_DURATION;
+            }
+
+            return (COLLISION_CACHE_DURATION - collision_rec_time);
+        }
+#endif
+        break;
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+void parking_event_callback(int cmd, void *msg0, void *msg1)
+{
+    switch (cmd) {
+    case CMD_PARKING:
+        gparking_gs_active = 1;
+        break;
+    default:
+        break;
+    }
+}
+
+/*usb disconenct shutdown process
+ */
+#ifdef USE_KEY_STOP_USB_DIS_SHUTDOWN
+int stop_usb_disconnect_poweroff()
+{
+    gshutdown = 3;
+    return 0;
+}
+#endif
+
+int usb_disconnect_poweroff(void *arg)
+{
+    int i;
+    HWND hWnd = (HWND)arg;
+
+    for (i = 0; i < 10; i++) {
+        if (charging_status_check()) {
+            gshutdown = 0;
+            printf("%s[%d]:vbus conenct,cancel shutdown\n", __func__, __LINE__);
+            return 0;
+        }
+        if (gshutdown == 2)//powerkey or low battery shutdown
+            break;
+#ifdef USE_KEY_STOP_USB_DIS_SHUTDOWN
+        if (gshutdown == 3) {
+            //key stop usb disconnect shutdown
+            gshutdown = 0;
+            printf("%s[%d]:key stop usb disconnect shutdown\n", __func__, __LINE__);
+            return 0;
+        }
+#endif
+        printf("%s[%d]:shutdown wait---%d\n", __func__, __LINE__, i);
+        sleep(1);
+    }
+    printf("%s[%d]:gshutdown=%d,shutdown...\n", __func__, __LINE__, gshutdown);
+    api_video_deinit();
+
+    if (charging_status_check()) {
+        gshutdown = 0;
+        printf("%s[%d]:vbus conenct,cancel shutdown\n", __func__, __LINE__);
+        video_record_deinit();
+        printf("init rec---\n");
+        initrec(hWnd);
+        if ((api_video_get_record_state() == VIDEO_STATE_PREVIEW) && api_get_sd_mount_state() == SD_STATE_IN)
+            api_start_rec();
+        return 0;
+    }
+
+    power_shutdown();
+    return 0;
+}
+
+void *usb_disconnect_process(void *arg)
+{
+    printf ("usb_disconnect_process\n");
+    usb_disconnect_poweroff(arg);
+    pthread_exit(NULL);
+}
+
+pthread_t run_usb_disconnect(HWND hWnd)
+{
+    pthread_t tid;
+    printf ("run_usb_disconnect\n");
+    if (pthread_create(&tid, NULL, usb_disconnect_process, (void *)hWnd)) {
+        printf("Create run_usb_disconnect thread failure\n");
+        return -1;
+    }
+
+    return tid;
+}
+
+static int shutdown_usb_disconnect(HWND hWnd)
+{
+    if (gshutdown == 1)
+        return -1;
+    gshutdown = 1;
+
+    run_usb_disconnect(hWnd);
+    return 0;
+}
+
+static int display_timelapse_record_mode_ui(HWND hWnd, int enable)
+{
+    HDC hdc;
+
+    if (enable == 1) {
+        InvalidateRect(hWnd, &msg_timeLapseimg, TRUE);
+        hdc = BeginPaint(hWnd);
+        FillBoxWithBitmap(hdc,
+                          TIMELAPSE_IMG_X,
+                          TIMELAPSE_IMG_Y,
+                          TIMELAPSE_IMG_W,
+                          TIMELAPSE_IMG_H,
+                          &timelapse_bmap);
+        EndPaint(hWnd, hdc);
+    } else if (enable == 0) {
+        InvalidateRect(hWnd, &msg_timeLapseimg, TRUE);
+    }
+
+    return 0;
+}
+
+static int display_timelapse_on_ui(HWND hWnd, int enable)
+{
+    HDC hdc;
+
+    if (enable == 1) {
+        InvalidateRect(hWnd, &msg_timeLapse_on_img, TRUE);
+        hdc = BeginPaint(hWnd);
+        FillBoxWithBitmap(hdc,
+                          MOTIONDETECT_ON_IMG_X,
+                          MOTIONDETECT_ON_IMG_Y,
+                          MOTIONDETECT_ON_IMG_W,
+                          MOTIONDETECT_ON_IMG_H,
+                          &timelapse_on_bmap);
+        EndPaint(hWnd, hdc);
+        gtimelapse_record = 1;
+    } else if (enable == 0) {
+        printf("display_timelapse_on_ui close\n");
+        InvalidateRect(hWnd, &msg_timeLapse_on_img, TRUE);
+        gtimelapse_record = 0;
+    }
+
+    return 0;
+}
+
+static int display_motion_detect_mode_ui(HWND hWnd, int enable)
+{
+    HDC hdc;
+
+    if (enable == 1) {
+        InvalidateRect(hWnd, &msg_motiondetect, TRUE);
+        hdc = BeginPaint(hWnd);
+        FillBoxWithBitmap(hdc,
+                          MOTIONDETECT_IMG_X,
+                          MOTIONDETECT_IMG_Y,
+                          MOTIONDETECT_IMG_W,
+                          MOTIONDETECT_IMG_H,
+                          &motiondetect_bmap);
+        EndPaint(hWnd, hdc);
+    } else if (enable == 0) {
+        InvalidateRect(hWnd, &msg_motiondetect, TRUE);
+    }
+
+    return 0;
+}
+
+static int display_motion_detect_on_ui(HWND hWnd, int enable)
+{
+    HDC hdc;
+
+    if (enable == 1) {
+        InvalidateRect(hWnd, &msg_motiondetect_on, TRUE);
+        hdc = BeginPaint(hWnd);
+        FillBoxWithBitmap(hdc,
+                          MOTIONDETECT_ON_IMG_X,
+                          MOTIONDETECT_ON_IMG_Y,
+                          MOTIONDETECT_ON_IMG_W,
+                          MOTIONDETECT_ON_IMG_H,
+                          &motiondetect_on_bmap);
+        EndPaint(hWnd, hdc);
+        gmotion_detection = 1;
+    } else if (enable == 0) {
+        printf("display_motion_detect_on_ui close\n");
+        InvalidateRect(hWnd, &msg_motiondetect_on, TRUE);
+        gmotion_detection = 0;
+    }
+
+    return 0;
+}
+
+static int parking_prompt_window(HWND hWnd, char parking_mode)
+{
+    if (parking_mode == PARKINGMONITOR_MOTION_DETECT) {
+        if (gmotion_detection == 1)
+            display_motion_detect_on_ui(hWnd, 1);
+        else
+            display_motion_detect_mode_ui(hWnd, 1);
+    } else if (parking_mode == PARKINGMONITOR_TIMELAPSE) {
+        if (gtimelapse_record == 1)
+            display_timelapse_on_ui(hWnd, 1);
+        else
+            display_timelapse_record_mode_ui(hWnd, 1);
+    } else {
+        display_motion_detect_mode_ui(hWnd, 0);
+        display_timelapse_record_mode_ui(hWnd, 0);
+    }
+
+    return 0;
+}
+
+static int parking_monitor_mode_switch(HWND hWnd)
+{
+    gparking = parameter_get_parkingmonitor();
+    if (gparking_mode_change == 1) {
+        if (gtimelapse_record == 1) {
+            display_timelapse_on_ui(hWnd, 0);
+        }
+        if (gmotion_detection == 1) {
+            display_motion_detect_on_ui(hWnd, 0);
+        }
+
+        gparking_mode_change = 0;
+    }
+
+    parking_prompt_window(hWnd, gparking);
+
+    if (gparking == PARKINGMONITOR_MOTION_DETECT) {
+        if (gparking_gs_active == 1) {
+            gparking_count = 0;
+            gparking_gs_active = 0;
+        } else if (SetMode == MODE_RECORDING) {
+            gparking_count++;
+        } else {
+            gparking_count = 0;
+        }
+
+        if (gparking_count % 10 == 0)
+            printf("MOTION_Detect: gparking_count = %d\n",
+                   gparking_count);
+        if ((gparking_count >= MOTION_DETECT_COUNT) &&
+            (gmotion_detection == 0)) {
+            printf("start_motion_detection\n");
+            start_motion_detection();
+            gmotion_detection = 1;
+
+            /* UI: prompt start motion detection */
+            display_motion_detect_on_ui(hWnd, 1);
+        } else if ((gmotion_detection == 1) &&
+                   (gparking_count == 0)) {
+            printf("close_motion_detection\n");
+            stop_motion_detection();
+            gmotion_detection = 0;
+
+            /* UI: prompt close motion detection */
+            display_motion_detect_on_ui(hWnd, 0);
+
+            printf("init rec---\n");
+            if (api_get_sd_mount_state() == SD_STATE_IN)
+                api_start_rec();
+        }
+    } else if ((gparking == PARKINGMONITOR_SHUTDOWN_MODE) ||
+               (gparking == PARKINGMONITOR_SUSPEND_MODE)) {
+        if ((gparking_gs_active == 0) &&
+            (PARKINGMONITOR_OFF != gparking)) {
+            if ((SetMode != MODE_USBDIALOG) &&
+                (SetMode != MODE_USBCONNECTION))
+                gparking_count++;
+            else
+                gparking_count = 0;
+            if (gparking_count % 10 == 0)
+                printf("PARKING_Monitor : gparking_count = %d\n",
+                       gparking_count);
+            if (gparking_count >= PARKING_RECORD_COUNT) {
+                if (gparking == PARKINGMONITOR_SHUTDOWN_MODE) {
+                    printf("shutdown\n");
+                    parking_record_process(PARKING_SHUTDOWN);
+                } else if (gparking == PARKINGMONITOR_SUSPEND_MODE) {
+                    printf("suspend:\n");
+                    parking_record_process(PARKING_SUSPEND);
+                }
+            }
+        }
+
+        if (((gparking_gs_active == 1) &&
+             (PARKINGMONITOR_OFF != gparking)) ||
+            (PARKINGMONITOR_OFF == gparking)) {
+            gparking_count = 0;
+            gparking_gs_active = 0;
+        }
+    } else if (gparking == PARKINGMONITOR_TIMELAPSE) {
+        if (gparking_gs_active == 1) {
+            gparking_count = 0;
+            gparking_gs_active = 0;
+        } else if (SetMode == MODE_RECORDING) {
+            gparking_count++;
+        } else {
+            gparking_count = 0;
+        }
+
+        if (gparking_count % 10 == 0)
+            printf("Timelapse_record : gparking_count = %d\n",
+                   gparking_count);
+        if ((gparking_count >= TIMELAPSE_RECORD_COUNT) &&
+            (gtimelapse_record == 0)) {
+            printf("start_timelapse_record\n");
+            gtimelapse_record = 1;
+            parameter_save_time_lapse_interval(1);
+            video_record_set_timelapseint(1);
+
+            /* UI: prompt start timelapse record */
+            display_timelapse_on_ui(hWnd, 1);
+        } else if ((gtimelapse_record == 1) &&
+                   (gparking_count == 0)) {
+            printf("close_timelapse_record\n");
+            parameter_save_time_lapse_interval(0);
+            video_record_set_timelapseint(0);
+            gtimelapse_record = 0;
+            /* UI: prompt close timelapse record */
+            display_timelapse_on_ui(hWnd, 0);
+        }
+    } else {
+        gparking_gs_active = 0;
+        gparking_count = 0;
+        gmotion_detection = 0;
+    }
+
+    return 0;
+}
+
+static void prompt(HWND hDlg)
+{
+    int year = SendDlgItemMessage(hDlg, IDL_YEAR, CB_GETSPINVALUE, 0, 0);
+    int mon = SendDlgItemMessage(hDlg, IDL_MONTH, CB_GETSPINVALUE, 0, 0);
+    int mday = SendDlgItemMessage(hDlg, IDL_DAY, CB_GETSPINVALUE, 0, 0);
+    int hour = SendDlgItemMessage(hDlg, IDC_HOUR, CB_GETSPINVALUE, 0, 0);
+    int min = SendDlgItemMessage(hDlg, IDC_MINUTE, CB_GETSPINVALUE, 0, 0);
+    int sec = SendDlgItemMessage(hDlg, IDL_SEC, CB_GETSPINVALUE, 0, 0);
+    printf("%d--%d--%d--%d--%d--%d\n", year, mon, mday, hour, min, sec);
+
+    api_set_system_time(year, mon, mday, hour, min, sec);
+}
+
+static int MyDateBoxProc(HWND hDlg, int message, WPARAM wParam, LPARAM lParam)
+{
+    time_t t;
+    //    char bufff[512] = "";
+    struct tm* tm;
+    switch (message) {
+    case MSG_INITDIALOG: {
+        HWND hCurFocus;
+        HWND hNewFocus;
+
+        time(&t);
+        tm = localtime(&t);
+        hCurFocus = GetFocusChild(hDlg);
+        SendDlgItemMessage(hDlg, IDL_YEAR, CB_SETSPINFORMAT, 0, (LPARAM) "%04d");
+        SendDlgItemMessage(hDlg, IDL_YEAR, CB_SETSPINRANGE, 1900, 2100);
+        SendDlgItemMessage(hDlg, IDL_YEAR, CB_SETSPINVALUE, tm->tm_year + 1900,
+                           0);
+        SendDlgItemMessage(hDlg, IDL_YEAR, CB_SETSPINPACE, 1, 1);
+
+        SendDlgItemMessage(hDlg, IDL_MONTH, CB_SETSPINFORMAT, 0, (LPARAM) "%02d");
+        SendDlgItemMessage(hDlg, IDL_MONTH, CB_SETSPINRANGE, 1, 12);
+        SendDlgItemMessage(hDlg, IDL_MONTH, CB_SETSPINVALUE, tm->tm_mon + 1, 0);
+        SendDlgItemMessage(hDlg, IDL_MONTH, CB_SETSPINPACE, 1, 2);
+
+        SendDlgItemMessage(hDlg, IDL_DAY, CB_SETSPINFORMAT, 0, (LPARAM) "%02d");
+        SendDlgItemMessage(hDlg, IDL_DAY, CB_SETSPINRANGE, 0, 30);
+        SendDlgItemMessage(hDlg, IDL_DAY, CB_SETSPINVALUE, tm->tm_mday, 0);
+        SendDlgItemMessage(hDlg, IDL_DAY, CB_SETSPINPACE, 1, 3);
+
+        SendDlgItemMessage(hDlg, IDC_HOUR, CB_SETSPINFORMAT, 0, (LPARAM) "%02d");
+        SendDlgItemMessage(hDlg, IDC_HOUR, CB_SETSPINRANGE, 0, 23);
+        SendDlgItemMessage(hDlg, IDC_HOUR, CB_SETSPINVALUE, tm->tm_hour, 0);
+        SendDlgItemMessage(hDlg, IDC_HOUR, CB_SETSPINPACE, 1, 4);
+
+        SendDlgItemMessage(hDlg, IDC_MINUTE, CB_SETSPINFORMAT, 0,
+                           (LPARAM) "%02d");
+        SendDlgItemMessage(hDlg, IDC_MINUTE, CB_SETSPINRANGE, 0, 59);
+        SendDlgItemMessage(hDlg, IDC_MINUTE, CB_SETSPINVALUE, tm->tm_min, 0);
+        SendDlgItemMessage(hDlg, IDC_MINUTE, CB_SETSPINPACE, 1, 5);
+
+        SendDlgItemMessage(hDlg, IDL_SEC, CB_SETSPINFORMAT, 0, (LPARAM) "%02d");
+        SendDlgItemMessage(hDlg, IDL_SEC, CB_SETSPINRANGE, 0, 59);
+        SendDlgItemMessage(hDlg, IDL_SEC, CB_SETSPINVALUE, tm->tm_sec, 0);
+        SendDlgItemMessage(hDlg, IDL_SEC, CB_SETSPINPACE, 1, 6);
+        hNewFocus = GetNextDlgTabItem(hDlg, hCurFocus, FALSE);
+        SetNullFocus(hCurFocus);
+        SetFocus(hNewFocus);
+        return 0;
+    }
+    case MSG_COMMAND: {
+        break;
+    }
+    case MSG_KEYDOWN: {
+        switch (wParam) {
+        case SCANCODE_ESCAPE:
+            EndDialog(hDlg, wParam);
+            break;
+        case SCANCODE_MENU:
+            EndDialog(hDlg, wParam);
+            break;
+        case SCANCODE_ENTER: {
+            prompt(hDlg);
+            EndDialog(hDlg, wParam);
+            break;
+        }
+        }
+        break;
+    }
+    }
+
+    return DefaultDialogProc(hDlg, message, wParam, lParam);
+}
+
+static void proc_MSG_FS_INITFAIL(HWND hWnd, int param);
+int sdcardmount_back(void* arg, int param)
+{
+    HWND hWnd = (HWND)arg;
+    printf("sdcardmount_back param = %d\n", param);
+
+    if (param == 0) {
+        PostMessage(hWnd, MSG_REPAIR, 0, 1);
+    } else if (param == 1) {
+        PostMessage(hWnd, MSG_FSINITFAIL, 0, 1);
+    }
+
+    return 0;
+}
+
+//-----------------
+static int UsbSDProc(HWND hDlg, int message, WPARAM wParam, LPARAM lParam)
+{
+    switch (message) {
+    case MSG_INITDIALOG: {
+        HWND hFocus = GetDlgDefPushButton(hDlg);
+        hWndUSB = hDlg;
+
+        if (hFocus)
+            SetFocus(hFocus);
+        return 0;
+    }
+    case MSG_COMMAND: {
+        switch (wParam) {
+        case IDUSB: {
+            printf("  UsbSDProc :case IDUSB:IDUSB  \n");
+            if (api_get_sd_mount_state() == SD_STATE_IN) {
+                //  printf("UsbSDProc:");
+                cvr_usb_sd_ctl(USB_CTRL, 1);
+                EndDialog(hDlg, wParam);
+                // hWndUSB = 0;
+                changemode(hMainWnd, MODE_USBCONNECTION);
+            } else if (api_get_sd_mount_state() == SD_STATE_OUT) {
+                //  EndDialog(hDlg, wParam);
+                if (parameter_get_video_lan() == 1)
+                    MessageBox(hDlg, "SD卡不存在!!!", "警告!!!", MB_OK);
+                else if (parameter_get_video_lan() == 0)
+                    MessageBox(hDlg, "no SD card insertted!!!", "Warning!!!", MB_OK);
+            }
+
+            break;
+        }
+        case USBBAT: {
+            printf("  UsbSDProc :case USBBAT  \n");
+            cvr_usb_sd_ctl(USB_CTRL, 0);
+            EndDialog(hDlg, wParam);
+            hWndUSB = 0;
+            changemode(hMainWnd, MODE_RECORDING);
+            break;
+        }
+        }
+        break;
+    }
+    }
+
+    return DefaultDialogProc(hDlg, message, wParam, lParam);
+}
+
+void cmd_IDM_SETDATE(void)
+{
+}
+
+static void cmd_IDM_RECOVERY(HWND hWnd)
+{
+    int ret;
+
+    if (parameter_get_video_lan() == 0)
+        ret = MessageBox(hWnd, "You sure you want to restore the factory settings?", "Warning", MB_YESNO | MB_DEFBUTTON2);
+    else if (parameter_get_video_lan() == 1)
+        ret = MessageBox(hWnd, "确定要恢复出厂设置?", "警告", MB_YESNO | MB_DEFBUTTON2);
+
+    if (ret == IDYES)
+        api_recovery();
+}
+
+static void cmd_IDM_FWVER(HWND hWnd)
+{
+    if (parameter_get_video_lan() == 0)
+        MessageBox(hWnd, parameter_get_firmware_version(), "FW Version", MB_OK);
+    else if (parameter_get_video_lan() == 1)
+        MessageBox(hWnd, parameter_get_firmware_version(), "固件版本", MB_OK);
+}
+
+static int check_firmware(void)
+{
+    int ret;
+
+    ret = access(FW_DEFAULT_MOUNT_FULLNAME, 0);
+    if (ret) {
+        printf("Not found firmware: " FW_DEFAULT_MOUNT_FULLNAME "\n");
+        ret = FW_NOTFOUND;
+        goto err;
+    }
+
+    /* TODO: verify firmware */
+
+    return FW_OK;
+
+err:
+    return ret;
+}
+
+static void cmd_IDM_SETTING_FWUPDATE(HWND hWnd)
+{
+    int ret;
+
+    ret = check_firmware();
+
+check_info:
+    switch (ret) {
+    case FW_NOTFOUND:
+        printf("check FW_NOTFOUND: (%d)\n", ret);
+        if (parameter_get_video_lan() == 0)
+            MessageBox(hWnd, "Not found: /mnt/sdcard/Firmware.img", "Firmware Update", MB_OK);
+        else if (parameter_get_video_lan() == 1)
+            MessageBox(hWnd, "未找到: /mnt/sdcard/Firmware.img", "固件升级", MB_OK);
+        break;
+    case FW_INVALID:
+        printf("check FW_INVALID: (%d)\n", ret);
+        if (parameter_get_video_lan() == 0)
+            MessageBox(hWnd, "Invalid firmware?", "Firmware Update", MB_OK);
+        else if (parameter_get_video_lan() == 1)
+            MessageBox(hWnd, "无效的固件？", "固件升级", MB_OK);
+        break;
+    case FW_OK:
+    default:
+        printf("check FW_OK\n");
+        if (parameter_get_video_lan() == 0)
+            ret = MessageBox(hWnd, "Will update firmware from /mnt/sdcard/Firmware.img?",
+                             "Firmware Update", MB_YESNO | MB_DEFBUTTON2);
+        else if (parameter_get_video_lan() == 1)
+            ret = MessageBox(hWnd, "用新固件 /mnt/sdcard/Firmware.img 升级？",
+                             "固件升级", MB_YESNO | MB_DEFBUTTON2);
+        if (ret == IDYES) {
+            /* check again */
+            ret = check_firmware();
+            if (ret == FW_OK) {
+                /* The BOOT_FWUPDATE which is defined in init_hook.h */
+                printf("will reboot and update...\n");
+                parameter_flash_set_flashed(BOOT_FWUPDATE);
+                power_reboot();
+            } else {
+                goto check_info;
+            }
+        }
+
+        break;
+    }
+}
+
+static void cmd_IDM_DEBUG_FWUPDATE_TEST(HWND hWnd)
+{
+    int ret;
+
+    if (parameter_get_video_lan() == 0)
+        ret = MessageBox(hWnd, "Will start fw_update test?",
+                         "FW_UPDATE TEST", MB_YESNO | MB_DEFBUTTON2);
+    else if (parameter_get_video_lan() == 1)
+        ret = MessageBox(hWnd, "开始固件升级测试？",
+                         "固件升级测试", MB_YESNO | MB_DEFBUTTON2);
+    if (ret == IDYES) {
+        unsigned int fwupdate_cnt = parameter_flash_get_fwupdate_count();
+
+        printf("FW_UPDATE_TEST (%d) cycles start...\n", fwupdate_cnt);
+
+        /* The BOOT_FWUPDATE_TEST_START which is defined in init_hook.h */
+        parameter_flash_set_flashed(BOOT_FWUPDATE_TEST_START);
+        power_reboot();
+    }
+}
+
+void cmd_IDM_CAR(HWND hWnd, char i)
+{
+    api_set_abmode(i);
+}
+
+static void cmd_IDM_3DNR(HWND hWnd, char i)
+{
+    api_3dnr_onoff(i);
+}
+
+#if 0
+static void cmd_IDM_IDC(HWND hWnd, char i)
+{
+    parameter_save_video_idc(i);
+}
+
+static void cmd_IDM_FLIP(HWND hWnd, char i)
+{
+    parameter_save_video_flip(i);
+    rk_fb_set_flip(i);
+}
+
+static void cmd_IDM_CVBSOUT(HWND hWnd, int i)
+{
+    int ret;
+
+    switch (i) {
+        /* no external */
+    case OUT_DEVICE_LCD:
+        if (rk_fb_get_cvbsout_connect()) {
+            if (!system("echo 0 > /sys/class/display/TV/enable"))
+                printf("shutdown external display\n");
+            else
+                printf("failed to shutdown external display\n");
+        }
+        break;
+        /* cvbsout */
+    case OUT_DEVICE_CVBS_PAL:
+        if (rk_fb_get_cvbsout_connect()) {
+            if (!system("echo 1 > /sys/class/display/TV/enable"))
+                printf("switch to cvbsout display\n");
+            else
+                printf("failed to switch to cvbsout display\n");
+
+            ret = system("echo 720x576i-50 > /sys/class/display/TV/mode");
+            if (!ret)
+                printf("switch to cvbsout PAL mode\n");
+            else
+                printf("failed to switch cvbsout display mode\n");
+            rk_fb_set_out_device(OUT_DEVICE_CVBS_PAL);
+        }
+        break;
+    case OUT_DEVICE_CVBS_NTSC:
+        if (rk_fb_get_cvbsout_connect()) {
+            if (!system("echo 1 > /sys/class/display/TV/enable"))
+                printf("switch to cvbsout display\n");
+            else
+                printf("failed to switch to cvbsout display\n");
+
+            ret = system("echo 720x480i-60 > /sys/class/display/TV/mode");
+            if (!ret)
+                printf("switch to cvbsout NTSC mode\n");
+            else
+                printf("failed to switch cvbsout display mode\n");
+            rk_fb_set_out_device(OUT_DEVICE_CVBS_NTSC);
+        }
+        break;
+    }
+}
+#endif
+
+static void cmd_IDM_ADAS(HWND hWnd, WPARAM wParam)
+{
+    char store[2];
+
+    switch (wParam) {
+    case IDM_ADAS_OFF:
+        api_adas_onoff(0);
+        break;
+    case IDM_ADAS_ON:
+        dpp_adas_set_calibrate_line((int)(ADAS_FCW_HEIGHT * ((float)store[0] / 100)),
+                                    (int)(ADAS_FCW_HEIGHT * ((float)store[1] / 100)));
+        adasFlag &= ~ADASFLAG_SETTING;
+        api_adas_onoff(1);
+        break;
+    default:
+        break;
+    }
+}
+
+static void cmd_IDM_detect(HWND hWnd, WPARAM wParam, LPARAM lParam)
+{
+    //printf("cmd_IDM_detect, wParam: %ld, lParam: %ld\n", wParam, lParam);
+    switch (wParam) {
+    case IDM_detectOFF:
+        if (!lParam && parameter_get_video_de() == 0)
+            return;
+        stop_motion_detection();
+        if (!lParam)
+            parameter_save_video_de(0);
+        InvalidateRect(hWnd, &msg_rcMove, FALSE);
+        break;
+    case IDM_detectON:
+        if (!lParam && parameter_get_video_de() == 1)
+            return;
+        if (!lParam)
+            parameter_save_video_de(1);
+        start_motion_detection(hWnd);
+        InvalidateRect(hWnd, &msg_rcMove, FALSE);
+        break;
+    default:
+        break;
+    }
+}
+
+static void cmd_IDM_YES_DELETE(void)
+{
+    if (parameter_get_video_lan() == 0)
+        MessageBox(hMainWndForPlay, "You choose YES!!", "DELETE", MB_OK);
+    else if (parameter_get_video_lan() == 1)
+        MessageBox(hMainWndForPlay, "你选择是!!", "删除", MB_OK);
+}
+
+static void cmd_IDM_NO_DELETE(void)
+{
+    if (parameter_get_video_lan() == 0)
+        MessageBox(hMainWndForPlay, "You choose NO!!", "DELETE", MB_OK);
+    else if (parameter_get_video_lan() == 1)
+        MessageBox(hMainWndForPlay, "你选择否!!", "删除", MB_OK);
+}
+//if format fail, retry format.
+static void cmd_IDM_RE_FORMAT(HWND hWnd)
+{
+    // just need judge mmcblk0
+    if (fs_manage_sd_exist(SDCARD_DEVICE) != 0) {
+        api_sdcard_format(1);
+    } else {
+        if (parameter_get_video_lan() == 1)
+            MessageBox(hWnd, "SD卡不存在!!", "警告!!!", MB_OK);
+        else if (parameter_get_video_lan() == 0)
+            MessageBox(hWnd, "no SD card insertted!!!", "Warning!!!", MB_OK);
+    }
+
+    return;
+}
+
+
+static void cmd_IDM_FORMAT(HWND hWnd)
+{
+}
+
+static void cmd_IDM_BACKLIGHT(WPARAM wParam)
+{
+}
+
+/* Chinese index */
+static uint32_t lic_chinese_idx = 0;
+/* Charactor or number index */
+static uint32_t lic_num_idx = 0;
+
+static char licenseplate_str[20];
+/* Save the car license plate */
+static char licenseplate[8][3] = {"-", "-", "-", "-", "-", "-", "-", "-",};
+uint32_t licplate_pos[8] = {0};
+
+#define PROVINCE_ABBR_MAX  37
+#define LICENSE_CHAR_MAX   39
+
+static const char g_license_chinese[PROVINCE_ABBR_MAX][3] = {
+    " ", "京", "津", "沪", "渝", "冀", "晋", "蒙", "辽", "吉", "黑",
+    "苏", "浙", "皖", "闽", "赣", "鲁", "豫", "鄂", "湘", "粤",
+    "桂", "琼", "川", "贵", "云", "藏", "青", "陕", "甘", "宁",
+    "新", "港", "澳", "台", "*", "-"
+};
+
+static const char g_license_char[LICENSE_CHAR_MAX][2] = {
+    " ", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
+    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
+    "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
+    "U", "V", "W", "X", "Y", "Z", "*", "-",
+};
+
+static void get_licenseplate_and_pos()
+{
+    int i, j;
+    char** lic_plate = NULL;
+
+    if (parameter_get_licence_plate_flag() == 1) {
+        lic_plate = (char **)parameter_get_licence_plate();
+        memcpy(licenseplate, lic_plate, sizeof(licenseplate));
+    } else {
+        for (i = 0; i < 8; i++)
+            strcpy(*(licenseplate + i), "-");
+    }
+
+    /* Init the license plate position */
+    memset(licplate_pos, 0, sizeof(licplate_pos));
+
+    if (parameter_get_licence_plate_flag() != 1)
+        return;
+
+    for (j = 0; j < PROVINCE_ABBR_MAX; j++) {
+        if (!strncmp(licenseplate[0], g_license_chinese[j], 2)) {
+            licplate_pos[0] = j;
+            break;
+        }
+    }
+
+    for (i = 1; i < 8; i++) {
+        for (j = 0; j < LICENSE_CHAR_MAX; j++) {
+            if (!strncmp(licenseplate[i], g_license_char[j], 2)) {
+                licplate_pos[i] = j;
+                break;
+            }
+        }
+    }
+}
+
+static void save_licenseplate()
+{
+    uint32_t i, pos;
+    uint32_t license_len;
+    uint32_t show_license[MAX_TIME_LEN] = { 0 };
+
+    memset(licenseplate_str, 0, sizeof(licenseplate_str));
+
+    /* Save the content before change fouce CtrlID */
+    if (lic_chinese_idx) {
+        /* Save the fisrt Chinese Charactor */
+        pos = licplate_pos[0];
+        strcpy((char*)licenseplate[0], (char*)g_license_chinese[pos]);
+        strcat(licenseplate_str, (char*)licenseplate[0]);
+    }
+
+    for (i = 1; i < 8; i++) {
+        if (licplate_pos[i] != 0) {
+            pos = licplate_pos[i];
+            strcpy(licenseplate[i], g_license_char[pos]);
+        }
+        strcat(licenseplate_str + 2, (char*)licenseplate[i]);
+    }
+
+    parameter_save_licence_plate(licenseplate, 8);
+    parameter_save_licence_plate_flag(1);
+
+    watermark_get_show_license(show_license, licenseplate_str, &license_len);
+    video_record_update_license(show_license, license_len);
+}
+
+static int MyLicensePlateProc(HWND hDlg, int message, WPARAM wParam, LPARAM lParam)
+{
+    HDC hdc;
+    int dlgID;
+    int i, k;
+    HWND hCurFocus;
+    RECT rt;
+    static HWND hFocus;
+
+    switch (message) {
+    case MSG_INITDIALOG: {
+        hCurFocus = GetFocus(hDlg);
+        hFocus = GetNextDlgTabItem(hDlg, hCurFocus, FALSE);
+        dlgID = GetDlgCtrlID(hFocus);
+
+        get_licenseplate_and_pos();
+
+        /* Set licence plate at init. */
+        for (k = 0; k < 8; k++) {
+            if (dlgID == ((k + 1) + IDC_BUTTON_OK))
+                SetWindowText(hFocus, (char*)licenseplate[k]);
+
+            hFocus = GetNextDlgTabItem(hDlg, hFocus, FALSE);
+            dlgID = GetDlgCtrlID(hFocus);
+        }
+
+        hFocus = GetNextDlgTabItem(hDlg, hFocus, FALSE);
+        dlgID = GetDlgCtrlID(hFocus);
+        SetFocus(hFocus);
+        return 0;
+    }
+
+    case MSG_COMMAND:
+        break;
+
+    case MSG_PAINT: {
+        uint32_t old_bk_color;
+        uint32_t old_pen_color;
+
+        hdc = BeginPaint(hDlg);
+        GetClientRect(hDlg, &rt);
+        hFocus = GetFocus(hDlg);
+        dlgID = GetDlgCtrlID(hFocus);
+
+        if (dlgID == IDC_BUTTON_OK)
+            SetFocus(hFocus);
+
+        old_bk_color = GetBkColor(hdc);
+        old_pen_color = GetPenColor(hdc);
+
+        for (i = IDC_STATIC1; i <= IDC_STATIC8; i++) {
+            if (i == dlgID) {
+                /* Selected */
+                SetPenColor(hdc, COLOR_red);
+                SetPenWidth(hdc, 4);
+                Rectangle(hdc, 96 + (i - IDC_STATIC1) * 30, 76, 124 + (i - IDC_STATIC1) * 30, 104);
+            } else {
+                /* Unselected */
+                SetPenColor(hdc, old_bk_color);
+                Rectangle(hdc, 96 + (i - IDC_STATIC1) * 30, 76, 124 + (i - IDC_STATIC1) * 30, 104);
+            }
+        }
+
+        if (dlgID == IDC_BUTTON_OK) {
+            SetPenColor(hdc, COLOR_red);
+            SetPenWidth(hdc, 4);
+            Rectangle(hdc, 300 - 2, 180 - 2, 350 + 2, 200 + 2);
+        } else {
+            uint8_t r, g, b;
+            GetPixelRGB(hdc, 0, 0, &r, &g, &b);
+            SetPenColor(hdc, RGB2Pixel(hdc, r, g, b));
+            Rectangle(hdc, 300 - 2, 180 - 2, 350 + 2, 200 + 2);
+        }
+
+        SetPenColor(hdc, old_pen_color);
+        Rectangle(hdc, 10, 10, rt.right - 10, rt.bottom - 10);
+        EndPaint(hDlg, hdc);
+    }
+    break;
+
+    case MSG_KEYDOWN: {
+        if (key_lock)
+            break;
+
+        int index = 0;
+
+        hdc = GetClientDC(hDlg);
+
+        switch (wParam) {
+        case SCANCODE_ESCAPE:
+            EndDialog(hDlg, wParam);
+            break;
+        case SCANCODE_MENU:
+            save_licenseplate();
+            EndDialog(hDlg, wParam);
+            break;
+        case SCANCODE_ENTER: {
+            save_licenseplate();
+            EndDialog(hDlg, wParam);
+            break;
+        }
+        case SCANCODE_CURSORBLOCKDOWN: {
+            hFocus = GetFocus(hDlg);
+            dlgID = GetDlgCtrlID(hFocus);
+            if (dlgID == IDC_BUTTON_OK)
+                break;
+
+            /* Select Chinese Character */
+            if (dlgID == IDC_STATIC1) {
+                if (lic_chinese_idx >= PROVINCE_ABBR_MAX - 1)
+                    lic_chinese_idx = 0;
+                /* Ignore space char */
+                SetWindowText(hFocus, g_license_chinese[++lic_chinese_idx]);
+                licplate_pos[0] = lic_chinese_idx;
+            } else {
+                index = dlgID - IDC_STATIC1;
+                lic_num_idx = licplate_pos[index];
+
+                if (lic_num_idx >= LICENSE_CHAR_MAX - 1)
+                    lic_num_idx = 0;
+
+                SetWindowText(hFocus, (char*)g_license_char[++lic_num_idx]);
+                licplate_pos[index] = lic_num_idx;
+            }
+            break;
+        }
+        case SCANCODE_CURSORBLOCKUP: {
+            hFocus = GetFocus(hDlg);
+            dlgID = GetDlgCtrlID(hFocus);
+            if (dlgID == IDC_BUTTON_OK)
+                break;
+
+            /* Select Chinese Character */
+            if (dlgID == IDC_STATIC1) {
+                if (lic_chinese_idx == 0)
+                    lic_chinese_idx = PROVINCE_ABBR_MAX - 1;
+
+                if (lic_chinese_idx == 1)
+                    lic_chinese_idx = PROVINCE_ABBR_MAX;
+                SetWindowText(hFocus, (char*)g_license_chinese[--lic_chinese_idx]);
+                licplate_pos[0] = lic_chinese_idx;
+            } else {
+                index = dlgID - IDC_STATIC1;
+                lic_num_idx = licplate_pos[index];
+
+                if (lic_num_idx == 0)
+                    lic_num_idx = LICENSE_CHAR_MAX - 1;
+
+                if (lic_num_idx == 1)
+                    lic_num_idx = LICENSE_CHAR_MAX;
+                SetWindowText(hFocus, g_license_char[--lic_num_idx]);
+                licplate_pos[index] = lic_num_idx;
+            }
+            break;
+        }
+        case SCANCODE_CURSORBLOCKLEFT:
+            hFocus = GetNextDlgTabItem(hDlg, hFocus, TRUE);
+            SetFocus(hFocus);
+            GetClientRect(hDlg, &rt);
+            InvalidateRect(hDlg, &rt, FALSE);
+            break;
+        case SCANCODE_CURSORBLOCKRIGHT:
+            hFocus = GetNextDlgTabItem(hDlg, hFocus, FALSE);
+            SetFocus(hFocus);
+            GetClientRect(hDlg, &rt);
+            InvalidateRect(hDlg, &rt, FALSE);
+            break;
+        case SCANCODE_TAB: {
+            RECT rt;
+            hFocus = GetFocus(hDlg);
+            dlgID = GetDlgCtrlID(hFocus);
+
+            lic_chinese_idx = licplate_pos[0];
+            if (dlgID != IDC_BUTTON_OK)
+                lic_num_idx = licplate_pos[dlgID + 1];  /* Get the next ctrlID's char index */
+
+            GetClientRect(hDlg, &rt);
+            InvalidateRect(hDlg, &rt, FALSE);
+        }
+        break;
+        }
+        ReleaseDC(hdc);
+        break;
+    }
+    }
+
+    return DefaultDialogProc(hDlg, message, wParam, lParam);
+}
+
+void cmd_IDM_SetLicensePlate(HWND hWnd)
+{
+}
+
+static void cmd_IDM_DEBUG_PHOTO_ON(HWND hWnd)
+{
+    if ((api_video_get_record_state() == VIDEO_STATE_PREVIEW)
+        && api_get_sd_mount_state() == SD_STATE_IN)
+        api_start_rec();
+    parameter_save_debug_photo(1);
+}
+
+static void cmd_IDM_DEBUG_PHOTO_OFF(HWND hWnd)
+{
+    if (api_video_get_record_state() == VIDEO_STATE_RECORD)
+        api_stop_rec();
+    parameter_save_debug_photo(0);
+}
+
+static void cmd_IDM_DEBUG_TEMP_ON(HWND hWnd)
+{
+    parameter_save_debug_temp(1);
+}
+
+static void cmd_IDM_DEBUG_TEMP_OFF(HWND hWnd)
+{
+    parameter_save_debug_temp(0);
+}
+
+extern void GUIAPI HideMenuBar (HWND hwnd);
+void MainMenuClean(HWND hWnd)
+{
+    SendMessage (HWND_DESKTOP, MSG_CLOSEMENU, 0, 0);
+    HideMenuBar(hWnd);
+}
+
+//---------------MSG_COMMAND消息处理函数---------------------
+static int commandEvent(HWND hWnd, WPARAM wParam, LPARAM lParam)
+{
+    struct photo_param photo_param1 = {1280, 720, 7};
+    struct photo_param photo_param2 = {1920, 1080, 5};
+    struct photo_param photo_param3 = {2560, 1440, 3};
+
+    switch (wParam) {
+    case IDM_FONT_1:
+        api_set_front_rec_resolution(0);
+        break;
+    case IDM_FONT_2:
+        api_set_front_rec_resolution(1);
+        break;
+    case IDM_FONT_3:
+        api_set_front_rec_resolution(2);
+        break;
+    case IDM_FONT_4:
+        api_set_front_rec_resolution(3);
+        break;
+    case IDM_BACK_1:
+        api_set_back_rec_resolution(0);
+        break;
+    case IDM_BACK_2:
+        api_set_back_rec_resolution(1);
+        break;
+    case IDM_BACK_3:
+        api_set_back_rec_resolution(2);
+        break;
+    case IDM_BACK_4:
+        api_set_back_rec_resolution(3);
+        break;
+    case IDM_CIF_1:
+        api_set_cif_rec_resolution(0);
+        break;
+    case IDM_CIF_2:
+        api_set_cif_rec_resolution(1);
+        break;
+    case IDM_CIF_3:
+        api_set_cif_rec_resolution(2);
+        break;
+    case IDM_CIF_4:
+        api_set_cif_rec_resolution(3);
+        break;
+    case IDM_BOOT_OFF:
+        parameter_save_debug_reboot(0);
+        break;
+    case IDM_RECOVERY_OFF:
+        parameter_save_debug_recovery(0);
+        break;
+    case IDM_STANDBY_2_OFF:
+        parameter_save_debug_standby(0);
+        break;
+    case IDM_MODE_CHANGE_OFF:
+        parameter_save_debug_modechange(0);
+        break;
+    case IDM_DEBUG_VIDEO_OFF:
+        parameter_save_debug_video(0);
+        break;
+    case IDM_BEG_END_VIDEO_OFF:
+        parameter_save_debug_beg_end_video(0);
+        break;
+    case IDM_DEBUG_PHOTO_OFF:
+        cmd_IDM_DEBUG_PHOTO_OFF(hWnd);
+        break;
+    case IDM_DEBUG_TEMP_ON:
+        cmd_IDM_DEBUG_TEMP_ON(hWnd);
+        break;
+    case IDM_DEBUG_TEMP_OFF:
+        cmd_IDM_DEBUG_TEMP_OFF(hWnd);
+        break;
+    case IDM_BOOT_ON:
+        parameter_save_debug_reboot(1);
+        break;
+    case IDM_RECOVERY_ON:
+        parameter_save_debug_recovery(1);
+        break;
+    case IDM_STANDBY_2_ON:
+        parameter_save_debug_standby(1);
+        break;
+    case IDM_MODE_CHANGE_ON:
+        parameter_save_debug_modechange(1);
+        break;
+    case IDM_DEBUG_VIDEO_ON:
+        parameter_save_debug_video(1);
+        break;
+    case IDM_BEG_END_VIDEO_ON:
+        parameter_save_debug_beg_end_video(1);
+        break;
+    case IDM_DEBUG_PHOTO_ON:
+        cmd_IDM_DEBUG_PHOTO_ON(hWnd);
+        break;
+    case IDM_VIDEO_QUALITY_H:
+        api_set_video_quaity(VIDEO_QUALITY_HIGH);
+        break;
+    case IDM_VIDEO_QUALITY_M:
+        api_set_video_quaity(VIDEO_QUALITY_MID);
+        break;
+    case IDM_VIDEO_QUALITY_L:
+        api_set_video_quaity(VIDEO_QUALITY_LOW);
+        break;
+    case IDM_LICENSEPLATE_WATERMARK:
+        cmd_IDM_SetLicensePlate(hWnd);
+        break;
+    case IDM_1M_ph:
+        api_set_photo_resolution(&photo_param1);
+        break;
+    case IDM_2M_ph:
+        api_set_photo_resolution(&photo_param2);
+        break;
+    case IDM_3M_ph:
+        api_set_photo_resolution(&photo_param3);
+        break;
+    case IDM_RECOVERY:
+        cmd_IDM_RECOVERY(hWnd);
+        break;
+    case IDM_FWVER:
+        cmd_IDM_FWVER(hWnd);
+        break;
+    case IDM_SETTING_FWUPDATE:
+        cmd_IDM_SETTING_FWUPDATE(hWnd);
+        break;
+    case IDM_DEBUG_FWUPDATE_TEST:
+        cmd_IDM_DEBUG_FWUPDATE_TEST(hWnd);
+        break;
+    case IDM_USB:
+        cmd_IDM_USB();
+        break;
+    case IDM_ADB:
+        cmd_IDM_ADB();
+        break;
+    case IDM_UVC:
+        cmd_IDM_UVC();
+        break;
+    case IDM_ABOUT_CAR:
+        break;
+    case IDM_ABOUT_TIME:
+        break;
+    case IDM_1MIN:
+        api_video_set_time_lenght(60);
+        break;
+    case IDM_3MIN:
+        api_video_set_time_lenght(180);
+        break;
+    case IDM_5MIN:
+        api_video_set_time_lenght(300);
+        break;
+    case IDM_CAR1:
+        cmd_IDM_CAR(hWnd, 0);
+        break;
+    case IDM_CAR2:
+        cmd_IDM_CAR(hWnd, 1);
+        break;
+    case IDM_CAR3:
+        cmd_IDM_CAR(hWnd, 2);
+        break;
+    case IDM_IDCOFF:
+        api_set_video_idc(0);
+        break;
+    case IDM_IDCON:
+        api_set_video_idc(1);
+        break;
+    case IDM_FLIP_OFF:
+        api_set_video_flip(0);
+        break;
+    case IDM_FLIP_ON:
+        api_set_video_flip(1);
+        break;
+    case IDM_3DNROFF:
+        cmd_IDM_3DNR(hWnd, 0);
+        break;
+    case IDM_3DNRON:
+        cmd_IDM_3DNR(hWnd, 1);
+        break;
+    case IDM_CVBSOUT_ON_PAL:
+        api_set_video_cvbsout(OUT_DEVICE_CVBS_PAL);
+        break;
+    case IDM_CVBSOUT_ON_NTSC:
+        api_set_video_cvbsout(OUT_DEVICE_CVBS_NTSC);
+        break;
+    case IDM_CVBSOUT_OFF:
+        api_set_video_cvbsout(OUT_DEVICE_LCD);
+        break;
+    case IDM_ADAS_OFF:
+        cmd_IDM_ADAS(hWnd, wParam);
+        break;
+    case IDM_ADAS_ON:
+        cmd_IDM_ADAS(hWnd, wParam);
+        break;
+    case IDM_bright1:
+        api_set_white_balance(0);
+        break;
+    case IDM_bright2:
+        api_set_white_balance(1);
+        break;
+    case IDM_bright3:
+        api_set_white_balance(2);
+        break;
+    case IDM_bright4:
+        api_set_white_balance(3);
+        break;
+    case IDM_bright5:
+        api_set_white_balance(4);
+        break;
+    case IDM_exposal1:
+        api_set_exposure_compensation(0);
+        break;
+    case IDM_exposal2:
+        api_set_exposure_compensation(1);
+        break;
+    case IDM_exposal3:
+        api_set_exposure_compensation(2);
+        break;
+    case IDM_exposal4:
+        api_set_exposure_compensation(3);
+        break;
+    case IDM_exposal5:
+        api_set_exposure_compensation(4);
+        break;
+    case IDM_detectON:
+    case IDM_detectOFF:
+        cmd_IDM_detect(hWnd, wParam, lParam);
+        break;
+    case IDM_markOFF:
+        api_video_mark_onoff(0);
+        break;
+    case IDM_markON:
+        api_video_mark_onoff(1);
+        break;
+    case IDM_GPSOFF:
+        if (parameter_get_gps_mark()) {
+            gps_ui_control(hWnd, TRUE);
+            gps_deinit(&ggps_send);
+            parameter_save_gps_mark(0);
+        }
+        break;
+    case IDM_GPSON:
+        if (!parameter_get_gps_mark()) {
+            if (gps_init(gps_send_callback, &ggps_send) == 0) {
+                parameter_save_gps_mark(1);
+                memset(&ggps_info, 0, sizeof(struct gps_info));
+                gps_ui_control(hWnd, FALSE);
+            }
+        }
+        break;
+    case IDM_recordOFF:
+        api_mic_onoff(0);
+        break;
+    case IDM_recordON:
+        api_mic_onoff(1);
+        break;
+    case IDM_AUTOOFFSCREENON:
+        screenoff_time = 15;
+        api_set_video_autooff_screen(15);  // 15S
+        break;
+    case IDM_AUTOOFFSCREENOFF:
+        screenoff_time = -1;
+        api_set_video_autooff_screen(-1);
+        break;
+    case IDM_autorecordOFF:
+        api_video_autorecode_onoff(0);
+        break;
+    case IDM_autorecordON:
+        api_video_autorecode_onoff(1);
+        break;
+    case IDM_WIFIOFF:
+        parameter_save_wifi_en(0);
+        wifi_management_stop();
+        break;
+    case IDM_WIFION:
+        parameter_save_wifi_en(1);
+        wifi_management_start();
+        break;
+    case IDM_langEN:
+        api_set_language(0);
+        break;
+    case IDM_langCN:
+        api_set_language(1);
+        break;
+    case IDM_50HZ:
+        api_set_video_freq(CAMARE_FREQ_50HZ);
+        break;
+    case IDM_60HZ:
+        api_set_video_freq(CAMARE_FREQ_60HZ);
+        break;
+    case IDM_YES_DELETE:
+        cmd_IDM_YES_DELETE();
+        break;
+    case IDM_NO_DELETE:
+        cmd_IDM_NO_DELETE();
+        break;
+    case IDM_1M:
+        SetCameraMP = 0;
+        break;
+    case IDM_2M:
+        SetCameraMP = 1;
+        break;
+    case IDM_3M:
+        SetCameraMP = 2;
+        break;
+    case IDM_FORMAT:
+        cmd_IDM_FORMAT(hWnd);
+        break;
+    case IDM_SETDATE:
+        cmd_IDM_SETDATE();
+        break;
+    case IDM_BACKLIGHT_L:
+        cmd_IDM_BACKLIGHT(wParam);
+        break;
+    case IDM_BACKLIGHT_M:
+        cmd_IDM_BACKLIGHT(wParam);
+        break;
+    case IDM_BACKLIGHT_H:
+        cmd_IDM_BACKLIGHT(wParam);
+        break;
+    case IDM_ABOUT_SETTING:
+        break;
+    case IDM_COLLISION_NO:
+        api_set_collision_level(COLLI_CLOSE);
+        break;
+    case IDM_COLLISION_L:
+        api_set_collision_level(COLLI_LEVEL_L);
+        break;
+    case IDM_COLLISION_M:
+        api_set_collision_level(COLLI_LEVEL_M);
+        break;
+    case IDM_COLLISION_H:
+        api_set_collision_level(COLLI_LEVEL_H);
+        break;
+    case IDM_PARKINGMONITOR_OFF:
+        parameter_save_parkingmonitor(PARKINGMONITOR_OFF);
+        parameter_save_video_de(0);
+        parking_unregister();
+        if (gmotion_detection == 1) {
+            stop_motion_detection();
+            gmotion_detection = 0;
+        }
+        if (gtimelapse_record == 1) {
+            parameter_save_time_lapse_interval(0);
+            video_record_set_timelapseint(0);
+        }
+        if (gparking != IDM_PARKINGMONITOR_OFF) {
+            gparking_count = 0;
+        }
+
+        break;
+    case IDM_PARKINGMONITOR_SHUTDOWN_MODE:
+        if (gmotion_detection == 1) {
+            stop_motion_detection();
+        }
+        if (gtimelapse_record == 1) {
+            parameter_save_time_lapse_interval(0);
+            video_record_set_timelapseint(0);
+        }
+        if (gparking != PARKINGMONITOR_SHUTDOWN_MODE) {
+            gparking_count = 0;
+            gparking_mode_change = 1;
+        }
+        parameter_save_parkingmonitor(PARKINGMONITOR_SHUTDOWN_MODE);
+        gparking = PARKINGMONITOR_SHUTDOWN_MODE;
+
+        parking_register();
+        break;
+    case IDM_MOTION_DETECT:
+        if (gtimelapse_record == 1) {
+            parameter_save_time_lapse_interval(0);
+            video_record_set_timelapseint(0);
+        }
+        if (gparking != PARKINGMONITOR_MOTION_DETECT) {
+            gparking_count = 0;
+            gparking_mode_change = 1;
+        }
+        parking_register();
+        parameter_save_parkingmonitor(PARKINGMONITOR_MOTION_DETECT);
+        gparking = PARKINGMONITOR_MOTION_DETECT;
+        parameter_save_video_de(1);
+
+        break;
+    case IDM_TIME_LAPSE_RECORD:
+        if (gmotion_detection == 1) {
+            stop_motion_detection();
+        }
+        if (gparking != PARKINGMONITOR_TIMELAPSE) {
+            gparking_count = 0;
+            gparking_mode_change = 1;
+        }
+        parking_register();
+        parameter_save_parkingmonitor(PARKINGMONITOR_TIMELAPSE);
+        gparking = PARKINGMONITOR_TIMELAPSE;
+
+        break;
+        /* TODO: show status of time-lapse by icon in screen */
+    case IDM_TIME_LAPSE_OFF:
+        api_set_video_time_lapse(0);
+        break;
+    case IDM_TIME_LAPSE_INTERNAL_1s:
+        api_set_video_time_lapse(1);
+        break;
+    case IDM_TIME_LAPSE_INTERNAL_5s:
+        api_set_video_time_lapse(5);
+        break;
+    case IDM_TIME_LAPSE_INTERNAL_10s:
+        api_set_video_time_lapse(10);
+        break;
+    case IDM_TIME_LAPSE_INTERNAL_30s:
+        api_set_video_time_lapse(30);
+        break;
+    case IDM_TIME_LAPSE_INTERNAL_60s:
+        api_set_video_time_lapse(60);
+        break;
+    case IDM_QUIT:
+        DestroyMainWindow(hWnd);
+        PostQuitMessage(hWnd);
+        return 0;
+    }
+
+    return 1;
+}
+
+//----碰撞检测菜单实现-----------
+static HMENU createpmenufileCOLLISION()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)collision[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)collision[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForCOLLI = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_collision_level() == COLLI_CLOSE) ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_COLLISION_NO;
+    mii.typedata = (DWORD)Collision_0[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Collision_0[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_collision_level() == COLLI_LEVEL_L)
+                ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_COLLISION_L;
+    mii.typedata = (DWORD)Collision_1[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Collision_1[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_collision_level() == COLLI_LEVEL_M)
+                ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_COLLISION_M;
+    mii.typedata = (DWORD)Collision_2[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Collision_2[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 5, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_collision_level() == COLLI_LEVEL_H)
+                ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_COLLISION_H;
+    mii.typedata = (DWORD)Collision_3[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Collision_3[i];
+
+    InsertMenuItem(hmnu, 6, TRUE, &mii);
+
+    return hmnu;
+}
+
+//----停车录像菜单实现-----------
+static HMENU createpmenufileLEAVECARREC()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)parking_monitor[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)parking_monitor[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForLEAVEREC = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_parkingmonitor() == PARKINGMONITOR_OFF) ?
+                MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_PARKINGMONITOR_OFF;
+    mii.typedata = (DWORD)parkingmonitor_Off[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)parkingmonitor_Off[i];
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_parkingmonitor() == PARKINGMONITOR_SHUTDOWN_MODE) ?
+                MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_PARKINGMONITOR_SHUTDOWN_MODE;
+    mii.typedata = (DWORD)Shutdown_On[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Shutdown_On[i];
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_parkingmonitor() == PARKINGMONITOR_MOTION_DETECT) ?
+                MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_MOTION_DETECT;
+    mii.typedata = (DWORD)Motion_Detect[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Motion_Detect[i];
+    InsertMenuItem(hmnu, 5, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 6, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_parkingmonitor() == PARKINGMONITOR_TIMELAPSE) ?
+                MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_TIME_LAPSE_RECORD;
+    mii.typedata = (DWORD)Time_Lapse_Record[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Time_Lapse_Record[i];
+    InsertMenuItem(hmnu, 7, TRUE, &mii);
+
+    return hmnu;
+}
+//----频率菜单实现-----------
+static HMENU createpmenufileFREQUENCY()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)frequency[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)frequency[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForFRE = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_fre() == CAMARE_FREQ_50HZ) ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_50HZ;
+    mii.typedata = (DWORD)HzNum_50[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)HzNum_50[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_fre() == CAMARE_FREQ_60HZ) ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_60HZ;
+    mii.typedata = (DWORD)HzNum_60[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)HzNum_60[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+//----背光亮度菜单实现-----------
+static HMENU createpmenufileBACKLIGHT()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    char BackLight_1[2][20] = {" low ", " 低 "};
+    char BackLight_2[2][20] = {" middle ", " 中 "};
+    char BackLight_3[2][20] = {" hight ", " 高 "};
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)backlight[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)backlight[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_backlt() == LCD_BACKLT_L) ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_BACKLIGHT_L;
+    mii.typedata = (DWORD)BackLight_1[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)BackLight_1[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_backlt() == LCD_BACKLT_M) ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_BACKLIGHT_M;
+    mii.typedata = (DWORD)BackLight_2[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)BackLight_2[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_backlt() == LCD_BACKLT_H) ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_BACKLIGHT_H;
+    mii.typedata = (DWORD)BackLight_3[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)BackLight_3[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    return hmnu;
+}
+static HMENU createpmenufileUSB()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    char* UsbMsc[2] = {" msc ", " msc "};
+    char* UsbAdb[2] = {" adb ", " adb "};
+#if USE_USB_WEBCAM
+    char* UsbUvc[2] = {" uvc ", " uvc "};
+#endif
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)usbmode[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)usbmode[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_usb() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_USB;
+    mii.typedata = (DWORD)UsbMsc[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)UsbMsc[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_usb() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_ADB;
+    mii.typedata = (DWORD)UsbAdb[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)UsbAdb[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+#if USE_USB_WEBCAM
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_usb() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_UVC;
+    mii.typedata = (DWORD)UsbUvc[0];
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)UsbUvc[i];
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+#endif
+
+    return hmnu;
+}
+
+//------------语言选择菜单实现-----------------
+static HMENU createpmenufileLANGUAGE()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)language[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)language[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForLAN = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_lan() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_langEN;
+    mii.typedata = (DWORD)LAN_ENG[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)LAN_ENG[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_lan() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_langCN;
+    mii.typedata = (DWORD)LAN_CHN[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)LAN_CHN[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+//---------------屏幕自动关闭菜单实现-------------------
+static HMENU createpmenufileWIFIONOFF()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)wifi[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)wifi[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_wifi_en() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_WIFIOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_wifi_en() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_WIFION;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+//---------------屏幕自动关闭菜单实现-------------------
+static HMENU createpmenufileAUTOOFFSCREEN()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)screenoffset[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)screenoffset[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForAutoOffScreen = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_screenoff_time() == -1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_AUTOOFFSCREENOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_screenoff_time() > 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_AUTOOFFSCREENON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+//---------------开机录像菜单实现-------------------
+static HMENU createpmenufileAUTORECORD()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)auto_record[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)auto_record[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForAutoRE = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_video_autorec() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_autorecordOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_video_autorec() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_autorecordON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU createpmenufileIDC()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)DSP_IDC[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DSP_IDC[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuFor3DNR = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_idc() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_IDCOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_idc() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_IDCON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU createpmenufileVIDEOFLIP()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)video_flip[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)video_flip[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_flip() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_FLIP_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_flip() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_FLIP_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+//---------3DNR-------------------------
+static HMENU createpmenufile3DNR()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)DSP_3DNR[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DSP_3DNR[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuFor3DNR = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_3dnr() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_3DNROFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_3dnr() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_3DNRON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+/*----------------External Display---------------------*/
+static HMENU createpmenufileCVBSOUT()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int tmp;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)DISP_CVBSOUT[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DISP_CVBSOUT[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForCVBSOUT = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (rk_fb_get_out_device(&tmp, &tmp) == OUT_DEVICE_LCD) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_CVBSOUT_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (rk_fb_get_out_device(&tmp, &tmp) == OUT_DEVICE_CVBS_PAL) ?
+                MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_CVBSOUT_ON_PAL;
+    mii.typedata = (DWORD)DISP_CVBSOUT_PAL[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DISP_CVBSOUT_PAL[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (rk_fb_get_out_device(&tmp, &tmp) == OUT_DEVICE_CVBS_NTSC) ?
+                MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_CVBSOUT_ON_NTSC;
+    mii.typedata = (DWORD)DISP_CVBSOUT_NTSC[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DISP_CVBSOUT_NTSC[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    return hmnu;
+}
+
+// font camera
+static HMENU createpmenufileFONTCAMERA()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int cnt = 0;
+    char mpstr[128] = {0};
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)fontcamera_ui[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)fontcamera_ui[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    if (!video_record_get_front_resolution(frontcamera, 4)) {
+        if ((frontcamera[0].width > 0) && (frontcamera[0].height > 0)) {
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", frontcamera[0].width, frontcamera[0].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_fontcamera() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_FONT_1;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+        if ((frontcamera[1].width > 0) && (frontcamera[1].height > 0)) {
+            if (cnt == 1) {
+                mii.type = MFT_SEPARATOR;  //类型
+                mii.state = 0;
+                mii.id = 0;  // ID
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", frontcamera[1].width, frontcamera[1].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_fontcamera() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_FONT_2;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+        if ((frontcamera[2].width > 0) && (frontcamera[2].height > 0)) {
+            if (cnt >= 1) {
+                mii.type = MFT_SEPARATOR;  //类型
+                mii.state = 0;
+                mii.id = 0;  // ID
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", frontcamera[2].width, frontcamera[2].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_fontcamera() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_FONT_3;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+        if ((frontcamera[3].width > 0) && (frontcamera[3].height > 0)) {
+            if (cnt >= 1) {
+                mii.type = MFT_SEPARATOR;  //类型
+                mii.state = 0;
+                mii.id = 0;  // ID
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", frontcamera[3].width, frontcamera[3].height);
+
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_fontcamera() == 3) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_FONT_4;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+    }
+
+    return hmnu;
+}
+
+static HMENU createpmenufileCIFCamera()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int cnt = 0;
+    char mpstr[10] = {0};
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)cifcamera_ui[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)cifcamera_ui[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    if (!video_record_get_cif_resolution(cifcamera, 4)) {
+        if ((cifcamera[0].width > 0) && (cifcamera[0].height > 0)) {
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", cifcamera[0].width, cifcamera[0].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_cifcamera() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_CIF_1;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+
+        if ((cifcamera[1].width > 0) && (cifcamera[1].height > 0)) {
+            if (cnt == 1) {
+                mii.type = MFT_SEPARATOR;
+                mii.state = 0;
+                mii.id = 0;
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", cifcamera[1].width, cifcamera[1].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_cifcamera() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_CIF_2;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+
+        if ((cifcamera[2].width > 0) && (cifcamera[2].height > 0)) {
+            if (cnt >= 1) {
+                mii.type = MFT_SEPARATOR;
+                mii.state = 0;
+                mii.id = 0;
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", cifcamera[2].width, cifcamera[2].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_cifcamera() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_CIF_3;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+
+        if ((cifcamera[3].width > 0) && (cifcamera[3].height > 0)) {
+            if (cnt >= 1) {
+                mii.type = MFT_SEPARATOR;
+                mii.state = 0;
+                mii.id = 0;
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", cifcamera[3].width, cifcamera[3].height);
+
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_cifcamera() == 3) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_CIF_4;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+    }
+    return hmnu;
+}
+
+static HMENU createpmenufileBACKCAMERA()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int cnt = 0;
+    char mpstr[10] = {0};
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)backcamera_ui[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)backcamera_ui[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    if (!video_record_get_back_resolution(backcamera, 4)) {
+        if ((backcamera[0].width > 0) && (backcamera[0].height > 0)) {
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", backcamera[0].width, backcamera[0].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_backcamera() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_BACK_1;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+        if ((backcamera[1].width > 0) && (backcamera[1].height > 0)) {
+            if (cnt == 1) {
+                mii.type = MFT_SEPARATOR;  //类型
+                mii.state = 0;
+                mii.id = 0;  // ID
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", backcamera[1].width, backcamera[1].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_backcamera() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_BACK_2;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+        if ((backcamera[2].width > 0) && (backcamera[2].height > 0)) {
+            if (cnt >= 1) {
+                mii.type = MFT_SEPARATOR;  //类型
+                mii.state = 0;
+                mii.id = 0;  // ID
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", backcamera[2].width, backcamera[2].height);
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_backcamera() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_BACK_3;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+        if ((backcamera[3].width > 0) && (backcamera[3].height > 0)) {
+            if (cnt >= 1) {
+                mii.type = MFT_SEPARATOR;  //类型
+                mii.state = 0;
+                mii.id = 0;  // ID
+                mii.typedata = 0;
+                InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+            }
+
+            memset(&mpstr, 0, 10);
+            snprintf(mpstr, sizeof(mpstr), "%d * %d", backcamera[3].width, backcamera[3].height);
+
+            memset(&mii, 0, sizeof(MENUITEMINFO));
+            mii.type = MFT_RADIOCHECK;
+            mii.state =
+                (parameter_get_video_backcamera() == 3) ? MFS_CHECKED : MFS_UNCHECKED;
+            mii.id = IDM_BACK_4;
+            mii.typedata = (DWORD)mpstr;
+
+            for (i = 0; i < LANGUAGE_NUM; i++)
+                mii.str[i] = mpstr;
+
+            InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+        }
+    } else {
+        //          hmnu = NULL;
+    }
+
+    return hmnu;
+}
+
+// REBOOT
+static HMENU createpmenufileREBOOT()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)reboot[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)reboot[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_reboot() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_BOOT_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_reboot() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_BOOT_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+static HMENU createpmenufileRECOVERY()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)recovery_debug[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)recovery_debug[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_recovery() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_RECOVERY_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_recovery() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_RECOVERY_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU createpmenufileSTANDBY()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)standby[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)standby[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_standby() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_STANDBY_2_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_standby() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_STANDBY_2_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU createpmenufileMODECHANGE()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)mode_change[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)mode_change[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_modechange() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_MODE_CHANGE_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_modechange() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_MODE_CHANGE_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+static HMENU createpmenufileDEBUGVIDEO()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)video_debug[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)video_debug[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_video() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_DEBUG_VIDEO_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_video() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_DEBUG_VIDEO_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+static HMENU createpmenufileBEGENDVIDEO()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)beg_end_video[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)beg_end_video[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_beg_end_video() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_BEG_END_VIDEO_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state =
+        (parameter_get_debug_beg_end_video() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_BEG_END_VIDEO_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+static HMENU createpmenufileDEBUGPHOTO()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)photo_debug[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)photo_debug[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_photo() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_DEBUG_PHOTO_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_photo() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_DEBUG_PHOTO_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU createpmenufileDEBUGTEMP()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)temp_debug[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)temp_debug[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_temp() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_DEBUG_TEMP_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_debug_temp() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_DEBUG_TEMP_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+inline static void add_seperator_line(HMENU hmnu, MENUITEMINFO* mii, int* cnt)
+{
+    mii->type = MFT_SEPARATOR;  //类型
+    mii->state = 0;
+    mii->id = 0;  // ID
+    mii->typedata = 0;
+    InsertMenuItem(hmnu, *cnt, TRUE, mii);
+    *cnt += 1;
+}
+
+#define ADD_SUB_VBR_MENU(INDEX, VAL)                                       \
+  memset(&mii, 0, sizeof(MENUITEMINFO));                                   \
+  mii.type = MFT_RADIOCHECK;                                               \
+  mii.state = (parameter_get_bit_rate_per_pixel() == VAL) ? MFS_CHECKED    \
+                                                          : MFS_UNCHECKED; \
+  mii.id = IDM_DEBUG_VIDEO_BIT_RATE + VAL;                           \
+  mii.typedata = (DWORD)vbit_rate_vals[INDEX];                             \
+  mii.str[0] = (char*)vbit_rate_vals[INDEX];                               \
+  InsertMenuItem(hmnu, cnt++, TRUE, &mii)
+
+static HMENU createpmenufileDEBUGVideoBitRate()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int cnt = 0;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)vbit_rate_debug[0];
+
+    for (i = 0; i < 2; i++)
+        mii.str[i] = (char*)vbit_rate_debug[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    for (i = 0; i < sizeof(vbit_rate_vals) / sizeof(vbit_rate_vals[0]); i++) {
+        int val = atoi(vbit_rate_vals[i]);
+        add_seperator_line(hmnu, &mii, &cnt);
+        ADD_SUB_VBR_MENU(i, val);
+    }
+
+    return hmnu;
+}
+
+static HMENU createpmenufileADAS()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)DSP_ADAS[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DSP_ADAS[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForADAS = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_adas() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_ADAS_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_adas() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_ADAS_ON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = MFS_UNCHECKED;
+    mii.id = IDM_ADAS_SETTING;
+    mii.typedata = (DWORD)setting[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)setting[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    return hmnu;
+}
+
+//?-------------------白平衡菜单实现-------------
+static HMENU createpmenufileWB()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)WB[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)WB[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForBr = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_wb() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_bright1;
+    mii.typedata = (DWORD)Br_Auto[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Br_Auto[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_wb() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_bright2;
+    mii.typedata = (DWORD)Br_Sun[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Br_Sun[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_wb() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_bright3;
+    mii.typedata = (DWORD)Br_Flu[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Br_Flu[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 5, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_wb() == 3) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_bright4;
+    mii.typedata = (DWORD)Br_Cloud[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Br_Cloud[i];
+
+    InsertMenuItem(hmnu, 6, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 7, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_wb() == 4) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_bright5;
+    mii.typedata = (DWORD)Br_tun[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Br_tun[i];
+
+    InsertMenuItem(hmnu, 8, TRUE, &mii);
+
+    return hmnu;
+}
+//-----曝光度-------------------------
+static HMENU createpmenufileEXPOSAL()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)exposal[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)exposal[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForEx = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_ex() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_exposal1;
+    mii.typedata = (DWORD)ExposalData_0[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ExposalData_0[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_ex() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_exposal2;
+    mii.typedata = (DWORD)ExposalData_1[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ExposalData_1[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_ex() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_exposal3;
+    mii.typedata = (DWORD)ExposalData_2[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ExposalData_2[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 5, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_ex() == 3) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_exposal4;
+    mii.typedata = (DWORD)ExposalData_3[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ExposalData_3[i];
+
+    InsertMenuItem(hmnu, 6, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 7, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_ex() == 4) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_exposal5;
+    mii.typedata = (DWORD)ExposalData_4[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ExposalData_4[i];
+
+    InsertMenuItem(hmnu, 8, TRUE, &mii);
+
+    return hmnu;
+}
+//------------录音----------------------------
+static HMENU createpmenufileRECORD()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)record[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)record[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForRe = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_audio() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_recordOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_audio() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_recordON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+//---------时间水印-------------------------
+static HMENU createpmenufileMARK()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)water_mark[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)water_mark[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForMark = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_mark() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_markOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_mark() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_markON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+/*---------------GPS-------------------*/
+static HMENU createpmenufileGPS()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)gps[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)gps[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForMark = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_gps_mark() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_GPSOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_gps_mark() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_GPSON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+#if ENABLE_MD_IN_MENU
+//--------------------移动侦测---------------------
+static HMENU createpmenufileDETECT()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)auto_detect[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)auto_detect[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForDe = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_de() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_detectOFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)OFF[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_video_de() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_detectON;
+    mii.typedata = (DWORD)ON[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)ON[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+#endif
+
+static HMENU createpmenufileMP_photo()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    struct photo_param *param = parameter_get_photo_param();
+    char* MPVed_1M[2] = {" 1280 * 720 ", " 1280 * 720 "};
+    char* MPVed_2M[2] = {" 1920 * 1080 ", " 1920 * 1080 "};
+    char* MPVed_3M[2] = {" 2560 * 1440 ", " 2560 * 1440 "};
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)MP[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MP[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (param->height == 720) ? MF_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_1M_ph;
+    mii.typedata = (DWORD)MPVed_1M[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MPVed_1M[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (param->height == 1080) ? MF_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_2M_ph;
+    mii.typedata = (DWORD)MPVed_2M[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MPVed_2M[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (param->height == 1440) ? MF_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_3M_ph;
+    mii.typedata = (DWORD)MPVed_3M[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MPVed_3M[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    return hmnu;
+}
+//------------清晰度菜单--------
+static HMENU createpmenufileMP()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int cnt = 0;
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)MP[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MP[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_FONTCAMERA;
+    mii.typedata = (DWORD)fontcamera_ui[0];
+    mii.hsubmenu = createpmenufileFONTCAMERA();
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)fontcamera_ui[i];
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_BACKCAMERA;
+    mii.typedata = (DWORD)backcamera_ui[0];
+    mii.hsubmenu = createpmenufileBACKCAMERA();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)backcamera_ui[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_CIFCAMERA;
+    mii.typedata = (DWORD)cifcamera_ui[0];
+    mii.hsubmenu = createpmenufileCIFCamera();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)cifcamera_ui[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    return hmnu;
+}
+
+//-------------录像时长菜单-----------
+static HMENU createpmenufileTIME()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)Record_Time[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Record_Time[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_recodetime() == 60) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_1MIN;
+    mii.typedata = (DWORD)Time_OneMIN[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Time_OneMIN[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_recodetime() == 180) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_3MIN;
+    mii.typedata = (DWORD)Time_TMIN[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Time_TMIN[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_recodetime() == 300) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_5MIN;
+    mii.typedata = (DWORD)Time_FMIN[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Time_FMIN[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+#if 0
+    mii.type = MFT_SEPARATOR; //类型
+    mii.state = 0;
+    mii.id = 0; //ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 5, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_recodetime() == 3) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_OFF;
+    mii.typedata = (DWORD)OFF[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char *)OFF[i];
+
+    InsertMenuItem(hmnu, 6, TRUE, &mii);
+#endif
+
+    return hmnu;
+}
+//-----------------------录像模式菜单-------------------------
+static HMENU createpmenufileCAR()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)Record_Mode[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Record_Mode[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_abmode() == 0) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_CAR1;
+    mii.typedata = (DWORD)Front_Record[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Front_Record[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_abmode() == 1) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_CAR2;
+    mii.typedata = (DWORD)Back_Record[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Back_Record[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_abmode() == 2) ? MFS_CHECKED : MFS_UNCHECKED;
+    mii.id = IDM_CAR3;
+    mii.typedata = (DWORD)Double_Record[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Double_Record[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    return hmnu;
+}
+
+// DEBUG
+static HMENU createpmenufileDEBUG()
+{
+    int i;
+    int cnt = 0;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)debug[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)debug[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    /* FW_UPDATE TEST */
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_DEBUG_FWUPDATE_TEST;
+    mii.typedata = (DWORD)str_fw_update_test[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)str_fw_update_test[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_BOOT;
+    mii.typedata = (DWORD)reboot[0];
+    mii.hsubmenu = createpmenufileREBOOT();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)reboot[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_RECOVERY_DEBUG;
+    mii.typedata = (DWORD)recovery_debug[0];
+    mii.hsubmenu = createpmenufileRECOVERY();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)recovery_debug[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_STANDBY_2;
+    mii.typedata = (DWORD)standby[0];
+    mii.hsubmenu = createpmenufileSTANDBY();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)standby[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_MODE_CHANGE;
+    mii.typedata = (DWORD)mode_change[0];
+    mii.hsubmenu = createpmenufileMODECHANGE();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)mode_change[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_DEBUG_VIDEO;
+    mii.typedata = (DWORD)video_debug[0];
+    mii.hsubmenu = createpmenufileDEBUGVIDEO();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)video_debug[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_BEG_END_VIDEO;
+    mii.typedata = (DWORD)beg_end_video[0];
+    mii.hsubmenu = createpmenufileBEGENDVIDEO();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)beg_end_video[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_DEBUG_PHOTO;
+    mii.typedata = (DWORD)photo_debug[0];
+    mii.hsubmenu = createpmenufileDEBUGPHOTO();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)photo_debug[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_DEBUG_TEMP;
+    mii.typedata = (DWORD)temp_debug[0];
+    mii.hsubmenu = createpmenufileDEBUGTEMP();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)temp_debug[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    add_seperator_line(hmnu, &mii, &cnt);
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_DEBUG_VIDEO_BIT_RATE;
+    mii.typedata = (DWORD)vbit_rate_debug[0];
+    mii.hsubmenu = createpmenufileDEBUGVideoBitRate();
+
+    for (i = 0; i < 2; i++)
+        mii.str[i] = (char*)vbit_rate_debug[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    return hmnu;
+}
+
+//-------------缩时录影间隔时长菜单-----------
+
+#define ADD_CHILD_ITEM(get_func, comp_val, idm_id, item_str) \
+  do { \
+    memset(&mii, 0, sizeof(MENUITEMINFO)); \
+    mii.type = MFT_RADIOCHECK; \
+    mii.state = (get_func() == comp_val) ? MFS_CHECKED : MFS_UNCHECKED; \
+    mii.id = idm_id; \
+    mii.typedata = (DWORD)item_str[0]; \
+    for (i = 0; i < LANGUAGE_NUM; i++) \
+      mii.str[i] = (char*)item_str[i]; \
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii); \
+  } while(0)
+
+static HMENU create_menu_time_lapse()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    int cnt = 0;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)time_lapse[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)time_lapse[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    ADD_CHILD_ITEM(parameter_get_time_lapse_interval, 0,
+                   IDM_TIME_LAPSE_OFF, time_off);
+    add_seperator_line(hmnu, &mii, &cnt);
+    ADD_CHILD_ITEM(parameter_get_time_lapse_interval, 1,
+                   IDM_TIME_LAPSE_INTERNAL_1s, time_one_sec);
+    add_seperator_line(hmnu, &mii, &cnt);
+    ADD_CHILD_ITEM(parameter_get_time_lapse_interval, 5,
+                   IDM_TIME_LAPSE_INTERNAL_5s, time_five_sec);
+    add_seperator_line(hmnu, &mii, &cnt);
+    ADD_CHILD_ITEM(parameter_get_time_lapse_interval, 10,
+                   IDM_TIME_LAPSE_INTERNAL_10s, time_ten_sec);
+    add_seperator_line(hmnu, &mii, &cnt);
+    ADD_CHILD_ITEM(parameter_get_time_lapse_interval, 30,
+                   IDM_TIME_LAPSE_INTERNAL_30s, time_thirty_sec);
+    add_seperator_line(hmnu, &mii, &cnt);
+    ADD_CHILD_ITEM(parameter_get_time_lapse_interval, 60,
+                   IDM_TIME_LAPSE_INTERNAL_60s, time_sixty_sec);
+    return hmnu;
+}
+
+static HMENU createpmenufileVIDEOQUALITY()
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)video_quality[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)video_quality[i];
+
+    hmnu = CreatePopupMenu(&mii);
+    hmnuForVideoQuality = hmnu;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_bit_rate_per_pixel() == VIDEO_QUALITY_HIGH)
+                ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_VIDEO_QUALITY_H;
+    mii.typedata = (DWORD)quality_hig[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)quality_hig[i];
+
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_bit_rate_per_pixel() == VIDEO_QUALITY_MID)
+                ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_VIDEO_QUALITY_M;
+    mii.typedata = (DWORD)quality_mid[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)quality_mid[i];
+
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_RADIOCHECK;
+    mii.state = (parameter_get_bit_rate_per_pixel() == VIDEO_QUALITY_LOW)
+                ? MFS_CHECKED
+                : MFS_UNCHECKED;
+    mii.id = IDM_VIDEO_QUALITY_L;
+    mii.typedata = (DWORD)quality_low[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)quality_low[i];
+
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    return hmnu;
+}
+
+//----------------设置菜单----------------------
+static HMENU createpmenufileSETTING()
+{
+    int i;
+    int cnt = 0;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD)setting[0];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)setting[i];
+
+    hmnu = CreatePopupMenu(&mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_IDC;
+    mii.typedata = (DWORD)DSP_IDC[0];
+    mii.hsubmenu = createpmenufileIDC();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DSP_IDC[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_FLIP;
+    mii.typedata = (DWORD)video_flip[0];
+    mii.hsubmenu = createpmenufileVIDEOFLIP();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)video_flip[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    // debug
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_3DNR;
+    mii.typedata = (DWORD)DSP_3DNR[0];
+    mii.hsubmenu = createpmenufile3DNR();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DSP_3DNR[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_CVBSOUT;
+    mii.typedata = (DWORD)DISP_CVBSOUT[0];
+    mii.hsubmenu = createpmenufileCVBSOUT();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DISP_CVBSOUT[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_ADAS;
+    mii.typedata = (DWORD)DSP_ADAS[0];
+    mii.hsubmenu = createpmenufileADAS();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)DSP_ADAS[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_bright;
+    mii.typedata = (DWORD)WB[0];
+    mii.hsubmenu = createpmenufileWB();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)WB[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_exposal;
+    mii.typedata = (DWORD)exposal[0];
+    mii.hsubmenu = createpmenufileEXPOSAL();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)exposal[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+#if ENABLE_MD_IN_MENU
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_detect;
+    mii.typedata = (DWORD)auto_detect[0];
+    mii.hsubmenu = createpmenufileDETECT();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)auto_detect[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+#endif
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_mark;
+    mii.typedata = (DWORD)water_mark[0];
+    mii.hsubmenu = createpmenufileMARK();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)water_mark[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //gps
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_GPS;
+    mii.typedata = (DWORD)gps[0];
+    mii.hsubmenu = createpmenufileGPS();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)gps[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_record;
+    mii.typedata = (DWORD)record[0];
+    mii.hsubmenu = createpmenufileRECORD();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)record[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    // createpmenufileAUTORECORD
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_AUTORECORD;
+    mii.typedata = (DWORD)auto_record[0];
+    mii.hsubmenu = createpmenufileAUTORECORD();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)auto_record[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_LANGUAGE;
+    mii.typedata = (DWORD)language[0];
+    mii.hsubmenu = createpmenufileLANGUAGE();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)language[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_FREQUENCY;
+    mii.typedata = (DWORD)frequency[0];
+    mii.hsubmenu = createpmenufileFREQUENCY();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)frequency[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //---------------------屏幕自动关闭--
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_AUTOOFFSCREEN;
+    mii.typedata = (DWORD)screenoffset[0];
+    mii.hsubmenu = createpmenufileAUTOOFFSCREEN();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)screenoffset[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //---------------------WIFI开关--
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_WIFI;
+    mii.typedata = (DWORD)wifi[0];
+    mii.hsubmenu = createpmenufileWIFIONOFF();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)wifi[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //---------------------背光亮度--
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_BACKLIGHT;
+    mii.typedata = (DWORD)backlight[0];
+    mii.hsubmenu = createpmenufileBACKLIGHT();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)backlight[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+    //---------usb mode--------------
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDC_SETMODE;
+    mii.typedata = (DWORD)usbmode[0];
+    mii.hsubmenu = createpmenufileUSB();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)usbmode[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //------------Format-------------------
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_FORMAT;
+    mii.typedata = (DWORD)format[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)format[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+    //--------------set date -------------
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_SETDATE;
+    mii.typedata = (DWORD)setdate[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)setdate[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //-----碰撞检测-----
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_COLLISION;
+    mii.typedata = (DWORD)collision[0];
+    mii.hsubmenu = createpmenufileCOLLISION();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)collision[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //-----------------------
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_PARKINGMONITOR;
+    mii.typedata = (DWORD)parking_monitor[0];
+    mii.hsubmenu = createpmenufileLEAVECARREC();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)parking_monitor[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //---------recovery--------------
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_RECOVERY;
+    mii.typedata = (DWORD)recovery[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)recovery[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_VIDEO_QUALITY;
+    mii.typedata = (DWORD)video_quality[0];
+    mii.hsubmenu = createpmenufileVIDEOQUALITY();
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)video_quality[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    /* -------- License plate watermark------------ */
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_LICENSEPLATE_WATERMARK;
+    mii.typedata = (DWORD)license_plate_watermark[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)license_plate_watermark[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    //---------fw ver--------------
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_FWVER;
+    mii.typedata = (DWORD)fw_ver[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)fw_ver[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    /* time lapse setting */
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_timelapse;
+    mii.typedata = (DWORD)time_lapse[0];
+    mii.hsubmenu = create_menu_time_lapse();
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)time_lapse[i];
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    /* Firmware Update */
+    mii.type = MFT_SEPARATOR;
+    mii.state = 0;
+    mii.id = 0;
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.state = 0;
+    mii.id = IDM_SETTING_FWUPDATE;
+    mii.typedata = (DWORD)str_fw_update[0];
+    mii.hsubmenu = 0;
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)str_fw_update[i];
+
+    InsertMenuItem(hmnu, cnt++, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU creatmenu(void)  //创建主
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    //    HDC hdcForFont;
+    //    hdcForFont = GetDC(hMainWndForPlay);
+    hmnu = CreateMenu();
+    hmnuMain = hmnu;
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_BITMAP;  //类型
+    mii.state = 0;
+    mii.id = IDM_ABOUT_MP;  // ID
+    mii.typedata = (DWORD)MP[0];
+    mii.uncheckedbmp = &bmp_menu_mp[0];
+    mii.checkedbmp = &bmp_menu_mp[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MP[i];
+
+    mii.hsubmenu = createpmenufileMP();
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    mii.type = MFT_BITMAP;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_TIME;
+    mii.typedata = (DWORD)Record_Time[0];
+    mii.uncheckedbmp = &bmp_menu_time[0];
+    mii.checkedbmp = &bmp_menu_time[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Record_Time[i];
+
+    mii.hsubmenu = createpmenufileTIME();
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 3, TRUE, &mii);
+
+    mii.type = MFT_BITMAP;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_CAR;
+    mii.typedata = (DWORD)Record_Mode[0];
+    mii.uncheckedbmp = &bmp_menu_car[0];
+    mii.checkedbmp = &bmp_menu_car[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)Record_Mode[i];
+
+    mii.hsubmenu = createpmenufileCAR();
+    InsertMenuItem(hmnu, 4, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 5, TRUE, &mii);
+
+    mii.type = MFT_BITMAP;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_SETTING;
+    mii.typedata = (DWORD)setting[0];
+    mii.uncheckedbmp = &bmp_menu_setting[0];
+    mii.checkedbmp = &bmp_menu_setting[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)setting[i];
+
+    mii.hsubmenu = createpmenufileSETTING();
+    InsertMenuItem(hmnu, 6, TRUE, &mii);
+
+    // debug
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 7, TRUE, &mii);
+
+    mii.type = MFT_BITMAP;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_DEBUG;
+    mii.typedata = (DWORD)debug[0];
+    mii.uncheckedbmp = &png_menu_debug[0];
+    mii.checkedbmp = &png_menu_debug[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)debug[i];
+
+    mii.hsubmenu = createpmenufileDEBUG();
+    InsertMenuItem(hmnu, 8, TRUE, &mii);
+    //
+    return hmnu;
+}
+
+static HMENU creatmenu_photo(void)  //创建主
+{
+    int i;
+    HMENU hmnu;
+    MENUITEMINFO mii;
+    printf("creatmenu_photo\n");
+    hmnu = CreateMenu();
+    hmnuMain = hmnu;
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_BITMAP;  //类型
+    mii.state = 0;
+    mii.id = IDM_ABOUT_MP;  // ID
+    mii.typedata = (DWORD)MP[0];
+    mii.uncheckedbmp = &bmp_menu_mp[0];
+    mii.checkedbmp = &bmp_menu_mp[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)MP[i];
+
+    mii.hsubmenu = createpmenufileMP_photo();
+    InsertMenuItem(hmnu, 0, TRUE, &mii);
+
+    mii.type = MFT_SEPARATOR;  //类型
+    mii.state = 0;
+    mii.id = 0;  // ID
+    mii.typedata = 0;
+    InsertMenuItem(hmnu, 1, TRUE, &mii);
+
+    mii.type = MFT_BITMAP;
+    mii.state = 0;
+    mii.id = IDM_ABOUT_SETTING;
+    mii.typedata = (DWORD)setting[0];
+    mii.uncheckedbmp = &bmp_menu_setting[0];
+    mii.checkedbmp = &bmp_menu_setting[1];
+
+    for (i = 0; i < LANGUAGE_NUM; i++)
+        mii.str[i] = (char*)setting[i];
+
+    mii.hsubmenu = createpmenufileSETTING();
+    InsertMenuItem(hmnu, 2, TRUE, &mii);
+
+    return hmnu;
+}
+
+static HMENU create_rightbutton_menu(void)
+{
+    int i;
+    HMENU hMenu;
+    MENUITEMINFO mii;
+    char* msg[] = {open_, copy, delete_, rename, properties_};
+
+    memset(&mii, 0, sizeof(MENUITEMINFO));
+    mii.type = MFT_STRING;
+    mii.id = 0;
+    mii.typedata = (DWORD) "File";
+
+    hMenu = CreatePopupMenu(&mii);
+
+    for (i = 0; i < 5; i++) {
+        memset(&mii, 0, sizeof(MENUITEMINFO));
+        mii.type = MFT_STRING;
+        mii.id = IDM_FILE + i;
+        mii.state = 0;
+        mii.typedata = (DWORD)msg[i];
+        InsertMenuItem(hMenu, i, TRUE, &mii);
+    }
+
+    return hMenu;
+    // return StripPopupHead(hMenu);
+}
+
+void lv_notify_process(HWND hwnd, int id, int code, DWORD addData)
+{
+    if (code == LVN_KEYDOWN) {
+        PLVNM_KEYDOWN down;
+        int key;
+
+        down = (PLVNM_KEYDOWN)addData;
+        key = LOWORD(down->wParam);
+
+        if (key == SCANCODE_REMOVE) {
+            HLVITEM hlvi;
+            hlvi = SendMessage(hwnd, LVM_GETSELECTEDITEM, 0, 0);
+            if (hlvi) {
+                if (MessageBox(hMainWnd, are_you_really_want_to_delete_this_file,
+                               warning, MB_YESNO | MB_DEFBUTTON2) == IDYES) {
+                    // not really delete yet.
+                    SendMessage(hwnd, LVM_DELITEM, 0, hlvi);
+                }
+            }
+        }
+        if (key == SCANCODE_ENTER) {
+        }
+    }
+    if (code == LVN_ITEMRUP) {
+        PLVNM_ITEMRUP up;
+        int x, y;
+
+        up = (PLVNM_ITEMRUP)addData;
+        x = LOSWORD(up->lParam);
+        y = HISWORD(up->lParam);
+
+        ClientToScreen(explorer_wnd, &x, &y);
+
+        TrackPopupMenu(GetPopupSubMenu(explorer_menu),
+                       TPM_LEFTALIGN | TPM_LEFTBUTTON, x, y, hMainWnd);
+    }
+    if (code == LVN_ITEMDBCLK) {
+        HLVITEM hlvi = SendMessage(hwnd, LVM_GETSELECTEDITEM, 0, 0);
+        if (hlvi > 0) {
+            if (MessageBox(hMainWnd, Are_you_really_want_to_open_this_file, Question,
+                           MB_YESNO) == IDYES) {
+                MessageBox(hMainWnd, "Me too.", "Sorry", MB_OK);
+            }
+        }
+    }
+}
+
+static void initrec(HWND hWnd)
+{
+    memset(&g_adas_output, 0, sizeof(g_adas_output));
+
+    if (SetMode != MODE_PHOTO) {
+        api_video_init(VIDEO_MODE_REC);
+    } else {
+        api_video_init(VIDEO_MODE_PHOTO);
+    }
+
+    InvalidateRect(hWnd, NULL, FALSE);
+}
+
+static void deinitrec(HWND hWnd)
+{
+    api_video_deinit();
+}
+
+void startplayvideo(HWND hWnd, char* filename)
+{
+    printf("%s filename = %s\n", __func__, filename);
+    changemode(hWnd, MODE_PLAY);
+    snprintf(testpath, sizeof(testpath), "%s", filename);
+    videoplay_init(filename);
+}
+
+void exitplayvideo(HWND hWnd)
+{
+    videoplay_deinit();
+    changemode(hWnd, MODE_PREVIEW);
+    video_play_state = 0;
+    if (api_get_sd_mount_state() != SD_STATE_IN) {
+        exitvideopreview();
+        /*
+        if (explorer_path == 0)
+                explorer_path = calloc(1, 256);
+        sprintf(explorer_path, "%s", SDCARD_PATH);
+        explorer_update(explorer_wnd);
+        */
+    }
+    InvalidateRect(hWnd, NULL, FALSE);
+}
+
+int explorer_getfiletype(char* filename)
+{
+    int type = FILE_TYPE_UNKNOW;
+    char* ext_name;
+    if (!filename || filename[0] == '.') {
+        return type;
+    }
+    ext_name = strrchr(filename, '.');
+    if (ext_name) {
+        ext_name++;
+
+        if (strcmp(ext_name, "mp4") == 0) {
+            type = FILE_TYPE_VIDEO;
+        } else if (strcmp(ext_name, "jpg") == 0) {
+            type = FILE_TYPE_PIC;
+        }
+    }
+
+    return type;
+}
+
+static int explorer_update(HWND hWnd)
+{
+    printf("%s 1\n", __func__);
+    explorer_update_reupdate = 1;
+    printf("%s 2\n", __func__);
+
+    return 0;
+}
+
+int explorer_enter(HWND hWnd)
+{
+    HLVITEM hItemSelected;
+    LVITEM lvItem;
+
+    hItemSelected = SendMessage(explorer_wnd, LVM_GETSELECTEDITEM, 0, 0);
+    SendMessage(explorer_wnd, LVM_GETITEM, hItemSelected, (LPARAM)&lvItem);
+    if (lvItem.itemData) {
+        if (lvItem.dwFlags) {
+            if (strcmp((char*)lvItem.itemData, ".") == 0) {
+                sprintf(explorer_path, "%s", SDCARD_PATH);
+            } else if (strcmp((char*)lvItem.itemData, "..") == 0) {
+                char* seek = strrchr(explorer_path, '/');
+                if (strcmp(explorer_path, SDCARD_PATH) > 0) {
+                    explorer_path[seek - explorer_path] = 0;
+                }
+            } else {
+                strcat(explorer_path, "/");
+                strcat(explorer_path, (const char *)lvItem.itemData);
+            }
+            explorer_update(explorer_wnd);
+        } else {
+            int filetype = explorer_getfiletype((char*)lvItem.itemData);
+            if (filetype == FILE_TYPE_VIDEO || filetype == FILE_TYPE_PIC) {
+                // char file[128];
+                snprintf(testpath, sizeof(testpath), "%s/%s", explorer_path,
+                         (char*)lvItem.itemData);
+                test_replay = 1;
+                startplayvideo(hWnd, testpath);
+            }
+        }
+    }
+
+    return 0;
+}
+
+int explorer_back(HWND hWnd)
+{
+    char* seek = strrchr(explorer_path, '/');
+
+    if (strcmp(explorer_path, SDCARD_PATH) > 0) {
+        explorer_path[seek - explorer_path] = 0;
+    }
+
+    explorer_update(explorer_wnd);
+
+    return 0;
+}
+
+int explorer_filedelete(HWND hWnd)
+{
+    HLVITEM hItemSelected;
+    LVITEM lvItem;
+    int mesg = 0;
+    hItemSelected = SendMessage(explorer_wnd, LVM_GETSELECTEDITEM, 0, 0);
+    SendMessage(explorer_wnd, LVM_GETITEM, hItemSelected, (LPARAM)&lvItem);
+
+    if (lvItem.dwFlags == 0) {
+        if (lvItem.itemData) {
+            if (parameter_get_video_lan() == 1)
+                mesg = MessageBox(explorer_wnd, "删除此视频?", "提示", MB_YESNO | MB_DEFBUTTON2);
+            else if (parameter_get_video_lan() == 0)
+                mesg =
+                    MessageBox(explorer_wnd, "Delete this video ?", "Prompt", MB_YESNO | MB_DEFBUTTON2);
+            if (mesg == IDYES) {
+                // char file[256];
+                // sprintf(file, "%s/%s", explorer_path, lvItem.itemData);
+                // printf("file = %s\n", file);
+                // fs_manage_remove(explorer_path, (char *)lvItem.itemData);
+                SendMessage(explorer_wnd, LVM_DELITEM, 0, (LPARAM)hItemSelected);
+                // remove(file);
+            }
+        }
+    }
+
+    return 0;
+}
+
+void* explorer_update_thread(void* arg)
+{
+    LVSUBITEM subdata;
+    LVITEM item;
+    HWND hWnd = (HWND)arg;
+
+    struct file_list* list;
+    while (explorer_update_run) {
+        if (explorer_update_reupdate == 0) {
+            usleep(10000);
+        } else {
+            int i = 0;
+            explorer_update_reupdate = 0;
+            SendMessage(hWnd, LVM_DELALLITEM, 0, 0);
+            // printf("%s 1, explorer_path = %s\n", __func__, explorer_path);
+            list = fs_manage_getmediafilelist();
+            if (list) {
+                struct file_node* node_tmp;
+
+                node_tmp = list->folder_tail;
+                while (node_tmp && explorer_update_run && !explorer_update_reupdate) {
+                    // printf("%s i =%d\n", __func__, i);
+                    item.itemData = (DWORD)strdup(node_tmp->name);
+                    item.nItem = i;
+                    item.nItemHeight = 28;
+                    item.dwFlags = LVIF_FOLD;
+                    SendMessage(hWnd, LVM_ADDITEM, 0, (LPARAM)&item);
+
+                    subdata.nItem = i;
+
+                    subdata.subItem = 0;
+                    subdata.flags = 0;
+                    subdata.pszText = node_tmp->name;
+                    subdata.flags = LVFLAG_BITMAP;
+
+                    if ((strcmp(node_tmp->name, ".") == 0) ||
+                        (strcmp(node_tmp->name, "..") == 0)) {
+                        subdata.image = (DWORD)&back_bmap;
+                    } else {
+                        subdata.image = (DWORD)&folder_bmap;
+                    }
+
+                    subdata.nTextColor = PIXEL_blue;
+                    SendMessage(hWnd, LVM_FILLSUBITEM, 0, (LPARAM)&subdata);
+
+                    i++;
+                    node_tmp = node_tmp->pre;
+                    if ((i % 500) == 0)
+                        usleep(10000);
+                }
+
+                node_tmp = list->file_tail;
+                while (node_tmp && explorer_update_run && !explorer_update_reupdate) {
+                    int filetype;
+                    // printf("%s i =%d\n", __func__, i);
+                    item.itemData = (DWORD)strdup(node_tmp->name);
+                    item.nItem = i;
+                    item.nItemHeight = 28;
+                    item.dwFlags = 0;
+                    SendMessage(hWnd, LVM_ADDITEM, 0, (LPARAM)&item);
+
+                    subdata.nItem = i;
+
+                    subdata.subItem = 0;
+                    subdata.flags = 0;
+                    subdata.pszText = node_tmp->name;
+                    subdata.flags = LVFLAG_BITMAP;
+                    filetype = explorer_getfiletype(node_tmp->name);
+
+                    subdata.nTextColor = PIXEL_black;
+                    subdata.image = (DWORD)&filetype_bmap[filetype];
+
+                    SendMessage(hWnd, LVM_FILLSUBITEM, 0, (LPARAM)&subdata);
+                    i++;
+                    node_tmp = node_tmp->pre;
+                    if ((i % 500) == 0)
+                        usleep(10000);
+                }
+                fs_manage_free_filelist(&list);
+                printf("add file finish\n");
+            }
+        }
+    }
+    printf("%s out\n", __func__);
+    pthread_exit(NULL);
+}
+
+void create_explorer(HWND hWnd)
+{
+    LVCOLUMN s1;
+    int width;
+
+    explorer_menu = create_rightbutton_menu();
+
+    width = g_rcScr.right - g_rcScr.left;
+
+    explorer_wnd = CreateWindowEx(
+                       CTRL_LISTVIEW, "List View",
+                       WS_VISIBLE | WS_VSCROLL | WS_HSCROLL | WS_BORDER, WS_EX_NONE,
+                       IDC_LISTVIEW, g_rcScr.left, g_rcScr.top + TOPBK_IMG_H, width,
+                       g_rcScr.bottom - TOPBK_IMG_H, hWnd, 0);
+
+    SetNotificationCallback(explorer_wnd, lv_notify_process);
+
+    s1.nCols = 0;
+    s1.pszHeadText = File_name;
+    s1.width = width - 10;
+    s1.pfnCompare = NULL;
+    s1.colFlags = 0;
+    SendMessage(explorer_wnd, LVM_ADDCOLUMN, 0, (LPARAM)&s1);
+
+    if (explorer_path == 0)
+        explorer_path = calloc(1, 256);
+    sprintf(explorer_path, "%s", SDCARD_PATH);
+    explorer_update_reupdate = 0;
+    explorer_update_run = 1;
+    if (pthread_create(&explorer_update_tid, NULL, explorer_update_thread,
+                       (void*)explorer_wnd)) {
+        printf("%s pthread_create err\n", __func__);
+    }
+    explorer_update(explorer_wnd);
+
+    SetFocusChild(explorer_wnd);
+}
+
+void destroy_explorer(void)
+{
+    explorer_update_run = 0;
+    if (explorer_update_tid)
+        pthread_join(explorer_update_tid, NULL);
+    explorer_update_tid = 0;
+    DestroyMenu(explorer_menu);
+    DestroyWindow(explorer_wnd);
+    if (explorer_path) {
+        free(explorer_path);
+        explorer_path = 0;
+    }
+    explorer_menu = 0;
+    explorer_wnd = 0;
+}
+
+void popmenu(HWND hWnd)
+{
+    SendAsyncMessage(hWnd, MSG_MENUBARPAINT, 0, 0);
+    TrackMenuBar(hWnd, 0);
+}
+
+void videopreview_getfilename(char* filename, struct file_node* filenode)
+{
+    char *filepath = NULL;
+
+    if (filenode == NULL)
+        return;
+
+    filepath = fs_storage_folder_get_bynode(filenode);
+    snprintf(filename, FILENAME_LEN, "%s/%s", filepath, filenode->name);
+
+    return;
+}
+
+void videopreview_show_decode(char* previewname,
+                              char* videoname,
+                              char* filename)
+{
+    videoplay = 0;
+    if (previewname == NULL)
+        return;
+
+    preview_isvideo = 0;
+    sprintf(previewname, "%s(%d/%d)", videoname, currentfilenum, totalfilenum);
+    printf("%s file = %s, previewname = %s\n", __func__, filename, previewname);
+    if (strstr(previewname, ".mp4")) {
+        printf("videoplay_decode_one_frame(%s)\n", filename);
+        preview_isvideo = 1;
+        videoplay = videoplay_decode_one_frame(filename);
+        printf("videoplay= %d\n", videoplay);
+        if (videoplay != 0) {
+            printf("videoplay==-1\n");
+            if (parameter_get_video_lan() == 1)
+                MessageBox(hwndforpre, "视频错误!!!", "警告!!!", MB_OK);
+            else if (parameter_get_video_lan() == 0)
+                MessageBox(hwndforpre, "video error !!!", "Warning!!!", MB_OK);
+        }
+    } else if (strstr(previewname, ".jpg")) {
+        printf("videoplay_decode_jpeg(%s)\n", filename);
+        videoplay_decode_jpeg(filename);
+    }
+
+    return;
+}
+
+void entervideopreview(void)
+{
+    char filename[FILENAME_LEN];
+
+    totalfilenum = 0;
+    currentfilenum = 0;
+    preview_isvideo = 0;
+    videoplay = 0;
+    printf("%s\n", __func__);
+
+    if (api_get_sd_mount_state() != SD_STATE_IN) {
+        snprintf(previewname, sizeof(previewname), "%s", "no sd card");
+        sprintf(previewname, "%s", "no sd card");
+        return;
+    }
+    char cmd[] = "sync\0";
+    runapp(cmd);  // sync when showing
+    filelist = fs_manage_getmediafilelist();
+    if (filelist == NULL) {
+        snprintf(previewname, sizeof(previewname), "(%d/%d)", currentfilenum, totalfilenum);
+        return;
+    }
+    currentfile = filelist->file_tail;
+
+    if (currentfile == NULL) {
+        snprintf(previewname, sizeof(previewname), "(%d/%d)", currentfilenum, totalfilenum);
+        return;
+    }
+    totalfilenum = filelist->filenum;
+    if (totalfilenum)
+        currentfilenum = 1;
+
+    currentfile = filelist->file_tail;
+
+    videopreview_getfilename(filename, currentfile);
+    videopreview_show_decode(previewname, currentfile->name, filename);
+
+    return;
+}
+
+void videopreview_refresh(HWND hWnd)
+{
+    char filename[FILENAME_LEN];
+
+    printf("%s\n", __func__);
+    if (currentfile == NULL)
+        return;
+
+    videopreview_getfilename(filename, currentfile);
+    videopreview_show_decode(previewname, currentfile->name, filename);
+    InvalidateRect(hWnd, NULL, FALSE);
+
+    return;
+}
+
+void videopreview_next(HWND hWnd)
+{
+    char filename[FILENAME_LEN];
+
+    printf("%s\n", __func__);
+    if (currentfile == NULL)
+        return;
+
+    if (currentfile->pre == NULL) {
+        currentfile = filelist->file_tail;
+        if (currentfile == NULL)
+            return;
+        currentfilenum = 1;
+    } else {
+        currentfile = currentfile->pre;
+        currentfilenum++;
+    }
+    videopreview_getfilename(filename, currentfile);
+    videopreview_show_decode(previewname, currentfile->name, filename);
+    InvalidateRect(hWnd, NULL, FALSE);
+
+    return;
+}
+
+void videopreview_pre(HWND hWnd)
+{
+    char filename[FILENAME_LEN];
+    printf("%s\n", __func__);
+    if (currentfile == NULL)
+        return;
+
+    if (currentfile->next == NULL) {
+        currentfile = filelist->file_head;
+        if (currentfile == NULL)
+            return;
+        currentfilenum = totalfilenum;
+    } else {
+        currentfile = currentfile->next;
+        currentfilenum--;
+    }
+    if (currentfilenum < 0)
+        currentfilenum = 0;
+
+    videopreview_getfilename(filename, currentfile);
+    videopreview_show_decode(previewname, currentfile->name, filename);
+    InvalidateRect(hWnd, NULL, FALSE);
+
+    return;
+}
+
+void videopreview_play(HWND hWnd)
+{
+    char filename[FILENAME_LEN];
+    printf("%s\n", __func__);
+    if (currentfile == NULL)
+        return;
+
+    videopreview_getfilename(filename, currentfile);
+
+    if (strstr(currentfile->name, ".mp4")) {
+        printf("videoplay_decode_one_frame(%s)\n", filename);
+        startplayvideo(hWnd, filename);
+    } else {
+        if (parameter_get_debug_video() == 1)
+            video_time = VIDEO_TIME - 1;
+        if (parameter_get_debug_modechange() == 1) {
+            // modechange_pre_flage==1;
+            modechange_time = MODECHANGE_TIME - 1;
+        }
+    }
+}
+
+int videopreview_delete(HWND hWnd)
+{
+    char filename[FILENAME_LEN];
+    struct file_node* current_filenode;
+    int mesg = 0;
+
+    if (currentfile == NULL)
+        return 0;
+
+    if (parameter_get_video_lan() == 1)
+        mesg = MessageBox(hWnd, "删除此视频?", "提示", MB_YESNO | MB_DEFBUTTON2);
+    else if (parameter_get_video_lan() == 0)
+        mesg = MessageBox(hWnd, "Delete this video ?", "Prompt", MB_YESNO | MB_DEFBUTTON2);
+    if (mesg == IDYES) {
+        // char file[256];
+        // sprintf(file, "%s/%s", explorer_path, lvItem.itemData);
+        // printf("file = %s\n", file);
+        current_filenode = currentfile;
+        if (currentfile->pre == NULL) {
+            currentfile = currentfile->next;
+            currentfilenum--;
+        } else {
+            currentfile = currentfile->pre;
+        }
+
+        totalfilenum--;
+
+        videopreview_getfilename(filename, current_filenode);
+        fs_storage_remove(filename, 0);
+        videoplay = 0;
+        preview_isvideo = 0;
+
+        if (currentfile == NULL) {
+            snprintf(previewname, sizeof(previewname), "(%d/%d)", currentfilenum, totalfilenum);
+            printf("%spreviewname = %s\n", __func__, previewname);
+            videoplay_set_fb_black();
+            goto out;
+        }
+        videopreview_getfilename(filename, currentfile);
+        videopreview_show_decode(previewname, currentfile->name, filename);
+    out:
+        InvalidateRect(hWnd, NULL, FALSE);
+        return 0;
+    }
+
+    return 0;
+}
+
+void exitvideopreview(void)
+{
+    printf("%s\n", __func__);
+    fs_manage_free_mediafilelist();
+    filelist = 0;
+    currentfile = 0;
+    totalfilenum = 0;
+    currentfilenum = 0;
+    preview_isvideo = 0;
+    videoplay = 0;
+
+    if (api_get_sd_mount_state() != SD_STATE_IN) {
+        snprintf(previewname, sizeof(previewname), "%s", "no sd card");
+    }
+    videoplay_set_fb_black();
+}
+
+void changemode(HWND hWnd, int mode)
+{
+    RECT msg_rcTopBk = {TOPBK_IMG_X, TOPBK_IMG_Y, TOPBK_IMG_X + g_rcScr.right,
+                        TOPBK_IMG_Y + TOPBK_IMG_H
+                       };
+    switch (SetMode) {
+    case MODE_PHOTO:
+    case MODE_RECORDING:
+        if (mode == MODE_EXPLORER) {
+            api_video_deinit();
+            SetMode = mode;
+            DestroyAllMenu();
+            create_explorer(hWnd);
+            InvalidateRect(hWnd, &msg_rcTopBk, FALSE);
+        } else if (mode == MODE_USBDIALOG) {
+            api_video_deinit();
+            SetMode = mode;
+            DestroyAllMenu();
+        } else if (mode == MODE_PREVIEW) {
+            api_video_deinit();
+            SetMode = mode;
+            DestroyAllMenu();
+            entervideopreview();
+            InvalidateRect(hWnd, NULL, FALSE);
+        } else if (mode == MODE_RECORDING || mode == MODE_PHOTO) {
+            pthread_mutex_lock(&set_mutex);
+            api_video_deinit();
+            SetMode = mode;
+            initrec(hWnd);
+            DestroyAllMenu();
+            CreateMainWindowMenu(hWnd, creatmenu_photo());
+            pthread_mutex_unlock(&set_mutex);
+        } else if (mode == MODE_SUSPEND) {
+            deinitrec(hWnd);
+            video_record_deinit();
+            DestroyAllMenu();
+            rkfb_screen_off();
+            fs_manage_sdcard_unmount();
+            runapp("echo mem > /sys/power/state");
+
+            pthread_mutex_lock(&set_mutex);
+            rkfb_screen_on();
+            CreateMainWindowMenu(hWnd, creatmenu());
+            initrec(hWnd);
+            InvalidateRect(hWnd, &msg_rcTopBk, FALSE);
+            pthread_mutex_unlock(&set_mutex);
+        }
+        break;
+    case MODE_EXPLORER:
+        if (mode == MODE_RECORDING || mode == MODE_PHOTO) {
+            pthread_mutex_lock(&set_mutex);
+            SetMode = mode;
+            destroy_explorer();
+            CreateMainWindowMenu(hWnd, creatmenu());
+            initrec(hWnd);
+
+            InvalidateRect(hWnd, &msg_rcTopBk, FALSE);
+            pthread_mutex_unlock(&set_mutex);
+        } else if (mode == MODE_PLAY) {
+            SetMode = mode;
+            ShowWindow(explorer_wnd, SW_HIDE);
+            InvalidateRect(hWnd, NULL, FALSE);
+        } else if (mode == MODE_USBDIALOG) {
+            SetMode = mode;
+            destroy_explorer();
+        }
+        break;
+    case MODE_PLAY:
+        if (mode == MODE_EXPLORER) {
+            ShowWindow(explorer_wnd, SW_SHOW);
+            SetFocusChild(explorer_wnd);
+            SetMode = mode;
+        } else if (mode == MODE_USBDIALOG) {
+            test_replay = 0;
+            videoplay_exit();
+            SetMode = mode;
+            exitvideopreview();
+        } else if (mode == MODE_PREVIEW) {
+            SetMode = mode;
+            InvalidateRect(hWnd, NULL, FALSE);
+        } else if (mode == MODE_SUSPEND) {
+            test_replay = 0;
+            videoplay_exit();
+            SetMode = mode;
+            exitvideopreview();
+            rkfb_screen_off();
+            fs_manage_sdcard_unmount();
+            runapp("echo mem > /sys/power/state");
+            rkfb_screen_on();
+            SetMode = MODE_PREVIEW;
+            InvalidateRect(hWnd, NULL, FALSE);
+        }
+        break;
+    case MODE_USBDIALOG:
+        if (mode == MODE_RECORDING || mode == MODE_PHOTO) {
+            pthread_mutex_lock(&set_mutex);
+            SetMode = mode;
+            CreateMainWindowMenu(hWnd, creatmenu());
+            initrec(hWnd);
+
+            InvalidateRect(hWnd, &msg_rcTopBk, FALSE);
+            pthread_mutex_unlock(&set_mutex);
+        } else if (mode == MODE_USBCONNECTION) {
+            SetMode = mode;
+            InvalidateRect(hWnd, NULL, TRUE);
+        }
+        break;
+    case MODE_USBCONNECTION:
+        if (mode == MODE_RECORDING || mode == MODE_PHOTO) {
+            pthread_mutex_lock(&set_mutex);
+            SetMode = mode;
+            CreateMainWindowMenu(hWnd, creatmenu());
+            initrec(hWnd);
+            pthread_mutex_unlock(&set_mutex);
+        }
+        break;
+    case MODE_PREVIEW:
+        if (mode == MODE_EXPLORER) {
+            exitvideopreview();
+            SetMode = mode;
+            create_explorer(hWnd);
+            InvalidateRect(hWnd, &msg_rcTopBk, FALSE);
+        } else if (mode == MODE_PLAY) {
+            SetMode = mode;
+            InvalidateRect(hWnd, NULL, FALSE);
+        } else if (mode == MODE_RECORDING || mode == MODE_PHOTO) {
+            pthread_mutex_lock(&set_mutex);
+            exitvideopreview();
+            SetMode = mode;
+            CreateMainWindowMenu(hWnd, creatmenu());
+            initrec(hWnd);
+            pthread_mutex_unlock(&set_mutex);
+        } else if (mode == MODE_SUSPEND) {
+            fs_manage_deinit();
+            fs_manage_sdcard_unmount();
+            exitvideopreview();
+            rkfb_screen_off();
+            runapp("echo mem > /sys/power/state");
+            rkfb_screen_on();
+            entervideopreview();
+            InvalidateRect(hWnd, NULL, FALSE);
+        }
+        break;
+    }
+}
+void loadingWaitBmp(HWND hWnd)
+{
+    ANIMATION* anim = CreateAnimationFromGIF89aFile(
+                          HDC_SCREEN, "/usr/local/share/minigui/res/images/waitfor2.gif");
+    if (anim == NULL) {
+        printf("anim=NULL\n");
+        return;
+    }
+    key_lock = 1;
+    SetWindowAdditionalData(hWnd, (DWORD)anim);
+    CreateWindow(CTRL_ANIMATION, "", WS_VISIBLE | ANS_AUTOLOOP, 190,
+                 (WIN_W - 98) / 2, (WIN_H - 98) / 2, 98, 98, hWnd, (DWORD)anim);
+    SendMessage(GetDlgItem(hWnd, 190), ANM_STARTPLAY, 0, 0);
+
+    return;
+}
+
+void unloadingWaitBmp(HWND hWnd)
+{
+    DWORD win_additionanl_data = GetWindowAdditionalData(hWnd);
+    if (win_additionanl_data) {
+        DestroyAnimation((ANIMATION*)win_additionanl_data, TRUE);
+        DestroyAllControls(hWnd);
+    }
+    key_lock = 0;
+}
+
+static void proc_MSG_USBCHAGE(HWND hWnd,
+                              int message,
+                              WPARAM wParam,
+                              LPARAM lParam)
+{
+
+}
+
+static void proc_record_SCANCODE_CURSORBLOCKRIGHT(HWND hWnd)
+{
+#ifdef USE_CIF_CAMERA
+    short inputid = parameter_get_cif_inputid();
+    inputid = (inputid == 0) ? 1 : 0;
+    parameter_save_cif_inputid(inputid);
+    api_video_reinit();
+#endif
+
+    video_record_inc_nv12_raw_cnt();
+}
+
+static void ui_takephoto(HWND hWnd)
+{
+    if (api_get_sd_mount_state() == SD_STATE_IN && !takephoto) {
+        takephoto = true;
+        audio_sync_play(capture_sound_file);
+        loadingWaitBmp(hWnd);
+        if (video_record_takephoto(1) == -1) {
+            printf("No input video devices!\n");
+            unloadingWaitBmp(hWnd);
+            takephoto = false;
+        }
+    }
+}
+
+static void proc_MSG_SDMOUNTFAIL(HWND hWnd)
+{
+}
+
+static void proc_MSG_FS_INITFAIL(HWND hWnd, int param)
+{
+    int mesg = 0;
+    printf("FS_INITFAIL\n");
+    // no space
+    if (param == -1) {
+        if (parameter_get_video_lan() == 1)
+            mesg = MessageBox(hWnd, "sd卡剩余空间不足\n是否格式化sd卡?", "警告!!!", MB_YESNO | MB_DEFBUTTON2);
+        else if (parameter_get_video_lan() == 0)
+            mesg = MessageBox(hWnd, "sd card no enough free space ,\nformat the sd card ?",
+                              "Warning!!!", MB_YESNO);
+        // init fail
+    } else if (param == -2) {
+        if (parameter_get_video_lan() == 1)
+            mesg = MessageBox(hWnd, "sd卡初始化异常\n是否格式化sd卡?", "警告!!!", MB_YESNO | MB_DEFBUTTON2);
+        else if (parameter_get_video_lan() == 0)
+            mesg = MessageBox(hWnd, "sd card init fail ,\nformat the sd card ?",
+                              "Warning!!!", MB_YESNO);
+        // else error
+    } else {
+        if (parameter_get_video_lan() == 1)
+            MessageBox(hWnd, "sd卡初始化异常", "警告!!!", MB_OK);
+        else if (parameter_get_video_lan() == 0)
+            MessageBox(hWnd, "sd card init fail", "Warning!!!", MB_OK);
+        return;
+    }
+
+    if (mesg == IDYES) {
+        api_sdcard_format(0);
+    }
+
+    return;
+}
+
+static int check_fwudpate_test(void)
+{
+    static int need_check = 1;
+
+    if (need_check) {
+        if (parameter_flash_get_flashed() == BOOT_FWUPDATE_TEST_DOING)
+            return 1;
+
+        /*
+         * If boot mode is not BOOT_FWUPDATE_TEST_DOING when startup,
+         * we don't need to check flash flag via kernel ioctl always.
+         */
+        need_check = 0;
+    }
+
+    return 0;
+}
+
+static void ui_timer_debug_process(HWND hWnd)
+{
+    if (parameter_get_debug_reboot() == 1) {
+        reboot_time++;
+        printf("--------REBOOT_TIME1-------\n");
+        if (reboot_time == REBOOT_TIME) {
+            parameter_get_reboot_cnt();
+            reboot_time = 0;
+            printf("--------REBOOT_TIME-------\n");
+            parameter_save_reboot_cnt();
+            power_reboot();
+        }
+    }
+    if (parameter_get_debug_recovery() == 1) {
+        recovery_time++;
+        if (recovery_time == RECOVERY_TIME) {
+            recovery_time = 0;
+            parameter_recover();
+            parameter_save_debug_recovery(1);
+        }
+    }
+    if (parameter_get_debug_modechange() == 1) {
+        modechange_time++;
+        if (SetMode == MODE_RECORDING) {
+            if (api_video_get_record_state() == VIDEO_STATE_PREVIEW) {
+                if (api_get_sd_mount_state() == SD_STATE_IN) {
+                    api_start_rec();
+                }
+            } else if ((api_video_get_record_state() == VIDEO_STATE_RECORD) && modechange_time == MODECHANGE_TIME) {
+                api_stop_rec();
+            }
+            if (modechange_time == MODECHANGE_TIME) {
+                modechange_time = 0;
+                changemode(hWnd, MODE_PREVIEW);
+            }
+        } else if (SetMode == MODE_PREVIEW) {
+            /*
+            if(modechange_time ==1) {
+              if(videoplay!=0) {
+                //  printf("videoplay==-1\n");
+                if(parameter_get_video_lan()==1) {
+                  modechange_time=MODECHANGE_TIME-1;
+                } else if(parameter_get_video_lan()==0) {
+                  modechange_time=MODECHANGE_TIME-1;
+                }
+              } else {
+                videopreview_play(hWnd);
+              }
+            }*/
+            if (modechange_time == MODECHANGE_TIME /*&&modechange_pre_flage==1*/) {
+                //modechange_pre_flage =0 ;
+                modechange_time = 0;
+                changemode(hWnd, MODE_RECORDING);
+            }
+        }
+    }
+
+    if (parameter_get_debug_standby()) {
+        standby_time++;
+        if (standby_time == STANDBY_TIME) {
+            runapp("echo +10 > /sys/class/rtc/rtc0/wakealarm");
+            changemode(hWnd, MODE_SUSPEND);
+            standby_time = 0;
+        }
+    }
+
+    if (parameter_get_debug_video() == 1) {
+        if (SetMode == MODE_PREVIEW) {
+            if (video_time == 0) {
+                if (videoplay != 0) {
+                    //  printf("videoplay==-1\n");
+                    if (parameter_get_video_lan() == 1) {
+                        video_time = 0;
+                        videopreview_next(hWnd);
+                    } else if (parameter_get_video_lan() == 0) {
+                        video_time = 0;
+                        videopreview_next(hWnd);
+                    }
+                } else {
+                    video_time = 2;
+                    videopreview_play(hWnd);
+                }
+            }
+
+            if (video_time == 1) {
+                video_time = 0;
+                videopreview_next(hWnd);
+            }
+        }
+    }
+    if (parameter_get_debug_beg_end_video() == 1) {
+        if (SetMode == MODE_RECORDING) {
+            beg_end_video_time++;
+            if (beg_end_video_time == 1) {
+                if (api_video_get_record_state() == VIDEO_STATE_PREVIEW) {
+                    if (api_get_sd_mount_state() == SD_STATE_IN) {
+                        api_start_rec();
+                    }
+                }
+            }
+            if (beg_end_video_time == BEG_END_VIDEO_TIME) {
+                if (api_video_get_record_state() == VIDEO_STATE_RECORD) {
+                    api_stop_rec();
+                }
+                beg_end_video_time = 0;
+            }
+        }
+    }
+    if (parameter_get_debug_photo() == 1) {
+        if (SetMode == MODE_RECORDING) {
+            photo_time++;
+            if (photo_time == PHOTO_TIME) {
+                ui_takephoto(hWnd);
+                photo_time = 0;
+            }
+        }
+    }
+
+    /*
+     * FW_UPDATE_TEST automatically
+     *
+     * Check boot is BOOT_FWUPDATE_TEST_DOING
+     */
+    if (check_fwudpate_test()) {
+        fwupdate_test_time++;
+        if (fwupdate_test_time >= FWUPDATE_TEST_TIME) {
+            unsigned int fwupdate_cnt = parameter_flash_get_fwupdate_count();
+
+            printf("FW_UPDATE_TEST has passed (%d) cycles, and reboot now\n",
+                   fwupdate_cnt);
+
+            /* The BOOT_FWUPDATE_TEST_CONTINUE which is defined in init_hook.h */
+            parameter_flash_set_flashed(BOOT_FWUPDATE_TEST_CONTINUE);
+            fwupdate_test_time = 0;
+            power_reboot();
+        }
+    }
+}
+
+static void PaintHorizontalBaseline(HDC hdc, DWORD color, int bold, int hight)
+{
+    SetPenColor(hdc, color);
+
+    MoveTo(hdc, 0, hight);
+    LineTo(hdc, WIN_W, hight);
+    if (bold) {
+        MoveTo(hdc, 0, hight + 1);
+        LineTo(hdc, WIN_W, hight + 1);
+        MoveTo(hdc, 0, hight - 1);
+        LineTo(hdc, WIN_W, hight - 1);
+    }
+}
+
+static void PaintADAS(HDC hdc)
+{
+    char setting_info[20];
+
+    if (adasflagtooff == 1) {
+        printf("adasflagtooff\n");
+        SetBrushColor(hdc, bkcolor);
+        SetBkColor(hdc, bkcolor);
+        FillBox(hdc, adas_X, adas_Y, adas_W, adas_H);
+        adasflagtooff = 0;
+    }
+
+    if (SetMode == MODE_RECORDING && parameter_get_video_adas()
+        && (adasFlag & (ADASFLAG_SETTING | ADASFLAG_DRAW))) {
+        SetBrushColor(hdc, bkcolor);
+        SetBkColor(hdc, bkcolor);
+        FillBox(hdc, adas_X, adas_Y, adas_W, adas_H);
+
+        /* Draw LDW lines. */
+        if (g_adas_output.ldw.valid) {
+            SetPenColor(hdc, PIXEL_red);
+            struct ldw_output *ldw = &g_adas_output.ldw;
+            MoveTo(hdc, (ldw->end_points[0][0] * WIN_W) / ADAS_LDW_WIDTH,
+                   (ldw->end_points[0][1] * WIN_H) / ADAS_LDW_HEIGHT);
+            LineTo(hdc, (ldw->end_points[1][0] * WIN_W) / ADAS_LDW_WIDTH,
+                   (ldw->end_points[1][1] * WIN_H) / ADAS_LDW_HEIGHT);
+            MoveTo(hdc, (ldw->end_points[2][0] * WIN_W) / ADAS_LDW_WIDTH,
+                   (ldw->end_points[2][1] * WIN_H) / ADAS_LDW_HEIGHT);
+            LineTo(hdc, (ldw->end_points[3][0] * WIN_W) / ADAS_LDW_WIDTH,
+                   (ldw->end_points[3][1] * WIN_H) / ADAS_LDW_HEIGHT);
+        }
+
+        /* Draw FCW rectangles. */
+        if (g_adas_output.odt.valid) {
+            SetPenColor(hdc, PIXEL_red);
+            int i = 0;
+            for (i = 0; i < g_adas_output.odt.count; i++) {
+                struct odt_object *obj = &g_adas_output.odt.objects[i];
+                int x0 = (obj->x * WIN_W) / ADAS_FCW_WIDTH;
+                int y0 = (obj->y * WIN_H) / ADAS_FCW_HEIGHT;
+                int x1 = ((obj->x + obj->width) * WIN_W) / ADAS_FCW_WIDTH;
+                int y1 = ((obj->y + obj->height) * WIN_H) / ADAS_FCW_HEIGHT;
+                Rectangle(hdc, x0, y0, x1, y1);
+                Rectangle(hdc, x0 - 1, y0 - 1, x1 - 1, y1 - 1);
+                Rectangle(hdc, x0 + 1, y0 + 1, x1 + 1, y1 + 1);
+            }
+        }
+        adasFlag &= ~ADASFLAG_DRAW;
+
+        /* Draw FCW setting Lines */
+        if (adasFlag & ADASFLAG_SETTING) {
+            char store[2];
+            int high;
+            parameter_get_video_adas_setting(store);
+            /* Draw Horizon */
+            high = (int)(WIN_H * ((float)store[0] / 100));
+            if (high > (adas_Y + 1))
+                PaintHorizontalBaseline(hdc, PIXEL_red,
+                                        adasFlag & ADASFLAG_LINE0_SELECTED, high);
+            /* Draw head baseline */
+            high = (int)(WIN_H * ((float)store[1] / 100));
+            if (high > (adas_Y + 1))
+                PaintHorizontalBaseline(hdc, PIXEL_green,
+                                        !(adasFlag & ADASFLAG_LINE0_SELECTED), high);
+
+            SetTextColor(hdc, PIXEL_red);
+            sprintf(setting_info, "horizon line: %3d%%", store[0]);
+            TextOut(hdc, 5, adas_Y, setting_info);
+
+            SetTextColor(hdc, PIXEL_green);
+            sprintf(setting_info, "head line:    %3d%%", store[1]);
+            TextOut(hdc, 5, adas_Y + 20, setting_info);
+        }
+    }
+}
+
+void keyprocess_adassetting(WPARAM key)
+{
+    char store[2];
+    char *p_setting;
+    char limit_high, limit_low;
+
+    parameter_get_video_adas_setting(store);
+    if (adasFlag & ADASFLAG_LINE0_SELECTED) {
+        p_setting = &store[0];
+        limit_high = store[1];
+        limit_low = 0;
+    } else {
+        p_setting = &store[1];
+        limit_high = 100;
+        limit_low = store[0];
+    }
+
+    switch (key) {
+    case SCANCODE_TAB:
+        if (adasFlag & ADASFLAG_LINE0_SELECTED)
+            adasFlag &= ~ADASFLAG_LINE0_SELECTED;
+        else
+            adasFlag |= ADASFLAG_LINE0_SELECTED;
+        break;
+    case SCANCODE_CURSORBLOCKDOWN:
+        if (*p_setting < limit_high)
+            (*p_setting) ++;
+        break;
+    case SCANCODE_CURSORBLOCKRIGHT:
+        if (*p_setting < (limit_high - 20) )
+            *p_setting += 20;
+        else
+            *p_setting = limit_high;
+        break;
+    case SCANCODE_CURSORBLOCKUP:
+        if (*p_setting > limit_low )
+            (*p_setting) --;
+        break;
+    case SCANCODE_CURSORBLOCKLEFT:
+        if (*p_setting > (limit_low + 20))
+            *p_setting -= 20;
+        else
+            *p_setting = limit_low;
+        break;
+    case SCANCODE_ENTER:
+        adasFlag &= ~ADASFLAG_SETTING;
+        dpp_adas_set_calibrate_line((int)(ADAS_FCW_HEIGHT * ((float)store[0] / 100)),
+                                    (int)(ADAS_FCW_HEIGHT * ((float)store[1] / 100)));
+        break;
+    }
+    parameter_save_video_adas_setting(store);
+}
+
+static int CameraWinProc(HWND hWnd, int message, WPARAM wParam, LPARAM lParam)
+{
+    HDC hdc;
+
+    // fprintf( stderr, "wParam =%d ,lParam =%d \n",(int)wParam,(int)lParam);
+    switch (message) {
+    case MSG_CREATE:
+        SetTimer(hWnd, _ID_TIMER, 100);
+        break;
+    case MSG_HDMI: {
+        //printf("%s wParam = %s, lParam = %d, hMainWnd = %d, hWnd = %d\n", __func__, wParam, lParam, hMainWnd, hWnd);
+        if (lParam == 1) {
+            rk_fb_set_out_device(OUT_DEVICE_HDMI);
+        } else {
+            rk_fb_set_out_device(OUT_DEVICE_LCD);
+        }
+        usleep(500000);
+        if (SetMode == MODE_PREVIEW)
+            videopreview_refresh(hWnd);
+        else if (SetMode == MODE_USBDIALOG) {
+            InvalidateRect(hWndUSB, NULL, TRUE);
+            break;
+        }
+        InvalidateRect(hMainWnd, NULL, TRUE);
+        break;
+    }
+
+    case MSG_CVBSOUT:
+        if (lParam == 1) {
+            rk_fb_set_out_device(rk_fb_get_cvbsout_mode());
+        } else {
+            rk_fb_set_out_device(OUT_DEVICE_LCD);
+        }
+        /* wait for kernel changing display to CVBSOUT completely */
+        usleep(500000);
+        if (SetMode == MODE_PREVIEW) {
+            videopreview_refresh(hWnd);
+        } else if (SetMode == MODE_USBDIALOG) {
+            InvalidateRect(hWndUSB, NULL, TRUE);
+            break;
+        }
+        InvalidateRect(hMainWnd, NULL, TRUE);
+        break;
+
+    case MSG_REPAIR:
+        if (parameter_get_video_lan() == 1)
+            MessageBox(hWnd, "sd卡中有损坏视频，\n现已修复!", "警告!!!", MB_OK);
+        else if (parameter_get_video_lan() == 0)
+            MessageBox(hWnd, "Sd card is damaged in video, \nwe have repair!",
+                       "Warning!!!", MB_OK);
+        break;
+    case MSG_FSINITFAIL:
+        proc_MSG_FS_INITFAIL(hWnd, -1);
+        break;
+    case MSG_PHOTOEND:
+        if (lParam == 1 && takephoto) {
+            unloadingWaitBmp(hWnd);
+            takephoto = false;
+        }
+        break;
+    case MSG_ADAS:
+        if (SetMode == MODE_RECORDING) {
+            memcpy((void *)&g_adas_output, (void *)wParam, sizeof(g_adas_output));
+            adasFlag |= ADASFLAG_DRAW;
+            InvalidateRect(hWnd, &adas_rc, FALSE);
+        } else {
+            memset(&g_adas_output, 0, sizeof(g_adas_output));
+            adasFlag &= ~ADASFLAG_DRAW;
+        }
+        break;
+    case MSG_SDMOUNTFAIL:
+        proc_MSG_SDMOUNTFAIL(hWnd);
+        break;
+    case MSG_SDCARDFORMAT:
+        unloadingWaitBmp(hWnd);
+        if (lParam == EVENT_SDCARDFORMAT_FINISH) {
+            printf("sd card format finish\n");
+        } else if (lParam == EVENT_SDCARDFORMAT_FAIL) {
+			printf("sd card format fail\n");
+        }
+        break;
+    case MSG_VIDEOPLAY:
+        if (lParam == EVENT_VIDEOPLAY_EXIT) {
+            exitplayvideo(hWnd);
+            // InvalidateRect (hWnd, &msg_rcTime, TRUE);
+            if (test_replay)
+                startplayvideo(hWnd, testpath);
+            if (parameter_get_debug_modechange() == 1) {
+                //    modechange_pre_flage =1;
+                modechange_time = MODECHANGE_TIME - 1;
+            } else if (parameter_get_debug_modechange() == 0) {
+                //        modechange_pre_flage=0;
+                modechange_time = 0;
+            }
+            if (parameter_get_debug_video() == 1) {
+                video_time = 1;
+            } else if (parameter_get_debug_video() == 0) {
+                video_time = 0;
+            }
+        } else if (lParam == EVENT_VIDEOPLAY_UPDATETIME) {
+            video_play_state = 1;
+            sec = (int)wParam;
+            if (parameter_get_debug_modechange() == 1) {
+                modechange_time = MODECHANGE_TIME - 1;
+            } else if (parameter_get_debug_modechange() == 0) {
+                modechange_time = 0;
+            }
+            if (parameter_get_debug_video() == 1) {
+                video_time = 1;
+            } else if (parameter_get_debug_video() == 0) {
+                video_time = 0;
+            }
+            InvalidateRect(hWnd, &msg_rcTime, FALSE);
+        }
+        break;
+    case MSG_VIDEOREC:
+        if (lParam == EVENT_VIDEOREC_UPDATETIME) {
+            sec = (int)wParam;
+            InvalidateRect(hWnd, &msg_rcTime, FALSE);
+            InvalidateRect(hWnd, &msg_rcRecimg, FALSE);
+        }
+        break;
+    case MSG_CAMERA: {
+        // printf("%s wParam = %s, lParam = %d\n", __func__, wParam, lParam);
+        if (SetMode != MODE_RECORDING && SetMode != MODE_PHOTO)
+            break;
+        if (lParam == 1) {
+            struct ui_frame front = {parameter_get_video_frontcamera_width(),
+                       parameter_get_video_frontcamera_height(),
+                       parameter_get_video_frontcamera_fps()
+            };
+
+            struct ui_frame back = {parameter_get_video_backcamera_width(),
+                       parameter_get_video_backcamera_height(),
+                       parameter_get_video_backcamera_fps()
+            };
+
+            struct ui_frame cif = {parameter_get_video_cifcamera_width(),
+                       parameter_get_video_cifcamera_height(),
+                       parameter_get_video_cifcamera_fps()
+            };
+
+            usleep(200000);
+            video_record_addvideo(wParam, &front, &back, &cif, api_video_get_record_state() == VIDEO_STATE_RECORD ? 1 : 0, 1);
+        } else {
+            video_record_deletevideo(wParam);
+        }
+        break;
+    }
+    case MSG_COLLISION: {
+        if (SetMode == MODE_RECORDING && api_get_sd_mount_state() == SD_STATE_IN)
+            video_record_savefile();
+        break;
+    }
+    case MSG_FILTER: {
+        // filterForUI= (int)lParam;
+        break;
+    }
+
+    case MSG_USBCHAGE:
+        proc_MSG_USBCHAGE(hWnd, message, wParam, lParam);
+        break;
+    case MSG_SDCHANGE:
+        printf("MSG_SDCHANGE sdcard = %d\n", api_get_sd_mount_state());
+        if (SetMode == MODE_RECORDING) {
+            if (api_get_sd_mount_state() == SD_STATE_IN) {
+                if (parameter_get_video_autorec())
+                    api_start_rec();
+            }
+        } else if (SetMode == MODE_EXPLORER) {
+            if (explorer_path == 0)
+                explorer_path = calloc(1, 256);
+            sprintf(explorer_path, "%s", SDCARD_PATH);
+            explorer_update(explorer_wnd);
+            InvalidateRect(hWnd, &msg_rcSD, FALSE);
+            InvalidateRect(hWnd, &msg_rcSDCAP, FALSE);
+        } else if (SetMode == MODE_PLAY) {
+            //videoplay_exit();
+        } else if (SetMode == MODE_PREVIEW) {
+            if (api_get_sd_mount_state() == SD_STATE_IN) {
+                entervideopreview();
+                InvalidateRect(hWnd, NULL, FALSE);
+            } else {
+                exitvideopreview();
+                InvalidateRect(hWnd, NULL, FALSE);
+            }
+        } else if (SetMode == MODE_PHOTO) {
+            InvalidateRect(hWnd, &msg_rcSD, FALSE);
+            InvalidateRect(hWnd, &msg_rcSDCAP, FALSE);
+        }
+        break;
+
+    case MSG_BATTERY:
+        cap = lParam;
+        if (cap > 100)
+            battery = 0;
+        else if ((cap >= 0) && (cap < (25 - BATTERY_CUSHION)))
+            battery = 1;
+        else if ((cap >= (25 + BATTERY_CUSHION)) && (cap < (50 - BATTERY_CUSHION)))
+            battery = 2;
+        else if ((cap >= (50 + BATTERY_CUSHION)) && (cap < (75 - BATTERY_CUSHION)))
+            battery = 3;
+        else if (cap >= (75 + BATTERY_CUSHION))
+            battery = 4;
+        else {
+            if ((battery != 0) && (last_battery != 0))
+                battery = last_battery;
+            if (battery == 0) {
+                if ((cap >= (25 - BATTERY_CUSHION)) && (cap < (25 + BATTERY_CUSHION)))
+                    battery  = 1;
+                if ((cap >= (50 - BATTERY_CUSHION)) && (cap < (50 + BATTERY_CUSHION)))
+                    battery  = 2;
+                if ((cap >= (75 - BATTERY_CUSHION)) && (cap < (75 + BATTERY_CUSHION)))
+                    battery  = 3;
+            }
+        }
+        last_battery = battery;
+        break;
+    case MSG_TIMER:
+        if (SetMode == MODE_RECORDING) {
+            parking_monitor_mode_switch(hWnd);
+        }
+
+        api_watchdog_keep_alive();
+
+        if (SetMode != MODE_PLAY) {
+            if (screenoff_time > 0) {
+                screenoff_time--;
+                if (screenoff_time == 0) {
+                    rkfb_screen_off();
+                }
+            }
+        }
+        if (SetMode < MODE_PLAY) {
+            InvalidateRect(hWnd, &msg_rcWifi, FALSE);
+            InvalidateRect(hWnd, &msg_rcSDCAP, FALSE);
+            InvalidateRect (hWnd, &msg_rcWatermarkTime, FALSE);
+            InvalidateRect (hWnd, &msg_rcWatermarkLicn, FALSE);
+            InvalidateRect (hWnd, &msg_rcWatermarkImg, FALSE);
+
+            if(parameter_get_gps_mark())
+                gps_ui_control(hWnd, FALSE);
+        }
+        if (SetMode == MODE_RECORDING) {
+            video_record_fps_count();
+        }
+
+        ui_timer_debug_process(hWnd);
+
+        break;
+    case MSG_PAINT:
+		break;
+    case MSG_COMMAND:
+        commandEvent(hWnd, wParam, lParam);
+        break;
+
+    case MSG_ACTIVEMENU:
+        break;
+
+    case MSG_CLOSE:
+        api_video_deinit();
+        KillTimer(hWnd, _ID_TIMER);
+        DestroyAllControls(hWnd);
+        DestroyMainWindow(hWnd);
+        PostQuitMessage(hWnd);
+        return 0;
+    case MSG_KEYDOWN: {
+        if (key_lock)
+            break;
+        printf("%s MSG_KEYDOWN SetMode = %d, key = %d\n", __func__, SetMode,
+               wParam);
+
+        if (SetMode == MODE_RECORDING && parameter_get_video_adas()
+            && (adasFlag & ADASFLAG_SETTING)) {
+            keyprocess_adassetting(wParam);
+            break;
+        }
+
+#ifdef USE_KEY_STOP_USB_DIS_SHUTDOWN
+        //key stop usb disconnect shutdown
+        if ((wParam != 116) && (gshutdown != 0)) {
+            stop_usb_disconnect_poweroff();
+        }
+#endif
+        if (SetMode == MODE_PREVIEW) {
+            hwndforpre = hWnd;
+            switch (wParam) {
+            case SCANCODE_TAB: {
+                changemode(hWnd, MODE_RECORDING);
+                break;
+            }
+            case SCANCODE_CURSORBLOCKUP:
+            case SCANCODE_CURSORBLOCKRIGHT: {
+                videopreview_next(hWnd);
+                break;
+            }
+            case SCANCODE_CURSORBLOCKDOWN:
+            case SCANCODE_CURSORBLOCKLEFT: {
+                videopreview_pre(hWnd);
+                break;
+            }
+            case SCANCODE_ENTER: {
+                if (videoplay != 0) {
+                    //    printf("videoplay==-1\n");
+                    if (parameter_get_video_lan() == 1)
+                        MessageBox(hwndforpre, "视频错误!!!", "警告!!!", MB_OK);
+                    else if (parameter_get_video_lan() == 0)
+                        MessageBox(hwndforpre, "video error !!!", "Warning!!!", MB_OK);
+                } else {
+                    videopreview_play(hWnd);
+                }
+                break;
+            }
+            case SCANCODE_MENU: {
+                videopreview_delete(hWnd);
+                break;
+            }
+            case SCANCODE_SHUTDOWN: {
+                changemode(hWnd, MODE_SUSPEND);
+                break;
+            }
+            }
+        } else if (SetMode == MODE_USBDIALOG) {
+        } else if (SetMode == MODE_PLAY) {
+            switch (wParam) {
+            case SCANCODE_TAB:
+            case SCANCODE_Q:
+            case SCANCODE_ESCAPE:
+                test_replay = 0;
+                videoplay_exit();
+                break;
+            case SCANCODE_SPACE:
+            case SCANCODE_ENTER:
+                // do pause
+                videoplay_pause();
+                break;
+            case SCANCODE_S:
+                videoplay_step_play();
+                break;
+            case SCANCODE_CURSORBLOCKLEFT:
+                videoplay_seek_time(-5.0);
+                break;
+            case SCANCODE_CURSORBLOCKRIGHT:
+                videoplay_seek_time(5.0);
+                break;
+            case SCANCODE_CURSORBLOCKUP:
+                videoplay_set_speed(1);
+                break;
+            case SCANCODE_CURSORBLOCKDOWN:
+                videoplay_set_speed(-1);
+                break;
+            case SCANCODE_SHUTDOWN:
+                changemode(hWnd, MODE_SUSPEND);
+                break;
+            default:
+                printf("scancode: %d\n", wParam);
+            }
+        } else if (SetMode == MODE_EXPLORER) {
+            switch (wParam) {
+            case SCANCODE_A:
+            case SCANCODE_ENTER:
+                explorer_enter(hWnd);
+                break;
+            case SCANCODE_TAB: {
+                changemode(hWnd, MODE_RECORDING);
+                break;
+            }
+            case SCANCODE_Q:
+                explorer_back(hWnd);
+                break;
+            case SCANCODE_D:
+                explorer_filedelete(hWnd);
+                break;
+            }
+        } else if (SetMode == MODE_RECORDING) {
+            switch (wParam) {
+            case SCANCODE_MENU:
+            case SCANCODE_LEFTALT:
+            case SCANCODE_RIGHTALT:
+                printf("add by lqw:SCANCODE_RIGHTALT\n");
+                //   CreateMainWindowMenu(hWnd, creatmenu());
+                if (menucreated == 0) {
+                    CreateMainWindowMenu(hWnd, creatmenu());
+                    menucreated = 1;
+                } else if ((video_record_get_front_resolution(frontcamera, 4) ==
+                            0) ||
+                           (video_record_get_back_resolution(backcamera, 4) == 0)) {
+                    DestroyMainWindowMenu(hWnd);
+                    CreateMainWindowMenu(hWnd, creatmenu());
+                }
+                if (api_video_get_record_state() == VIDEO_STATE_PREVIEW)
+                    popmenu(hWnd);
+                break;
+            case SCANCODE_CURSORBLOCKDOWN:
+                api_mic_onoff(parameter_get_video_audio() == 0 ? 1 : 0);
+                break;
+            case SCANCODE_CURSORBLOCKUP:
+                if (api_video_get_record_state() == VIDEO_STATE_PREVIEW) {
+                    if (api_get_sd_mount_state() == SD_STATE_IN) {
+                        api_start_rec();
+                    }
+                } else {
+                    api_stop_rec();
+                }
+                break;
+            case SCANCODE_CURSORBLOCKRIGHT:
+                proc_record_SCANCODE_CURSORBLOCKRIGHT(hWnd);
+                break;
+            case SCANCODE_TAB: {
+                // changemode(hWnd, MODE_EXPLORER);
+                changemode(hWnd, MODE_PHOTO);
+                // changemode(hWnd, MODE_PREVIEW);
+                break;
+            }
+            case SCANCODE_ENTER:
+                ui_takephoto(hWnd);
+                break;
+            case SCANCODE_ESCAPE:
+                video_record_display_switch();
+                break;
+
+            case SCANCODE_B:  // block video save
+                video_record_blocknotify(BLOCK_PREV_NUM, BLOCK_LATER_NUM);
+                video_record_savefile();
+                printf("The envent SCANCODE_B\n");
+                break;
+            case SCANCODE_SHUTDOWN:
+                changemode(hWnd, MODE_SUSPEND);
+            }
+        } else if (SetMode == MODE_PHOTO) {
+            switch (wParam) {
+            case SCANCODE_MENU:
+            case SCANCODE_RIGHTALT:
+                if (api_video_get_record_state() == VIDEO_STATE_PREVIEW)
+                    popmenu(hWnd);
+                break;
+            case SCANCODE_TAB:
+                changemode(hWnd, MODE_PREVIEW);
+                break;
+            case SCANCODE_ENTER:
+                ui_takephoto(hWnd);
+                break;
+            case SCANCODE_SHUTDOWN:
+                changemode(hWnd, MODE_SUSPEND);
+            }
+        }
+    } break;
+
+    case MSG_KEYLONGPRESS:
+        if (wParam == SCANCODE_SHUTDOWN) {
+            shutdown_deinit(hWnd);
+        }
+        break;
+
+    case MSG_USB_DISCONNECT:
+        if (wParam == SCANCODE_SHUTDOWN) {
+            shutdown_usb_disconnect(hWnd);
+        }
+        break;
+
+
+    case MSG_KEYALWAYSPRESS:
+        // printf("MSG_KEYALWAYSPRESS key = %d\n", wParam);
+        break;
+
+    case MSG_KEYUP:
+        // printf("MSG_KEYUP key = %d\n", wParam);
+        switch (wParam) {
+        default:
+            break;
+        }
+        break;
+    case MSG_MAINWIN_KEYDOWN:
+        if (SetMode != MODE_PLAY && SetMode != MODE_PREVIEW)
+            audio_sync_play(keypress_sound_file);
+
+        if (screenoff_time == 0) {
+            screenoff_time = parameter_get_screenoff_time();
+            rkfb_screen_on();
+        } else if (screenoff_time > 0) {
+            screenoff_time = parameter_get_screenoff_time();
+        }
+        break;
+    case MSG_MAINWIN_KEYUP:
+        break;
+    case MSG_MAINWIN_KEYLONGPRESS:
+        break;
+    case MSG_MAINWIN_KEYALWAYSPRESS:
+        break;
+    }
+
+    return DefaultMainWinProc(hWnd, message, wParam, lParam);
+}
+
+int loadres(void)
+{
+    int i;
+    char img[128];
+    char respath[] = "/usr/local/share/minigui/res/images/";
+
+    char debug_img[2][20] = {"debug.bmp", "debug_sel.bmp"};
+    char filetype_img[FILE_TYPE_MAX][20] = {"file_unknown.bmp", "file_jpeg.bmp",
+                                            "file_video.bmp"
+                                           };
+    char play_img[] = "play.bmp";
+    char back_img[] = "file_back.bmp";
+    char usb_img[] = "usb.bmp";
+    char folder_img[] = "folder.bmp";
+    char mic_img[2][20] = {"mic_off.bmp", "mic_on.bmp"};
+    char A_img[3][10] = {"a.bmp", "b.bmp", "ab.bmp"};
+    char topbk_img[] = "top_bk.bmp";
+    char rec_img[] = "rec.bmp";
+    char timelapse_img[] = "timelapse.png";
+    char timelapse_on_img[] = "timelapse_on.png";
+    char motiondetect_img[] = "motiondetect.png";
+    char motiondetect_on_img[] = "motiondetect_on.png";
+    char watermark_img[7][30] = {"watermark.bmp", "watermark_240p.bmp", "watermark_360p.bmp", "watermark_480p.bmp",
+                                 "watermark_720p.bmp", "watermark_1080p.bmp", "watermark_1440p.bmp"
+                                };
+    char batt_img[5][20] = {"battery_0.bmp", "battery_1.bmp", "battery_2.bmp",
+                            "battery_3.bmp", "battery_4.bmp"
+                           };
+    char tf_img[2][20] = {"tf_out.bmp", "tf_in.bmp"};
+    char mode_img[4][20] = {"icon_video.bmp", "icon_camera.bmp", "icon_play.bmp",
+                            "icon_play.bmp"
+                           };
+    char resolution_img[2][30] = {"resolution_720p.bmp", "resolution_1080p.bmp"};
+    char move_img[2][20] = {"move_0.bmp", "move_1.bmp"};
+    char mp_img[2][20] = {"mp.bmp", "mp_sel.bmp"};
+    char car_img[2][20] = {"car.bmp", "car_sel.bmp"};
+    char time_img[2][20] = {"time.bmp", "time_sel.bmp"};
+    char setting_img[2][20] = {"setting.bmp", "setting_sel.bmp"};
+    char wifi_img[5][20] = {"wifi_0.bmp", "wifi_1.bmp", "wifi_2.bmp",
+                            "wifi_3.bmp", "wifi_4.bmp"
+                           };
+
+    /*load wifi bmp*/
+    for (i = 0; i < (sizeof(wifi_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, wifi_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &wifi_bmap[i], img))
+            return -1;
+    }
+
+    // load debug
+    for (i = 0; i < (sizeof(png_menu_debug) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, debug_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &png_menu_debug[i], img))
+            return -1;
+    }
+    /*load filetype bmp*/
+    for (i = 0; i < (sizeof(filetype_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, filetype_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &filetype_bmap[i], img))
+            return -1;
+    }
+
+    /* load play bmp */
+    snprintf(img, sizeof(img), "%s%s", respath, play_img);
+    if (LoadBitmap(HDC_SCREEN, &play_bmap, img))
+        return -1;
+
+    /* load back bmp */
+    snprintf(img, sizeof(img), "%s%s", respath, back_img);
+    if (LoadBitmap(HDC_SCREEN, &back_bmap, img))
+        return -1;
+
+    // load usb bmp
+    snprintf(img, sizeof(img), "%s%s", respath, usb_img);
+    if (LoadBitmap(HDC_SCREEN, &usb_bmap, img))
+        return -1;
+
+    /* load folder bmp */
+    snprintf(img, sizeof(img), "%s%s", respath, folder_img);
+    if (LoadBitmap(HDC_SCREEN, &folder_bmap, img))
+        return -1;
+
+    /*load mic bmp*/
+    for (i = 0; i < (sizeof(mic_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, mic_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &mic_bmap[i], img))
+            return -1;
+    }
+
+    /*load a bmp*/
+    for (i = 0; i < (sizeof(A_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, A_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &A_bmap[i], img))
+            return -1;
+    }
+
+    /* load topbk bmp */
+    snprintf(img, sizeof(img), "%s%s", respath, topbk_img);
+    if (LoadBitmap(HDC_SCREEN, &topbk_bmap, img))
+        return -1;
+
+    /* load recimg bmp */
+    snprintf(img, sizeof(img), "%s%s", respath, rec_img);
+    if (LoadBitmap(HDC_SCREEN, &recimg_bmap, img))
+        return -1;
+
+    /* load timelapse png */
+    snprintf(img, sizeof(img), "%s%s", respath, timelapse_img);
+    if (LoadBitmap(HDC_SCREEN, &timelapse_bmap, img))
+        return -1;
+
+    /* load timelapse_on png */
+    snprintf(img, sizeof(img), "%s%s", respath, timelapse_on_img);
+    if (LoadBitmap(HDC_SCREEN, &timelapse_on_bmap, img))
+        return -1;
+
+    /* load motiondetect png */
+    snprintf(img, sizeof(img), "%s%s", respath, motiondetect_img);
+    if (LoadBitmap(HDC_SCREEN, &motiondetect_bmap, img))
+        return -1;
+
+    /* load motiondetect_on png */
+    snprintf(img, sizeof(img), "%s%s", respath, motiondetect_on_img);
+    if (LoadBitmap(HDC_SCREEN, &motiondetect_on_bmap, img))
+        return -1;
+
+    /* load watermark bmp */
+    for (i = 0; i < ARRAY_SIZE(watermark_bmap); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, watermark_img[i]);
+        if (load_bitmap(&watermark_bmap[i], img)) {
+            printf("load watermark bmp error, i = %d\n", i);
+            return -1;
+        }
+    }
+
+    /* load batt bmp */
+    for (i = 0; i < (sizeof(batt_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, batt_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &batt_bmap[i], img))
+            return -1;
+    }
+
+    /* load tf card bmp */
+    for (i = 0; i < (sizeof(tf_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, tf_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &tf_bmap[i], img))
+            return -1;
+    }
+
+    /* load mode bmp */
+    for (i = 0; i < (sizeof(mode_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, mode_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &mode_bmap[i], img))
+            return -1;
+    }
+
+    /* load resolution bmp */
+    for (i = 0; i < (sizeof(resolution_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, resolution_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &resolution_bmap[i], img))
+            return -1;
+    }
+
+    /* load move bmp */
+    for (i = 0; i < (sizeof(move_bmap) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, move_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &move_bmap[i], img))
+            return -1;
+    }
+
+    /* load mp bmp */
+    for (i = 0; i < (sizeof(bmp_menu_mp) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, mp_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &bmp_menu_mp[i], img))
+            return -1;
+    }
+
+    /* load car bmp */
+    for (i = 0; i < (sizeof(bmp_menu_car) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, car_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &bmp_menu_car[i], img))
+            return -1;
+    }
+
+    /* load time bmp */
+    for (i = 0; i < (sizeof(bmp_menu_time) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, time_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &bmp_menu_time[i], img))
+            return -1;
+    }
+    /* load setting bmp */
+    for (i = 0; i < (sizeof(bmp_menu_setting) / sizeof(BITMAP)); i++) {
+        snprintf(img, sizeof(img), "%s%s", respath, setting_img[i]);
+        if (LoadBitmap(HDC_SCREEN, &bmp_menu_setting[i], img))
+            return -1;
+    }
+
+    return 0;
+}
+
+void unloadres(void)
+{
+    int i;
+
+    /* unload wifi bmp */
+    for (i = 0; i < (sizeof(wifi_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&wifi_bmap[i]);
+    }
+
+    /* unload filetype bmp */
+    for (i = 0; i < (sizeof(filetype_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&filetype_bmap[i]);
+    }
+
+    /* unload back bmp */
+    UnloadBitmap(&play_bmap);
+
+    /* unload back bmp */
+    UnloadBitmap(&back_bmap);
+
+    /* unload folder bmp */
+    UnloadBitmap(&folder_bmap);
+
+    /* unload topbk bmp */
+    UnloadBitmap(&topbk_bmap);
+
+    /* unload recimg bmp */
+    UnloadBitmap(&recimg_bmap);
+
+    /* unload timelapse bmp */
+    UnloadBitmap(&timelapse_bmap);
+
+    /* unload motiondetect bmp */
+    UnloadBitmap(&motiondetect_bmap);
+
+    /* unload timelapse_on bmp */
+    UnloadBitmap(&timelapse_on_bmap);
+
+    /* unload motiondetect_on bmp */
+    UnloadBitmap(&motiondetect_on_bmap);
+
+    /* unload watermark bmp */
+    for (i = 0; i < ARRAY_SIZE(watermark_bmap); i++)
+        unload_bitmap(&watermark_bmap[i]);
+
+    // unload usb bmp
+    UnloadBitmap(&usb_bmap);
+    /* unload mic bmp */
+    for (i = 0; i < (sizeof(mic_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&mic_bmap[i]);
+    }
+
+    /* unload a bmp */
+    for (i = 0; i < (sizeof(A_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&A_bmap[i]);
+    }
+
+    /* unload batt bmp */
+    for (i = 0; i < (sizeof(batt_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&batt_bmap[i]);
+    }
+
+    /* unload tf card bmp */
+    for (i = 0; i < (sizeof(tf_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&tf_bmap[i]);
+    }
+
+    /* unload mode bmp */
+    for (i = 0; i < (sizeof(mode_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&mode_bmap[i]);
+    }
+
+    /* unload resolution bmp */
+    for (i = 0; i < (sizeof(resolution_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&resolution_bmap[i]);
+    }
+
+    /* unload move bmp */
+    for (i = 0; i < (sizeof(move_bmap) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&move_bmap[i]);
+    }
+
+    /* unload mp bmp */
+    for (i = 0; i < (sizeof(bmp_menu_mp) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&bmp_menu_mp[i]);
+    }
+
+    /*un load car bmp */
+    for (i = 0; i < (sizeof(bmp_menu_car) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&bmp_menu_car[i]);
+    }
+
+    /* unload time bmp */
+    for (i = 0; i < (sizeof(bmp_menu_time) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&bmp_menu_time[i]);
+    }
+
+    /* unload setting bmp */
+    for (i = 0; i < (sizeof(bmp_menu_setting) / sizeof(BITMAP)); i++) {
+        UnloadBitmap(&bmp_menu_setting[i]);
+    }
+}
+
+void ui_deinit(void)
+{
+    KillTimer(hMainWnd, _ID_TIMER);
+    DestroyAllControls(hMainWnd);
+    DestroyMainWindow(hMainWnd);
+    UnregisterMainWindow(hMainWnd);
+    MainWindowThreadCleanup(hMainWnd);
+    unloadres();
+}
+
+void ui_msg_manager_cb(void *msgData, void *msg0, void *msg1)
+{
+    struct public_message msg;
+
+    if (NULL != msgData) {
+        msg.id = ((struct public_message *)msgData)->id;
+        msg.type = ((struct public_message *)msgData)->type;
+    }
+
+    if (msg.type != TYPE_LOCAL && msg.type != TYPE_BROADCAST)
+        return;
+
+    switch (msg.id) {
+    case MSG_SET_LANGUAGE:
+        SetSystemLanguage(hMainWnd, (int)msg0);
+        break;
+    case MSG_SDCARDFORMAT_START:
+        printf("%s MSG_SDCARDFORMAT_START %d\n", __func__, (int)msg0);
+        loadingWaitBmp(hMainWnd);
+        break;
+    case MSG_SDCARDFORMAT_NOTIFY:
+        printf("%s MSG_SDCARDFORMAT_NOTIFY %d\n", __func__, (int)msg0);
+        if (msg0 < 0)
+            PostMessage(hMainWnd, MSG_SDCARDFORMAT, 0, EVENT_SDCARDFORMAT_FAIL);
+        else
+            PostMessage(hMainWnd, MSG_SDCARDFORMAT, 0, EVENT_SDCARDFORMAT_FINISH);
+        break;
+    case MSG_VIDEO_REC_START:
+        sec = 0;
+        InvalidateRect(hMainWnd, &msg_rcTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcRecimg, TRUE);
+
+        InvalidateRect (hMainWnd, &msg_rcWatermarkTime, TRUE);
+        InvalidateRect (hMainWnd, &msg_rcWatermarkLicn, TRUE);
+        InvalidateRect (hMainWnd, &msg_rcWatermarkImg, TRUE);
+        break;
+    case MSG_VIDEO_REC_STOP:
+        InvalidateRect(hMainWnd, &msg_rcTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcRecimg, TRUE);
+
+        InvalidateRect(hMainWnd, &msg_rcWatermarkTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkLicn, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkImg, TRUE);
+        break;
+    case MSG_VIDEO_MIC_ONOFF:
+        InvalidateRect(hMainWnd, &msg_rcMic, FALSE);
+        break;
+    case MSG_VIDEO_SET_ABMODE:
+        InvalidateRect(hMainWnd, &msg_rcAB, FALSE);
+        break;
+    case MSG_VIDEO_SET_MOTION_DETE:
+        InvalidateRect(hMainWnd, &msg_rcMove, FALSE);
+        break;
+    case MSG_VIDEO_MARK_ONOFF:
+        InvalidateRect(hMainWnd, &msg_rcWatermarkTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkLicn, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkImg, TRUE);
+        break;
+    case MSG_VIDEO_ADAS_ONOFF:
+        adasflagtooff = 1;
+        InvalidateRect(hMainWnd, &adas_rc, TRUE);
+        break;
+    case MSG_VIDEO_UPDATETIME:
+        PostMessage(hMainWnd, MSG_VIDEOREC, (WPARAM)msg0, EVENT_VIDEOREC_UPDATETIME);
+        break;
+    case MSG_ADAS_UPDATE:
+        PostMessage(hMainWnd, MSG_ADAS, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_VIDEO_PHOTO_END:
+        SendNotifyMessage(hMainWnd, MSG_PHOTOEND, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_SDCORD_MOUNT_FAIL:
+        PostMessage(hMainWnd, MSG_SDMOUNTFAIL, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_SDCORD_CHANGE:
+        PostMessage(hMainWnd, MSG_SDCHANGE, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_FS_INITFAIL:
+        PostMessage(hMainWnd, MSG_FSINITFAIL, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_HDMI_EVENT:
+        SendMessage(hMainWnd, MSG_HDMI, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_CVBSOUT_EVENT:
+        SendMessage(hMainWnd, MSG_CVBSOUT, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_POWEROFF:
+        ui_deinit();
+        break;
+    case MSG_BATT_UPDATE_CAP:
+        PostMessage(hMainWnd, MSG_BATTERY, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_BATT_LOW:
+        shutdown_deinit(hMainWnd);
+        break;
+    case MSG_BATT_DISCHARGE:
+        PostMessage(hMainWnd, MSG_BATTERY, (WPARAM)msg0, (LPARAM)msg1);
+        shutdown_usb_disconnect(hMainWnd);
+        break;
+    case MSG_CAMERE_EVENT:
+        PostMessage(hMainWnd, MSG_CAMERA, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_USB_EVENT:
+        PostMessage(hMainWnd, MSG_USBCHAGE, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_USER_RECORD_RATE_CHANGE:
+        break;
+    case MSG_USER_MDPROCESSOR:
+        break;
+    case MSG_USER_MUXER:
+        break;
+    case MSG_VIDEOPLAY_EXIT:
+        PostMessage(hMainWnd, MSG_VIDEOPLAY, (WPARAM)NULL,
+                    EVENT_VIDEOPLAY_EXIT);
+        break;
+    case MSG_VIDEOPLAY_UPDATETIME:
+        SendMessage(hMainWnd, MSG_VIDEOPLAY, (WPARAM)msg0,
+                    EVENT_VIDEOPLAY_UPDATETIME);
+        break;
+    default:
+        break;
+    }
+}
+#else
+
+struct bitmap watermark_bmap[7];
+uint32_t licplate_pos[8] = {0};
+static pthread_mutex_t set_mutex;
+static HWND hMainWnd;
+static int SetMode;
+static struct adas_output g_adas_output;
+static struct gps_info ggps_info;
+static struct gps_send_data ggps_send;
+static long int collision_rec_time;
+
+#define BLOCK_PREV_NUM 1   // min
+#define BLOCK_LATER_NUM 1  // min
+
+#define MODE_RECORDING 0
+#define MODE_PHOTO 1
+#define MODE_EXPLORER 2
+#define MODE_PREVIEW 3
+#define MODE_PLAY 4
+#define MODE_USBDIALOG 5
+#define MODE_USBCONNECTION 6
+#define MODE_SUSPEND 7
+//USB
+#define USB_MODE 1
+#define BATTERY_CUSHION 3
+#define USE_KEY_STOP_USB_DIS_SHUTDOWN
+
+#define PARKINGMONITOR_OFF      0
+#define PARKINGMONITOR_SHUTDOWN_MODE    1
+#define PARKINGMONITOR_SUSPEND_MODE 2
+#define PARKINGMONITOR_MOTION_DETECT    3
+#define PARKINGMONITOR_TIMELAPSE    4
+#define PARKING_RECORD_COUNT        90
+#define MOTION_DETECT_COUNT     30
+#define TIMELAPSE_RECORD_COUNT      30
+#define PARKING_SUSPEND         1
+#define PARKING_SHUTDOWN        2
+static char gparking;
+static char gparking_mode_change;
+static int gparking_gs_active;
+static int gparking_count;
+static int gmotion_detection;
+static int gtimelapse_record;
+
+static int parking_monitor_mode_switch(HWND hWnd)
+{
+#if 0
+    gparking = parameter_get_parkingmonitor();
+    if (gparking_mode_change == 1) {
+        if (gtimelapse_record == 1) {
+            display_timelapse_on_ui(hWnd, 0);
+        }
+        if (gmotion_detection == 1) {
+            display_motion_detect_on_ui(hWnd, 0);
+        }
+
+        gparking_mode_change = 0;
+    }
+
+    parking_prompt_window(hWnd, gparking);
+
+    if (gparking == PARKINGMONITOR_MOTION_DETECT) {
+        if (gparking_gs_active == 1) {
+            gparking_count = 0;
+            gparking_gs_active = 0;
+        } else if (SetMode == MODE_RECORDING) {
+            gparking_count++;
+        } else {
+            gparking_count = 0;
+        }
+
+        if (gparking_count % 10 == 0)
+            printf("MOTION_Detect: gparking_count = %d\n",
+                   gparking_count);
+        if ((gparking_count >= MOTION_DETECT_COUNT) &&
+            (gmotion_detection == 0)) {
+            printf("start_motion_detection\n");
+            start_motion_detection();
+            gmotion_detection = 1;
+
+            /* UI: prompt start motion detection */
+            display_motion_detect_on_ui(hWnd, 1);
+        } else if ((gmotion_detection == 1) &&
+                   (gparking_count == 0)) {
+            printf("close_motion_detection\n");
+            stop_motion_detection();
+            gmotion_detection = 0;
+
+            /* UI: prompt close motion detection */
+            display_motion_detect_on_ui(hWnd, 0);
+
+            printf("init rec---\n");
+            if (api_get_sd_mount_state() == SD_STATE_IN)
+                api_start_rec();
+        }
+    } else if ((gparking == PARKINGMONITOR_SHUTDOWN_MODE) ||
+               (gparking == PARKINGMONITOR_SUSPEND_MODE)) {
+        if ((gparking_gs_active == 0) &&
+            (PARKINGMONITOR_OFF != gparking)) {
+            if ((SetMode != MODE_USBDIALOG) &&
+                (SetMode != MODE_USBCONNECTION))
+                gparking_count++;
+            else
+                gparking_count = 0;
+            if (gparking_count % 10 == 0)
+                printf("PARKING_Monitor : gparking_count = %d\n",
+                       gparking_count);
+            if (gparking_count >= PARKING_RECORD_COUNT) {
+                if (gparking == PARKINGMONITOR_SHUTDOWN_MODE) {
+                    printf("shutdown\n");
+                    parking_record_process(PARKING_SHUTDOWN);
+                } else if (gparking == PARKINGMONITOR_SUSPEND_MODE) {
+                    printf("suspend:\n");
+                    parking_record_process(PARKING_SUSPEND);
+                }
+            }
+        }
+
+        if (((gparking_gs_active == 1) &&
+             (PARKINGMONITOR_OFF != gparking)) ||
+            (PARKINGMONITOR_OFF == gparking)) {
+            gparking_count = 0;
+            gparking_gs_active = 0;
+        }
+    } else if (gparking == PARKINGMONITOR_TIMELAPSE) {
+        if (gparking_gs_active == 1) {
+            gparking_count = 0;
+            gparking_gs_active = 0;
+        } else if (SetMode == MODE_RECORDING) {
+            gparking_count++;
+        } else {
+            gparking_count = 0;
+        }
+
+        if (gparking_count % 10 == 0)
+            printf("Timelapse_record : gparking_count = %d\n",
+                   gparking_count);
+        if ((gparking_count >= TIMELAPSE_RECORD_COUNT) &&
+            (gtimelapse_record == 0)) {
+            printf("start_timelapse_record\n");
+            gtimelapse_record = 1;
+            parameter_save_time_lapse_interval(1);
+            video_record_set_timelapseint(1);
+
+            /* UI: prompt start timelapse record */
+            display_timelapse_on_ui(hWnd, 1);
+        } else if ((gtimelapse_record == 1) &&
+                   (gparking_count == 0)) {
+            printf("close_timelapse_record\n");
+            parameter_save_time_lapse_interval(0);
+            video_record_set_timelapseint(0);
+            gtimelapse_record = 0;
+            /* UI: prompt close timelapse record */
+            display_timelapse_on_ui(hWnd, 0);
+        }
+    } else {
+        gparking_gs_active = 0;
+        gparking_count = 0;
+        gmotion_detection = 0;
+    }
+#endif
+    return 0;
+}
+
+void parking_event_callback(int cmd, void *msg0, void *msg1)
+{
+    switch (cmd) {
+    case CMD_PARKING:
+        gparking_gs_active = 1;
+        break;
+    default:
+        break;
+    }
+}
+
+void gps_send_callback(const char* gpsData, int len, int searchType)
+{
+    if(gpsData == NULL)
+        return;
+
+    gps_nmea_data_parse(&ggps_info, gpsData, searchType, len);
+}
+
+static void initrec(HWND hWnd)
+{
+    memset(&g_adas_output, 0, sizeof(g_adas_output));
+
+    if (SetMode != MODE_PHOTO) {
+        api_video_init(VIDEO_MODE_REC);
+    } else {
+        api_video_init(VIDEO_MODE_PHOTO);
+    }
+
+    InvalidateRect(hWnd, NULL, FALSE);
+}
+
+static void deinitrec(HWND hWnd)
+{
+    api_video_deinit();
+}
+
+static int CameraWinProc(HWND hWnd, int message, WPARAM wParam, LPARAM lParam)
+{
+    switch (message) {
+	case MSG_CREATE:
+		SetTimer(hWnd, _ID_TIMER, 1000);
+        break;
+	case MSG_HDMI: 
+		DBGMSG(NI, ("MSG_HDMI\n"));
+        break;
+    case MSG_TIMER:
+        /* gparking_gs_active (0: gsensor negative 1: gsneosr active) */
+        if (SetMode == MODE_RECORDING) {
+            parking_monitor_mode_switch(hWnd);
+        }
+#if 0
+        api_watchdog_keep_alive();
+        if (SetMode != MODE_PLAY) {
+            if (screenoff_time > 0) {
+                screenoff_time--;
+                if (screenoff_time == 0) {
+                    rkfb_screen_off();
+                }
+            }
+        }
+        if (SetMode < MODE_PLAY) {
+            InvalidateRect(hWnd, &msg_rcWifi, FALSE);
+            InvalidateRect(hWnd, &msg_rcSDCAP, FALSE);
+            InvalidateRect (hWnd, &msg_rcWatermarkTime, FALSE);
+            InvalidateRect (hWnd, &msg_rcWatermarkLicn, FALSE);
+            InvalidateRect (hWnd, &msg_rcWatermarkImg, FALSE);
+
+            if(parameter_get_gps_mark())
+                gps_ui_control(hWnd, FALSE);
+        }
+		ui_timer_debug_process(hWnd);
+#endif
+        if (SetMode == MODE_RECORDING) {
+            video_record_fps_count();
+        }
+
+
+        break;
+        break;
+	case MSG_KEYDOWN:
+		DBGMSG(NI, ("MSG_KEYDOWN %d %d\n", (int)wParam, (int)lParam));
+		break;
+	case MSG_KEYUP:
+		DBGMSG(NI, ("MSG_KEYUP %d %d\n", (int)wParam, (int)lParam));
+		break;
+	case MSG_KEYLONGPRESS:
+		DBGMSG(NI, ("MSG_KEYLONGPRESS %d %d\n", (int)wParam, (int)lParam));
+		break;
+    }
+	return 0;
+}
+static void *msg_test(void* p_arg)
+{
+	while (1) {
+		PostMessage(hMainWnd, 1, 1, 1);
+		usleep(1000*1000);
+	}
+	return NULL;
+}
+void loadingWaitBmp(HWND hWnd)
+{
+	return;
+}
+static int sec;
+static int adasflagtooff;
+void ui_deinit(void)
+{
+    KillTimer(hMainWnd, _ID_TIMER);
+    DestroyAllControls(hMainWnd);
+    DestroyMainWindow(hMainWnd);
+    UnregisterMainWindow(hMainWnd);
+    MainWindowThreadCleanup(hMainWnd);
+    unloadres();
+}
+static int gshutdown;
+/*SHUTDOWN FUNCTION*/
+static int shutdown_deinit(HWND hWnd)
+{
+    if ((gshutdown == 1) || (gshutdown == 2)) {
+        gshutdown = 2; //tell usb disconnect shutdown
+        return -1;
+    }
+    gshutdown = 1;
+    power_shutdown();
+    return 0;
+}
+int usb_disconnect_poweroff(void *arg)
+{
+    int i;
+    HWND hWnd = (HWND)arg;
+    for (i = 0; i < 10; i++) {
+        if (charging_status_check()) {
+            gshutdown = 0;
+            printf("%s[%d]:vbus conenct,cancel shutdown\n", __func__, __LINE__);
+            return 0;
+        }
+        if (gshutdown == 2)//powerkey or low battery shutdown
+            break;
+#ifdef USE_KEY_STOP_USB_DIS_SHUTDOWN
+        if (gshutdown == 3) {
+            //key stop usb disconnect shutdown
+            gshutdown = 0;
+            printf("%s[%d]:key stop usb disconnect shutdown\n", __func__, __LINE__);
+            return 0;
+        }
+#endif
+        printf("%s[%d]:shutdown wait---%d\n", __func__, __LINE__, i);
+        sleep(1);
+    }
+    printf("%s[%d]:gshutdown=%d,shutdown...\n", __func__, __LINE__, gshutdown);
+    api_video_deinit();
+    if (charging_status_check()) {
+        gshutdown = 0;
+        printf("%s[%d]:vbus conenct,cancel shutdown\n", __func__, __LINE__);
+        video_record_deinit();
+        printf("init rec---\n");
+        initrec(hWnd);
+        if ((api_video_get_record_state() == VIDEO_STATE_PREVIEW) && api_get_sd_mount_state() == SD_STATE_IN)
+            api_start_rec();
+        return 0;
+    }
+    power_shutdown();
+    return 0;
+}
+void *usb_disconnect_process(void *arg)
+{
+    printf ("usb_disconnect_process\n");
+    usb_disconnect_poweroff(arg);
+    pthread_exit(NULL);
+}
+pthread_t run_usb_disconnect(HWND hWnd)
+{
+    pthread_t tid;
+    printf ("run_usb_disconnect\n");
+    if (pthread_create(&tid, NULL, usb_disconnect_process, (void *)hWnd)) {
+        printf("Create run_usb_disconnect thread failure\n");
+        return -1;
+    }
+    return tid;
+}
+static int shutdown_usb_disconnect(HWND hWnd)
+{
+    if (gshutdown == 1)
+        return -1;
+    gshutdown = 1;
+    run_usb_disconnect(hWnd);
+    return 0;
+}
+void ui_msg_manager_cb(void *msgData, void *msg0, void *msg1)
+{
+    struct public_message msg;
+    if (NULL != msgData) {
+        msg.id = ((struct public_message *)msgData)->id;
+        msg.type = ((struct public_message *)msgData)->type;
+    }
+    if (msg.type != TYPE_LOCAL && msg.type != TYPE_BROADCAST)
+        return;
+    switch (msg.id) {
+    case MSG_SET_LANGUAGE:
+        SetSystemLanguage(hMainWnd, (int)msg0);
+        break;
+    case MSG_SDCARDFORMAT_START:
+        printf("%s MSG_SDCARDFORMAT_START %d\n", __func__, (int)msg0);
+        loadingWaitBmp(hMainWnd);
+        break;
+    case MSG_SDCARDFORMAT_NOTIFY:
+        printf("%s MSG_SDCARDFORMAT_NOTIFY %d\n", __func__, (int)msg0);
+        if (msg0 < 0)
+            PostMessage(hMainWnd, MSG_SDCARDFORMAT, 0, EVENT_SDCARDFORMAT_FAIL);
+        else
+            PostMessage(hMainWnd, MSG_SDCARDFORMAT, 0, EVENT_SDCARDFORMAT_FINISH);
+        break;
+    case MSG_VIDEO_REC_START:
+        sec = 0;
+        InvalidateRect(hMainWnd, &msg_rcTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcRecimg, TRUE);
+        InvalidateRect (hMainWnd, &msg_rcWatermarkTime, TRUE);
+        InvalidateRect (hMainWnd, &msg_rcWatermarkLicn, TRUE);
+        InvalidateRect (hMainWnd, &msg_rcWatermarkImg, TRUE);
+        break;
+    case MSG_VIDEO_REC_STOP:
+        InvalidateRect(hMainWnd, &msg_rcTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcRecimg, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkLicn, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkImg, TRUE);
+        break;
+    case MSG_VIDEO_MIC_ONOFF:
+        InvalidateRect(hMainWnd, &msg_rcMic, FALSE);
+        break;
+    case MSG_VIDEO_SET_ABMODE:
+        InvalidateRect(hMainWnd, &msg_rcAB, FALSE);
+        break;
+    case MSG_VIDEO_SET_MOTION_DETE:
+        InvalidateRect(hMainWnd, &msg_rcMove, FALSE);
+        break;
+    case MSG_VIDEO_MARK_ONOFF:
+        InvalidateRect(hMainWnd, &msg_rcWatermarkTime, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkLicn, TRUE);
+        InvalidateRect(hMainWnd, &msg_rcWatermarkImg, TRUE);
+        break;
+    case MSG_VIDEO_ADAS_ONOFF:
+        adasflagtooff = 1;
+        InvalidateRect(hMainWnd, &adas_rc, TRUE);
+        break;
+    case MSG_VIDEO_UPDATETIME:
+        PostMessage(hMainWnd, MSG_VIDEOREC, (WPARAM)msg0, EVENT_VIDEOREC_UPDATETIME);
+        break;
+    case MSG_ADAS_UPDATE:
+        PostMessage(hMainWnd, MSG_ADAS, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_VIDEO_PHOTO_END:
+        SendNotifyMessage(hMainWnd, MSG_PHOTOEND, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_SDCORD_MOUNT_FAIL:
+        PostMessage(hMainWnd, MSG_SDMOUNTFAIL, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_SDCORD_CHANGE:
+        PostMessage(hMainWnd, MSG_SDCHANGE, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_FS_INITFAIL:
+        PostMessage(hMainWnd, MSG_FSINITFAIL, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_HDMI_EVENT:
+        SendMessage(hMainWnd, MSG_HDMI, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_CVBSOUT_EVENT:
+        SendMessage(hMainWnd, MSG_CVBSOUT, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_POWEROFF:
+        ui_deinit();
+        break;
+    case MSG_BATT_UPDATE_CAP:
+        PostMessage(hMainWnd, MSG_BATTERY, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_BATT_LOW:
+        shutdown_deinit(hMainWnd);
+        break;
+    case MSG_BATT_DISCHARGE:
+        PostMessage(hMainWnd, MSG_BATTERY, (WPARAM)msg0, (LPARAM)msg1);
+        shutdown_usb_disconnect(hMainWnd);
+        break;
+    case MSG_CAMERE_EVENT:
+        PostMessage(hMainWnd, MSG_CAMERA, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_USB_EVENT:
+        PostMessage(hMainWnd, MSG_USBCHAGE, (WPARAM)msg0, (LPARAM)msg1);
+        break;
+    case MSG_USER_RECORD_RATE_CHANGE:
+        break;
+    case MSG_USER_MDPROCESSOR:
+        break;
+    case MSG_USER_MUXER:
+        break;
+    case MSG_VIDEOPLAY_EXIT:
+        PostMessage(hMainWnd, MSG_VIDEOPLAY, (WPARAM)NULL,
+                    EVENT_VIDEOPLAY_EXIT);
+        break;
+    case MSG_VIDEOPLAY_UPDATETIME:
+        SendMessage(hMainWnd, MSG_VIDEOPLAY, (WPARAM)msg0, EVENT_VIDEOPLAY_UPDATETIME);
+        break;
+    default:
+        break;
+    }
+}
+
+static void gps_ui_control(HWND hWnd, BOOL bEraseBkgnd)
+{
+    InvalidateRect(hWnd, &msg_rcGpsState, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsSatellite, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsSpeed, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsLatitude, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsLongitude, bEraseBkgnd);
+    InvalidateRect(hWnd, &msg_rcGpsTime, bEraseBkgnd);
+}
+
+int collision_event_callback(int cmd, void *msg0, void *msg1)
+{
+    switch (cmd) {
+    case CMD_COLLISION:
+#ifdef CACHE_ENCODEDATA_IN_MEM
+        PostMessage(hMainWnd, MSG_COLLISION,
+                    (WPARAM)msg0, (LPARAM)msg1);
+
+        return COLLISION_CACHE_DURATION;
+#else
+        if ((SetMode == MODE_RECORDING) &&
+            (api_video_get_record_state() == VIDEO_STATE_PREVIEW)) {
+            video_record_blocknotify(BLOCK_PREV_NUM, BLOCK_LATER_NUM);
+            if (collision_rec_time >= COLLISION_CACHE_DURATION) {
+                video_record_savefile();
+                collision_rec_time = 0;
+                return COLLISION_CACHE_DURATION;
+            }
+
+            return (COLLISION_CACHE_DURATION - collision_rec_time);
+        }
+#endif
+        break;
+    default:
+        break;
+    }
+
+    return 0;
+}
+
+
+int key_event_callback(int keycode, int keyval, int islongpress)
+{
+	if (keyval == KBD_VAL_KEY_DOWN && !islongpress)
+		PostMessage(hMainWnd, MSG_KEYDOWN, (WPARAM)keycode, (LPARAM)0);
+	if (keyval == KBD_VAL_KEY_UP)
+		PostMessage(hMainWnd, MSG_KEYUP, (WPARAM)keycode, (LPARAM)0);
+	if (islongpress)
+		PostMessage(hMainWnd, MSG_KEYLONGPRESS, (WPARAM)keycode, (LPARAM)0);
+}
+
+static void sig_pipe_handler(int sig)
+{
+  printf("SIGPIPE\n");
+  return;
+}
+
+static void sig_int_handler(int sig)
+{
+  printf("exit with SIGINT\n");
+  exit(0);
+}
+
+int MiniGUIMain(int argc, const char* argv[])
+{
+    MSG Msg;
+    MAINWINCREATE CreateInfo;
+    /* HDC sndHdc; */
+    /* struct color_key key; */
+    char collision_level = 0;
+    char parkingrec = 0;
+
+	DBGMSG(NI, ("MiniGUIMain running...\n"));
+	signal(SIGPIPE, sig_pipe_handler);
+	signal(SIGINT, sig_int_handler);
+	if (0 != audio_dev_init()) {
+        DBGMSG(NI, ("audio_dev_init failed\n"));
+    }
+    if (loadres())
+        printf("loadres fail\n");
+    pthread_mutex_init(&set_mutex, NULL);
+	CreateInfo.MainWindowProc = CameraWinProc;
+	hMainWnd = CreateMainWindow(&CreateInfo);
+    if (hMainWnd == HWND_INVALID)
+        return -1;
+    RegisterMainWindow(hMainWnd);
+
+    api_poweron_init(ui_msg_manager_cb);
+	parameter_save_isp_max_resolution(1920, 1080);
+
+	kbd_init();
+	kbd_register(key_event_callback);
+
+    gsensor_init();
+    gsensor_use_interrupt(GSENSOR_INT2, GSENSOR_INT_STOP);
+
+    if (parameter_get_gps_mark()) {
+        if (gps_init(gps_send_callback, &ggps_send) == 0) {
+            memset(&ggps_info, 0, sizeof(struct gps_info));
+            gps_ui_control(hMainWnd, FALSE);
+        } else {
+            parameter_save_gps_mark(0);
+        }
+    }
+
+    /* register collision get data function */
+    collision_level = parameter_get_collision_level();
+    collision_init();
+    if (collision_level != 0)
+        collision_register();
+    collision_regeventcallback(collision_event_callback);
+
+    /* register parkingrec get data function */
+    /* register parkingrec get data function */
+    gparking = parameter_get_parkingmonitor();
+    parking_init();
+    if (gparking != PARKINGMONITOR_OFF)
+        parking_register();
+    parking_regeventcallback(parking_event_callback);
+
+	initrec(hMainWnd);
+    while (0 == GetMessage(&Msg, hMainWnd)) {
+        TranslateMessage(&Msg);
+        DispatchMessage(&Msg);
+    }
+
+	api_poweroff_deinit();
+   
+	collision_unregister();
+    parking_unregister();
+    parkingrec = parameter_get_parkingmonitor();
+    if (parkingrec != 0) {
+        gsensor_enable(1);
+        gsensor_use_interrupt(GSENSOR_INT2, GSENSOR_INT_START);
+    }
+    gsensor_release();
+
+    if(parameter_get_gps_mark())
+        gps_deinit(&ggps_send);
+
+    UnregisterMainWindow(hMainWnd);
+    MainWindowThreadCleanup(hMainWnd);
+    unloadres();
+	return 0;
+}
+#endif
diff --git a/noui/camera_ui.h b/noui/camera_ui.h
new file mode 100644
index 0000000..f94a380
--- /dev/null
+++ b/noui/camera_ui.h
@@ -0,0 +1,30 @@
+#ifndef __CAMERA_UI_H__
+#define __CAMERA_UI_H__
+#include <stdbool.h>
+#include "common.h"
+
+void ui_deinit_init_camera(HWND hWnd, char i, char j, char k);
+int sdcardformat_back(void *arg, int param);
+void ui_set_white_balance(int i);
+void ui_set_exposure_compensation(int i);
+void cmd_IDM_frequency(char i);
+void changemode(HWND hWnd, int mode);
+void cmd_IDM_CAR(HWND hWnd, char i);
+void startrec(HWND hWnd);
+void stoprec(HWND hWnd);
+
+void cmd_IDM_VIDEO_QUALITY(HWND hWnd, unsigned int qualiy_level);
+void cmd_IDM_DEBUG_VIDEO_BIT_RATE(HWND hWnd, unsigned int val);
+
+int getSD(void);
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+void start_motion_detection();
+void stop_motion_detection();
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/noui/camera_ui_def.h b/noui/camera_ui_def.h
new file mode 100644
index 0000000..869aca2
--- /dev/null
+++ b/noui/camera_ui_def.h
@@ -0,0 +1,329 @@
+#ifndef __CAMERA_UI_DEF_H__
+#define __CAMERA_UI_DEF_H__
+#ifdef WITHOUT_UI
+#include "vgui_api.h"
+#else
+#include <minigui/common.h>
+#endif
+#include <stdbool.h>
+#define MSG_USER 0x0800 /*<minigui/window.h>*/
+
+int video_SendMessage(HWND hWnd, int iMsg, WPARAM wParam, LPARAM lParam);
+void video_rkfb_get_resolution(int* width, int* height);
+int gsensor_GetValue(char* name);
+
+#define MSG_SDCHANGE (MSG_USER + 1)
+#define MSG_BATTERY (MSG_USER + 2)
+#define MSG_CAMERA (MSG_USER + 3)
+#define MSG_VIDEOREC (MSG_USER + 4)
+#define MSG_VIDEOPLAY (MSG_USER + 5)
+#define MSG_SDCARDFORMAT (MSG_USER + 6)
+#define MSG_USBCHAGE (MSG_USER + 7)
+#define MSG_FILTER (MSG_USER + 8)
+#define MSG_SDMOUNTFAIL (MSG_USER + 9)
+#define MSG_SDNOTFIT (MSG_USER + 10)
+#define MSG_ADAS (MSG_USER + 11)
+#define MSG_PHOTOEND (MSG_USER + 13)
+#define MSG_REPAIR (MSG_USER + 14)
+#define MSG_FSINITFAIL (MSG_USER + 15)
+#define MSG_HDMI (MSG_USER + 16)
+#define MSG_CVBSOUT (MSG_USER + 17)
+#define MSG_USB_DISCONNECT (MSG_USER + 18)
+#define MSG_RK_USER (MSG_USER + 30)
+#define MSG_ATTACH_USER_MUXER (MSG_RK_USER + 0)
+#define MSG_DETACH_USER_MUXER (MSG_RK_USER + 1)
+#define MSG_ATTACH_USER_MDPROCESSOR (MSG_RK_USER + 2)
+#define MSG_DETACH_USER_MDPROCESSOR (MSG_RK_USER + 3)
+#define MSG_RECORD_RATE_CHANGE (MSG_RK_USER + 4)
+#define MSG_COLLISION (MSG_RK_USER + 5)
+//
+struct FlagForUI {
+    int adasflagtooff;
+    bool formatflag;
+    int setmode_ui;
+    int sdcard_ui;
+    bool video_rec_state_ui;
+};
+
+//DEBUG
+#define REBOOT_TIME 10
+#define RECOVERY_TIME 5
+#define AWAKE_TIME 5
+#define STANDBY_TIME 5
+#define MODECHANGE_TIME 5
+#define VIDEO_TIME 2
+#define BEG_END_VIDEO_TIME 5
+#define PHOTO_TIME 5
+#define FWUPDATE_TEST_TIME 5
+
+//
+#define EVENT_VIDEOREC_UPDATETIME 1
+
+#define EVENT_VIDEOPLAY_UPDATETIME 1
+#define EVENT_VIDEOPLAY_EXIT 2
+
+#define EVENT_SDCARDFORMAT_FAIL 0
+#define EVENT_SDCARDFORMAT_FINISH 1
+
+#define IDM_NEW 1
+#define IDM_SAVE 3
+#define IDM_SAVEAS 4
+#define IDM_EXIT 5
+#define _ID_TIMER 106
+
+#define IDL_DIR 106
+#define IDL_FILE 110
+#define IDC_PATH 120
+#define IDC_LISTVIEW 121
+
+#define IDM_ABOUT_MP 103
+#define IDM_ABOUT_TIME 104
+#define IDM_ABOUT_CAR 105
+#define IDM_ABOUT_SETTING 106
+#define IDM_QUIT 107
+#define IDM_ABOUT_LINE1 108
+#define IDM_ABOUT_LINE2 109
+#define IDM_ABOUT_LINE3 110
+#define IDM_ABOUT_LINE4 111
+#define IDM_720P 112
+#define IDM_1080P 113
+#define IDM_1MIN 114
+#define IDM_3MIN 115
+#define IDM_5MIN 116
+#define IDM_OFF 117
+#define IDM_CAR1 118
+#define IDM_CAR2 119
+#define IDM_CAR3 120
+#define IDM_bright 121
+#define IDM_exposal 122
+#define IDM_detect 123
+#define IDM_mark 124
+#define IDM_record 125
+
+#define IDM_bright1 126
+#define IDM_bright2 127
+#define IDM_bright3 128
+#define IDM_bright4 129
+#define IDM_bright5 130
+
+#define IDM_exposal1 131
+#define IDM_exposal2 132
+#define IDM_exposal3 133
+#define IDM_exposal4 134
+#define IDM_exposal5 135
+
+#define IDM_detectOFF 136
+#define IDM_detectON 137
+
+#define IDM_markOFF 138
+#define IDM_markON 139
+
+#define IDM_recordOFF 140
+#define IDM_recordON 141
+
+#define IDM_ABOUT_AUTORECORD 142
+#define IDM_ABOUT_LANGUAGE 143
+#define IDM_ABOUT_FREQUENCY 144
+#define IDM_ABOUT_AVIN 145
+#define IDM_ABOUT_AUTOOFF 146
+#define IDM_ABOUT_SAVERR 147
+#define IDM_ABOUT_GSENSOR 148
+#define IDM_ABOUT_PARKING 149
+#define IDM_ABOUT_DATE_SET 150
+#define IDM_ABOUT_FORMAT 151
+#define IDM_ABOUT_DEF_SET 152
+#define IDM_ABOUT_VERSION 153
+
+#define IDM_autorecordOFF 154
+#define IDM_autorecordON 155
+
+#define IDM_langEN 156
+#define IDM_langCN 157
+
+#define IDM_50HZ 158
+#define IDM_60HZ 159
+#define IDM_MODE 160
+#define IDM_VEDIO 163
+#define IDM_PLAY 162
+#define IDM_CAMERA 161
+
+#define IDM_1M 164
+#define IDM_2M 165
+#define IDM_3M 166
+
+#define IDM_DELETE 167
+#define IDM_YES_DELETE 168
+#define IDM_NO_DELETE 169
+
+#define IDM_FILE 170
+
+#define IDM_FORMAT 171
+#define IDM_SETDATE 172
+#define IDC_BOX4 173
+#define IDC_HOUR 174
+#define IDC_MINUTE 175
+#define IDC_SECOND 176
+#define IDL_DAXIA 177
+#define IDL_YEAR 178
+#define IDL_MONTH 179
+#define IDL_DAY 180
+#define IDL_SEC 181
+
+#define IDC_PROMPT 182
+
+#define IDUSB 183
+#define USBBAT 184
+
+#define IDM_3DNR 185
+#define IDM_3DNROFF 186
+#define IDM_3DNRON 187
+
+#define IDM_ADAS 188
+#define IDM_ADAS_OFF 189
+#define IDM_ADAS_ON 190
+#define IDM_ADAS_SETTING 191
+
+#define IDM_BACKLIGHT 192
+#define IDM_BACKLIGHT_L 193
+#define IDM_BACKLIGHT_M 194
+#define IDM_BACKLIGHT_H 195
+
+#define IDC_SETMODE 196
+#define IDM_USB 197
+#define IDM_ADB 198
+#define IDM_FWVER 199
+#define IDM_RECOVERY 200
+
+#define IDM_1M_ph 201
+#define IDM_2M_ph 202
+#define IDM_3M_ph 203
+#define IDM_ABOUT_DEBUG 204
+
+#define IDM_BOOT_OFF 205
+#define IDM_RECOVERY_OFF 206
+#define IDM_AWAKE_1_OFF 207
+#define IDM_STANDBY_2_OFF 208
+#define IDM_MODE_CHANGE_OFF 209
+#define IDM_DEBUG_VIDEO_OFF 210
+#define IDM_BEG_END_VIDEO_OFF 211
+#define IDM_DEBUG_PHOTO_OFF 212
+
+#define IDM_BOOT_ON 213
+#define IDM_RECOVERY_ON 214
+#define IDM_AWAKE_1_ON 215
+#define IDM_STANDBY_2_ON 216
+#define IDM_MODE_CHANGE_ON 217
+#define IDM_DEBUG_VIDEO_ON 218
+#define IDM_BEG_END_VIDEO_ON 219
+#define IDM_DEBUG_PHOTO_ON 220
+
+#define IDM_BOOT 221
+#define IDM_RECOVERY_DEBUG 222
+#define IDM_AWAKE_1 223
+#define IDM_STANDBY_2 224
+#define IDM_MODE_CHANGE 225
+#define IDM_DEBUG_VIDEO 226
+#define IDM_BEG_END_VIDEO 227
+#define IDM_DEBUG_PHOTO 228
+
+#define IDM_FONTCAMERA 229
+#define IDM_BACKCAMERA 230
+#define IDM_FONT_1 231
+#define IDM_FONT_2 232
+#define IDM_FONT_3 233
+#define IDM_FONT_4 234
+#define IDM_BACK_1 235
+#define IDM_BACK_2 236
+#define IDM_BACK_3 237
+#define IDM_BACK_4 238
+
+#define IDM_COLLISION 239
+#define IDM_COLLISION_NO 240
+#define IDM_COLLISION_L 241
+#define IDM_COLLISION_M 242
+#define IDM_COLLISION_H 243
+#define IDM_PARKINGMONITOR 244
+#define IDM_PARKINGMONITOR_SHUTDOWN_MODE 245
+#define IDM_PARKINGMONITOR_OFF 246
+#define IDM_AUTOOFFSCREEN 247
+#define IDM_AUTOOFFSCREENOFF 248
+#define IDM_AUTOOFFSCREENON 249
+#define IDM_VIDEO_QUALITY 250
+#define IDM_VIDEO_QUALITY_H 251
+#define IDM_VIDEO_QUALITY_M 252
+#define IDM_VIDEO_QUALITY_L 253
+#define IDM_PARKINGMONITOR_SUSPEND_MODE 254
+#define IDM_MOTION_DETECT 255
+#define IDM_TIME_LAPSE_RECORD 256
+#define IDM_LICENSEPLATE_WATERMARK 260
+#define IDM_DEBUG_VIDEO_BIT_RATE 280
+
+#define IDM_DEBUG_VIDEO_BIT_RATE1 (IDM_DEBUG_VIDEO_BIT_RATE + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE2 (IDM_DEBUG_VIDEO_BIT_RATE1 + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE4 (IDM_DEBUG_VIDEO_BIT_RATE2 + 2)
+#define IDM_DEBUG_VIDEO_BIT_RATE5 (IDM_DEBUG_VIDEO_BIT_RATE4 + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE6 (IDM_DEBUG_VIDEO_BIT_RATE5 + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE8 (IDM_DEBUG_VIDEO_BIT_RATE6 + 2)
+#define IDM_DEBUG_VIDEO_BIT_RATE_MAX IDM_DEBUG_VIDEO_BIT_RATE8
+#define IDM_WIFI (IDM_DEBUG_VIDEO_BIT_RATE_MAX + 1)
+#define IDM_WIFION (IDM_WIFI + 1)
+#define IDM_WIFIOFF (IDM_WIFION + 1)
+
+#define IDM_DEBUG_TEMP (IDM_WIFIOFF + 1)
+#define IDM_DEBUG_TEMP_ON (IDM_DEBUG_TEMP + 1)
+#define IDM_DEBUG_TEMP_OFF (IDM_DEBUG_TEMP_ON + 1)
+
+#define IDM_IDC     (IDM_DEBUG_TEMP_OFF + 1)
+#define IDM_IDCOFF  (IDM_IDC + 1)
+#define IDM_IDCON   (IDM_IDCOFF + 1)
+
+#define IDM_timelapse               (IDM_IDCON + 1)
+#define IDM_TIME_LAPSE_OFF          (IDM_timelapse + 1)
+#define IDM_TIME_LAPSE_INTERNAL_1s  (IDM_TIME_LAPSE_OFF + 1)
+#define IDM_TIME_LAPSE_INTERNAL_5s  (IDM_TIME_LAPSE_INTERNAL_1s + 1)
+#define IDM_TIME_LAPSE_INTERNAL_10s (IDM_TIME_LAPSE_INTERNAL_5s + 1)
+#define IDM_TIME_LAPSE_INTERNAL_30s (IDM_TIME_LAPSE_INTERNAL_10s + 1)
+#define IDM_TIME_LAPSE_INTERNAL_60s (IDM_TIME_LAPSE_INTERNAL_30s + 1)
+
+#define IDM_CVBSOUT (IDM_TIME_LAPSE_INTERNAL_60s + 1)
+#define IDM_CVBSOUT_OFF (IDM_CVBSOUT + 1)
+#define IDM_CVBSOUT_ON_PAL (IDM_CVBSOUT + 2)
+#define IDM_CVBSOUT_ON_NTSC (IDM_CVBSOUT + 3)
+
+#define IDM_CIFCAMERA (IDM_CVBSOUT_ON_NTSC + 1)
+#define IDM_CIF_1 (IDM_CIFCAMERA + 1)
+#define IDM_CIF_2 (IDM_CIFCAMERA + 2)
+#define IDM_CIF_3 (IDM_CIFCAMERA + 3)
+#define IDM_CIF_4 (IDM_CIFCAMERA + 4)
+
+#define IDM_SETTING_FWUPDATE        (IDM_CIF_4 + 1)
+
+#define IDM_UVC     (IDM_SETTING_FWUPDATE + 1)
+
+#define IDM_FLIP            (IDM_UVC + 1)
+#define IDM_FLIP_OFF            (IDM_FLIP + 1)
+#define IDM_FLIP_ON         (IDM_FLIP_OFF + 1)
+
+#define IDM_DEBUG_FWUPDATE_TEST         (IDM_FLIP_ON + 1)
+
+#define IDM_GPS (IDM_DEBUG_FWUPDATE_TEST + 1)
+#define IDM_GPSOFF (IDM_GPS + 1)
+#define IDM_GPSON (IDM_GPSOFF + 1)
+
+#define FILE_TYPE_UNKNOW 0
+#define FILE_TYPE_PIC 1
+#define FILE_TYPE_VIDEO 2
+
+#define IDC_BUTTON_OK  1000
+#define IDC_STATIC1    1001
+#define IDC_STATIC2    1002
+#define IDC_STATIC3    1003
+#define IDC_STATIC4    1004
+#define IDC_STATIC5    1005
+#define IDC_STATIC6    1006
+#define IDC_STATIC7    1007
+#define IDC_STATIC8    1008
+
+#define FILE_TYPE_MAX 3
+
+#endif
diff --git a/noui/camera_ui_res_cn.h b/noui/camera_ui_res_cn.h
new file mode 100644
index 0000000..4b5fb0f
--- /dev/null
+++ b/noui/camera_ui_res_cn.h
@@ -0,0 +1,6 @@
+/*
+ * hello_res_cn.h
+ * GB2312 charset for Simplified Chinese support.
+ * wangjian<wangjian@minigui.org>
+ * 2008-2-14.
+ */
diff --git a/noui/camera_ui_res_en.h b/noui/camera_ui_res_en.h
new file mode 100644
index 0000000..245c1aa
--- /dev/null
+++ b/noui/camera_ui_res_en.h
@@ -0,0 +1,31 @@
+/*
+ * hello_res_en.h
+ * utf-8 charset for English support.
+ * wangjian<wangjian@minigui.org>
+ * 2008-2-14.
+ */
+
+#define open_ "open"
+#define copy "copy"
+#define delete_ "delete"
+#define rename "rename"
+#define properties_ "properties"
+#define File_name "File name"
+#define File_size "File size"
+#define Category "Category"
+#define Last_modified_time "Last modified time"
+#define ListView_control "ListView control"
+#define directory "directory"
+#define regular_file "regular file"
+#define are_you_really_want_to_delete_this_file \
+  "are you really want to delete this file?"
+#define warning "warning"
+#define Are_you_really_want_to_open_this_file \
+  "Are you really want to open this file?"
+#define Question "Question"
+
+#define OK "OK"
+#define Cancel "Cancel"
+#define SetDate "Set Date"
+#define SetLicense "Set License Plate "
+
diff --git a/noui/camera_ui_res_tw.h b/noui/camera_ui_res_tw.h
new file mode 100644
index 0000000..91c1c38
--- /dev/null
+++ b/noui/camera_ui_res_tw.h
@@ -0,0 +1,6 @@
+/*
+ * hello_res_tw.h
+ * big5 charset for Complex Chinese support.
+ * wangjian<wangjian@minigui.org>
+ * 2008-2-14.
+ */
diff --git a/noui/display_cvr.c b/noui/display_cvr.c
new file mode 100644
index 0000000..c8d2c8b
--- /dev/null
+++ b/noui/display_cvr.c
@@ -0,0 +1,34 @@
+/**
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ * author: hogan.wang@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include "display_cvr.h"
+#include "display.h"
+#include "ui_resolution.h"
+
+#define CVR_WINDOW_NUM 5
+
+static struct display_window cvr_window[CVR_WINDOW_NUM] = {
+    { 0, 0, WIN_W, WIN_H },
+    { WIN_W * 4 / 5, WIN_H * 4 / 5, WIN_W / 5, WIN_H / 5 },
+    { WIN_W * 3 / 5, WIN_H * 4 / 5, WIN_W / 5, WIN_H / 5 },
+    { WIN_W * 2 / 5, WIN_H * 4 / 5, WIN_W / 5, WIN_H / 5 },
+    { WIN_W * 1 / 5, WIN_H * 4 / 5, WIN_W / 5, WIN_H / 5 },
+};
+
+static bool cvr_position[CVR_WINDOW_NUM];
+
+void set_display_cvr_window(void)
+{
+    set_display_window(cvr_window, CVR_WINDOW_NUM, cvr_position);
+}
diff --git a/noui/display_cvr.h b/noui/display_cvr.h
new file mode 100644
index 0000000..a93a33b
--- /dev/null
+++ b/noui/display_cvr.h
@@ -0,0 +1,20 @@
+/**
+ * Copyright (C) 2017 Fuzhou Rockchip Electronics Co., Ltd
+ * author: hogan.wang@rock-chips.com
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __DISPLAY_CVR_H__
+#define __DISPLAY_CVR_H__
+
+void set_display_cvr_window(void);
+
+#endif
diff --git a/noui/libvui/fwk_gl_api.h b/noui/libvui/fwk_gl_api.h
new file mode 100644
index 0000000..c12182e
--- /dev/null
+++ b/noui/libvui/fwk_gl_api.h
@@ -0,0 +1,96 @@
+/*   ----------------------------------------------------------------------
+Copyright (C) 2014-2016 Fuzhou Rockchip Electronics Co., Ltd
+
+     Sec Class: Rockchip Confidential
+
+V1.0 Dayao Ji <jdy@rock-chips.com>
+---------------------------------------------------------------------- */
+
+
+#ifndef __FWK_GL_API_849390303__
+#define __FWK_GL_API_849390303__
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <strings.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/vfs.h>
+#include <fcntl.h>
+#include <semaphore.h>
+#include <unistd.h>
+
+#include "fwk_gl_def.h"
+
+#define LOG_TAG "fwk_msg"
+
+
+#if 1
+#define fwk_debug(fmt, ...) \
+	do { fprintf(stdout, LOG_TAG "(msg): line:[%04d] %s() \n", __LINE__, __FUNCTION__); fprintf(stdout, fmt, ##__VA_ARGS__); } while (0)
+
+
+
+#define FWK_CHECK( _X_ )	do{ fwk_debug(#_X_ "\r\n");\
+		if( (_X_)  != 0)\
+		{\
+			fwk_debug( "call %s failed ", #_X_);\
+		}\
+		fwk_debug("Call %s success!", #_X_);\
+	}while(0)
+#endif
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+extern int fwk_msg_init(void);
+extern int fwk_create_queue(int mod_id);
+extern void fwk_remove_queue(void);
+
+extern int fwk_send_message_ext(int sour, int dest,int msg_id, void *data, int size);
+extern FWK_MSG * fwk_get_message(int queque, int msgflg, int *ret);
+extern FWK_MSG* fwk_get_message_timeout(int queque, int timeout_ms, int *ret);
+extern int fwk_free_message(FWK_MSG **msg);
+
+
+
+
+
+extern void *FWK_Malloc(int size, const char * file, int line);
+extern void FWK_Free(const char *file, int line, void * mem);
+
+extern void *_FWK_MEMCPY (void * _DEST_PTR, int _DEST_LEN, void *  _SRC_PTR, int _SRC_LEN, int _SIZE, const char *file, int line);
+extern void *_FWK_MEMSET(void *_DEST_PTR, int _VAL, int _SIZE, const char *file, int line);
+extern char * _FWK_STRNCPY (char * _DEST_PTR, int  _DEST_LEN, const char *_SRC_PTR, int _SIZE, const char *file, int line);
+extern char *_FWK_STRCAT(char *_DEST_PTR, int  _DEST_LEN, const char *_SRC_PTR, const char *file, int line);
+extern int _FWK_STRLEN (char *_STR_PTR, const char *file, int line);
+extern int _FWK_SPRINTF (char * _DEST_PTR, int  _DEST_LEN, const char *file, int line, const char *_FMT, ...);
+
+
+
+#define FWK_MALLOC(size)		FWK_Malloc((size), __FILE__, __LINE__)
+#define FWK_FREE(_PMEM)		do{\
+							FWK_Free(__FILE__, __LINE__, (_PMEM));  \
+							if((_PMEM)) (_PMEM) = NULL;\
+							}while(0)
+#define FWK_MEMCPY(_DEST_PTR, _DEST_LEN, _SRC_PTR, _SRC_LEN, _SIZE)  _FWK_MEMCPY((_DEST_PTR), (_DEST_LEN), (_SRC_PTR), (_SRC_LEN), (_SIZE), __FILE__, __LINE__)
+#define FWK_MEMSET(_DEST_PTR, _VAL, _SIZE) _FWK_MEMSET((_DEST_PTR), (_VAL), (_SIZE), __FILE__, __LINE__)
+#define FWK_STRNCPY(_DEST_PTR, _DEST_LEN, _SRC_PTR, _SIZE) _FWK_STRNCPY((_DEST_PTR), (_DEST_LEN), (_SRC_PTR), (_SIZE), __FILE__, __LINE__)
+#define FWK_STRCAT(_DEST_PTR, _DEST_LEN, _SRC_PTR) _FWK_STRCAT((_DEST_PTR), (_DEST_LEN), (_SRC_PTR), __FILE__, __LINE__)
+#define FWK_STRLEN(_STR_PTR) _FWK_STRLEN((_STR_PTR), __FILE__, __LINE__)
+#define FWK_SPRINTF(_DEST_PTR, _DEST_LEN, _FMT, ...) _FWK_SPRINTF((_DEST_PTR),(_DEST_LEN), __FILE__,__LINE__,_FMT, ##__VA_ARGS__)
+
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
diff --git a/noui/libvui/fwk_gl_def.h b/noui/libvui/fwk_gl_def.h
new file mode 100644
index 0000000..c99cff9
--- /dev/null
+++ b/noui/libvui/fwk_gl_def.h
@@ -0,0 +1,3078 @@
+/*   ----------------------------------------------------------------------
+Copyright (C) 2014-2016 Fuzhou Rockchip Electronics Co., Ltd
+
+     Sec Class: Rockchip Confidential
+
+V1.0 Dayao Ji <jdy@rock-chips.com>
+---------------------------------------------------------------------- */
+
+
+#ifndef _FWK_GL_DEF_837689389163_
+#define _FWK_GL_DEF_837689389163_
+
+#include <stdio.h>
+#include <sys/msg.h>
+
+
+enum
+{
+    FWK_MOD_FWK = 1,
+    FWK_MOD_CONTROL,
+    FWK_MOD_VIEW,
+    FWK_MOD_CAMERA,/*Camera*/
+    FWK_MOD_PARAMETER, /*Parameter*/
+    FWK_MOD_STORAGE,/*Storage*/
+    FWK_MOD_GPS, /*GPS*/
+    FWK_MOD_WIFI, /*WiFi*/
+    FWK_MOD_CELLULAR,/*Cellular*/
+    FWK_MOD_WRTC, /*Web RTC*/
+    FWK_MOD_GB28181,
+    FWK_MOD_ONVIF,
+    FWK_MOD_GLUE,
+    FWK_MOD_IOTC,
+    FWK_MOD_RKP,
+    FWK_MOD_Reserverd1, /*be used! Don't Touch*/
+    FWK_MOD_Reserverd2,
+    FWK_MOD_Reserverd3,
+    FWK_MOD_Reserverd4,
+    FWK_MOD_Reserverd5,
+    FWK_MOD_Reserverd6,
+    FWK_MOD_VIDEO,
+    FWK_MOD_NUM
+};
+
+
+
+
+
+typedef struct
+{
+    int size;
+    int source;
+    int msg_id;
+    int dest;
+    char para[1];
+} FWK_MSG;
+
+
+typedef enum
+{
+    FWK_MSG_COMMON_IPC_MSG = 1,
+}FWK_MSG_COMMON_MSG_TYPE;
+
+
+
+#define MSG_GET_NO_WAIT			IPC_NOWAIT
+#define MSG_GET_WAIT_ROREVER		0
+
+
+#define FWK_MSG_MAX_NAME_LEN			32
+#define FWK_MSG_MAX_VALUE_LEN			32
+#define FWK_MSG_MAX_SETTING_ITEMS		22
+#define FWK_MSG_MAX_FILE_NAME_LEN		512
+#define FWK_MSG_MAX_URL_LEN				512
+
+typedef enum
+{
+    FWK_MSG_PROTOCOL_TYPE_GB28181 = 1,
+    FWK_MSG_PROTOCOL_TYPE_ONVIF,
+    FWK_MSG_PROTOCOL_TYPE_GUI,
+    FWK_MSG_PROTOCOL_TYPE_IOTC,
+    FWK_MSG_PROTOCOL_TYPE_PRK,
+    FWK_MSG_PROTOCOL_TYPE_RKAPI
+}FWK_MSG_PROTOCOL_TYPE;
+
+#define CHECK_PROTOCOL_RKAPI(ps_type)  (ps_type & 0xffff0000)
+#define RKAPI_PSTYPE_GET_KEY(ps_type)  ((ps_type & 0xffff0000) >> 16)
+
+#define CHECK_PROTOCOL_ONVIF(ps_type)  (ps_type & 0xffff0000)
+#define ONVIF_PSTYPE_GET_KEY(ps_type)  ((ps_type & 0xffff0000) >> 16)
+#define ONVIF_PSTYPE_GET_TYPE(ps_type)  ((ps_type & 0x0000ffff))
+
+
+
+typedef enum
+{
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_LEFT = 1,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_RIGHT,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_UP,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_DOWN,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_ZOOM_IN,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_ZOOM_OUT,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_PTZ_STOP_CONTROL,
+
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_RECORD,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_STOPRECORD,
+
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_SETGUARD,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_RESETGUARD,
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE_TELEBOOT
+}FWK_MSG_GB28181_DEVICE_CONTROL_TYPE;
+
+typedef struct{
+	int avIndex;
+	int session_id;
+}FWK_MSG_IOTC_HEADER;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_GET_DEVICE_INFO_REQ;
+
+typedef struct{
+	char deviceid[FWK_MSG_MAX_NAME_LEN+1];
+	char version[FWK_MSG_MAX_NAME_LEN+1];
+	char cputype[FWK_MSG_MAX_NAME_LEN+1];
+	char cpu[FWK_MSG_MAX_NAME_LEN+1];
+	char manufacturer[FWK_MSG_MAX_NAME_LEN+1];
+	char device_name[FWK_MSG_MAX_NAME_LEN+1];
+    char model[FWK_MSG_MAX_NAME_LEN +1];
+	char serio_number[FWK_MSG_MAX_NAME_LEN+1];
+}FWK_MSG_DEVICE_INFO;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_DEVICE_INFO dev_info;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_GET_DEVICE_INFO_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int req_type;//0 heart, 1 auto
+}FWK_MSG_GET_STATUS_INFO_REQ;
+
+typedef struct{
+	char deviceid[FWK_MSG_MAX_NAME_LEN+1];
+	char status[FWK_MSG_MAX_NAME_LEN+1];
+	char reason[FWK_MSG_MAX_NAME_LEN+1];
+}FWK_MSG_STATUS_INFO;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_STATUS_INFO status_info;
+	int req_type;
+}FWK_MSG_GET_STATUS_INFO_RSP;
+
+typedef struct{
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+    char deviceid[FWK_MSG_MAX_NAME_LEN+1];
+    char device_name[FWK_MSG_MAX_NAME_LEN+1];
+    char manufacturer[FWK_MSG_MAX_NAME_LEN+1];
+    char model[FWK_MSG_MAX_NAME_LEN+1];
+    char serio_number[FWK_MSG_MAX_NAME_LEN+1];
+    char status[FWK_MSG_MAX_NAME_LEN+1];
+    char ip_addr[FWK_MSG_MAX_NAME_LEN+1];
+    char pwd[FWK_MSG_MAX_NAME_LEN+1];
+    char latitude[FWK_MSG_MAX_NAME_LEN +1];
+    char longitude[FWK_MSG_MAX_NAME_LEN +1];
+}FWK_MSG_GET_DEVICE_CATALOG_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_DEVICE_STATUS_REQ;
+
+typedef struct{
+	char deviceid[FWK_MSG_MAX_NAME_LEN+1];
+	char status[FWK_MSG_MAX_NAME_LEN+1];
+	char reason[FWK_MSG_MAX_NAME_LEN+1];
+	char encode[FWK_MSG_MAX_NAME_LEN+1];
+	char record[FWK_MSG_MAX_NAME_LEN+1];
+	char duty_status[FWK_MSG_MAX_NAME_LEN+1];
+}FWK_MSG_DEVICE_STATUS;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_DEVICE_STATUS dev_status;
+}FWK_MSG_GET_DEVICE_STATUS_RSP;
+
+typedef struct{
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+    int did;
+    int subscription_status;
+    int subscription_reason;
+}FWK_MSG_NOTIFY_ALARM_REQ;
+
+typedef struct{
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+    char alarm_priority[FWK_MSG_MAX_NAME_LEN+1];
+    char alarm_method[FWK_MSG_MAX_NAME_LEN+1];
+    char alarm_time[FWK_MSG_MAX_NAME_LEN+1];
+    char alarm_description[FWK_MSG_MAX_NAME_LEN+1];
+    char longitude[FWK_MSG_MAX_NAME_LEN+1];
+    char latitude[FWK_MSG_MAX_NAME_LEN+1];
+    int did;
+    int subscription_status;
+    int subscription_reason;
+}FWK_MSG_NOTIFY_ALARM_RSP;
+
+#define FWK_MSG_MAX_DEVICE_CONTROL_ADDR    128
+#define FWK_MSG_MAX_DEVICE_CONTROL_BODY    1024
+#define FWK_MSG_MAX_DEVICE_CONTROL_CSEQ    24
+typedef struct {
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+    FWK_MSG_GB28181_DEVICE_CONTROL_TYPE cmd_type;
+    char from[FWK_MSG_MAX_DEVICE_CONTROL_ADDR];
+    char to[FWK_MSG_MAX_DEVICE_CONTROL_ADDR];
+    char body[FWK_MSG_MAX_DEVICE_CONTROL_BODY];
+    char cseq_number[FWK_MSG_MAX_DEVICE_CONTROL_CSEQ];
+    int ret;
+}FWK_MSG_DEVICE_CONTROL;
+
+#define FWK_MSG_MAX_DEVICE_CODE				(20)
+#define FWK_MSG_MAX_IP_STR_LEN				(63)
+#define FWK_MSG_MAX_PORT_STR_LEN			(10)
+#define FWK_MSG_UID_LEN						(20)
+#define FWK_MSG_MAX_DOMAIN_LEN				(40)
+#define FWK_MSG_MAX_PASSWORD_LEN			(32)
+typedef struct{
+	char     			deviceID[FWK_MSG_MAX_DEVICE_CODE+1];/*device ID*/
+	char     			alarmID[FWK_MSG_MAX_DEVICE_CODE+1]; /*alram ID*/
+	char     			reg_pwd[FWK_MSG_MAX_DEVICE_CODE+1]; /*register password*/
+	char     			server_name[FWK_MSG_MAX_DEVICE_CODE+1];/*SIP server Name*/
+	char     			sipserver_domain[FWK_MSG_MAX_DOMAIN_LEN+1]; /*SIP server domain name*/
+	char     			realm[FWK_MSG_MAX_DOMAIN_LEN+1];/* Realm that device belong to*/
+	char     			sipserver_ip[FWK_MSG_MAX_IP_STR_LEN+1];/*SIP server IP*/
+	char     			sipserver_port[FWK_MSG_MAX_PORT_STR_LEN+1]; /*SIP server port,default is 5060*/
+	char     			local_port[FWK_MSG_MAX_PORT_STR_LEN+1];/*local sip port, default is 5062*/
+	unsigned char     	transfer_protocol;/*0:UDP  1:TCP*/
+	unsigned int     	keepalive_interval;  /*second*/
+	unsigned int    	register_period;/*register valid period*/
+	char				device_name[FWK_MSG_MAX_DEVICE_CODE+1];
+	char				manufacturer[FWK_MSG_MAX_DEVICE_CODE+1];
+	char				model[FWK_MSG_MAX_DEVICE_CODE+1];
+	char				iotc_uid[FWK_MSG_UID_LEN+1];
+	unsigned char 		alarm_guard;/*0:OFFDUTY 1:ONDUTY else ALARM*/
+	char				avpassword[FWK_MSG_MAX_PASSWORD_LEN+1];
+	unsigned char 		reserved[5]; /*reserved*/
+}RK_PROTOCOL_CFG;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_CONTROL_RK_PROTOCOL_CFG_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	RK_PROTOCOL_CFG cfg;
+}FWK_MSG_CONTROL_RK_PROTOCOL_CFG_RSP;
+
+
+#define RK_PLATFORM_CFG_PARAMETER_VER_LEN		(12-1)
+#define RK_PLATFORM_CFG_FIRMWARE_VER_LEN		(30-1)
+#define RK_PLATFORM_CFG_WIFI_SSID_LEN			(33-1)
+#define RK_PLATFORM_CFG_WIFI_PASS_LEN			(65-1)
+
+typedef struct{
+  char pararater_version[RK_PLATFORM_CFG_PARAMETER_VER_LEN+1];
+  char firmware_version[RK_PLATFORM_CFG_FIRMWARE_VER_LEN+1];
+  char wifi_ssid[RK_PLATFORM_CFG_WIFI_SSID_LEN+1];
+  char wifi_pass[RK_PLATFORM_CFG_WIFI_PASS_LEN+1];
+  char sta_wifi_ssid[RK_PLATFORM_CFG_WIFI_SSID_LEN+1];
+  char sta_wifi_pwd[RK_PLATFORM_CFG_WIFI_PASS_LEN+1];
+  int wifi_mode;
+  int wifi_en;
+  int vcam_resolution;
+  int ccam_resolution;
+  short recordtime;
+  int abmode;
+  int wb;
+  int ex;
+  int movedete;
+  int timemark;
+  int voicerec;
+  int video_de;
+  int video_mark;
+  int video_audioenable;
+  int video_autorec;
+  int video_lan;
+  int video_fre;
+  int video_3dnr;
+  int video_adas;
+  int video_backlt;
+  int video_usb;
+  int video_fontcamera;
+  int video_backcamera;
+  int vcam_resolution_photo;
+  int Debug_reboot;
+  int Debug_recovery;
+  int Debug_awake;
+  int Debug_standby;
+  int Debug_mode_change;
+  int Debug_video;
+  int Debug_beg_end_video;
+  int Debug_photo;
+  int Debug_temp;
+  short back_width;
+  short back_height;
+  int back_fps;
+  short front_width;
+  short front_height;
+  int front_fps;
+  short cif_inputid;
+  int colli_level;
+  int video_leavecarrec;
+  short screenoff_time;
+  unsigned int bit_rate_per_pixel;
+  int video_idc;
+  int video_md_sensitivity;
+}RK_PLATFORM_CFG;
+
+#define FWK_MSG_JSON_BUF_SIZE	(1024)
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char json_message[FWK_MSG_JSON_BUF_SIZE+1];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_JSON_MESSAGE;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char json_message[FWK_MSG_JSON_BUF_SIZE+1];
+	FWK_MSG_IOTC_HEADER iotc_header;
+	int is_broadcast;
+}FWK_MSG_JSON_MESSAGE_RSP;
+
+
+typedef enum
+{
+    FWK_MSG_CONTROL_COMMU_TYPE_GPS = 1,
+    FWK_MSG_CONTROL_COMMU_TYPE_WIFI,
+    FWK_MSG_CONTROL_COMMU_TYPE_CELLULAR,
+    FWK_MSG_CONTROL_COMMU_TYPE_WATERMARK,
+    FWK_MSG_CONTROL_COMMU_TYPE_MOVING,
+    FWK_MSG_CONTROL_COMMU_TYPE_FORMAT,
+    FWK_MSG_CONTROL_COMMU_TYPE_FACTORY_RESET,
+    FWK_MSG_CONTROL_COMMU_TYPE_RECORD,
+    FWK_MSG_CONTROL_COMMU_TYPE_VOICE,
+    FWK_MSG_CONTROL_COMMU_TYPE_3DNR,
+    FWK_MSG_CONTROL_COMMU_TYPE_IDC,
+    FWK_MSG_CONTROL_COMMU_TYPE_LDW,
+    FWK_MSG_CONTROL_COMMU_TYPE_FORCE_IDR,
+    FWK_MSG_CONTROL_COMMU_TYPE_ODT
+}FWK_MSG_CONTROL_COMMU_CMD_TYPE;
+
+typedef  struct 
+{
+   FWK_MSG_PROTOCOL_TYPE ps_type;
+   FWK_MSG_CONTROL_COMMU_CMD_TYPE cmdType;
+   int operType; /*0: OFF     1: ON*/
+   FWK_MSG_IOTC_HEADER iotc_header;
+} FWK_MSG_CONTROL_COMMU_REQ;
+
+typedef  struct 
+{
+   FWK_MSG_PROTOCOL_TYPE ps_type;
+   FWK_MSG_CONTROL_COMMU_CMD_TYPE cmdType; 
+   int operType; /*0: OFF     1: ON*/
+   int result; /*0:  Success      others: failed*/
+   FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_COMMU_RSP;
+
+
+typedef enum
+{
+    FWK_MSG_CONTROL_VALUE_TYPE_RESOLUTION = 1,
+    FWK_MSG_CONTROL_VALUE_TYPE_RECORD_TIME,
+    FWK_MSG_CONTROL_VALUE_TYPE_EXPOSURE,
+    FWK_MSG_CONTROL_VALUE_TYPE_WB,
+    FWK_MSG_CONTROL_VALUE_TYPE_CONTRAST,
+    FWK_MSG_CONTROL_VALUE_TYPE_PICTURE_RESOLUTION,
+    FWK_MSG_CONTROL_VALUE_TYPE_STREAM_QUALITY,
+    FWK_MSG_CONTROL_VALUE_TYPE_MOVING_SENSITIVITY,
+    FWK_MSG_CONTROL_VALUE_TYPE_PLAY_VOLUME,
+    FWK_MSG_CONTROL_VALUE_TYPE_ODT_LEVEL,
+    FWK_MSG_CONTROL_VALUE_TYPE_PLAY_BRIGHTNESS,
+    FWK_MSG_CONTROL_VALUE_TYPE_PLAY_CONTRAST,
+    FWK_MSG_CONTROL_VALUE_TYPE_PLAY_SATURATION,
+    FWK_MSG_CONTROL_VALUE_TYPE_PLAY_SHARPNESS
+}FWK_MSG_CONTROL_VALUE_CMD_TYPE;
+
+typedef enum
+{
+    FWK_MSG_TEST_CMD_RECOVERY_VALUE,
+
+}FWK_MSG_TEST_CMD_TYPE;
+
+typedef struct
+{
+   FWK_MSG_PROTOCOL_TYPE ps_type;
+   FWK_MSG_TEST_CMD_TYPE cmdType;
+   char value;
+   FWK_MSG_IOTC_HEADER iotc_header;
+   
+}FWK_MSG_CONTROL_TEST_RSP;
+
+typedef struct
+{
+   FWK_MSG_PROTOCOL_TYPE ps_type;
+   FWK_MSG_TEST_CMD_TYPE cmdType;
+   FWK_MSG_IOTC_HEADER iotc_header;
+
+}FWK_MSG_CONTROL_TEST_REQ;
+
+
+typedef enum{
+	FWK_MSG_CONTROL_VIDEO_RESOLUTION_1080P = 1,
+	FWK_MSG_CONTROL_VIDEO_RESOLUTION_720P
+}FWK_MSG_CONTROL_VIDEO_RESOLUTION;
+
+typedef enum{
+	FWK_MSG_CONTROL_PICTURE_RESOLUTION_1M = 1,
+	FWK_MSG_CONTROL_PICTURE_RESOLUTION_2M,
+	FWK_MSG_CONTROL_PICTURE_RESOLUTION_3M
+}FWK_MSG_CONTROL_PICTURE_RESOLUTION;
+
+
+typedef enum
+{
+    FWK_MSG_CONTROL_WB_VALUE_AUTO = 0,
+    FWK_MSG_CONTROL_WB_VALUE_DAYLIGHT,
+    FWK_MSG_CONTROL_WB_VALUE_CLOUDY,
+    FWK_MSG_CONTROL_WB_VALUE_INCANDESCENT,
+    FWK_MSG_CONTROL_WB_VALUE_FLUORESCENT
+}FWK_MSG_CONTROL_VALUE_WB;
+
+
+
+typedef struct
+{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_VALUE_CMD_TYPE cmdType;
+	int value;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_VALUE_REQ;
+
+typedef struct
+{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_VALUE_CMD_TYPE cmdType;
+	int value;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_VALUE_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	unsigned int year;
+	unsigned int month;
+	unsigned int day;
+	unsigned int hour;
+	unsigned int minute;
+	unsigned int second;
+	int isdst;
+	int is_ntp;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_DATE_TIME;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_WRTC_DATE_TIME dt;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_DT_RSP;
+
+typedef struct {
+	unsigned int year;
+	unsigned int month;
+	unsigned int day;
+	unsigned int hour;
+	unsigned int minute;
+	unsigned int second;
+	int isdst;
+	int is_ntp;
+}FWK_MSG_DATA_T;
+
+
+
+#define FWK_MSG_CONTROL_WRTC_MAX_NAME_LEN			(32)
+#define FWK_MSG_CONTROL_WRTC_MAX_VALUE_LEN			(32)
+#define FWK_MSG_CONTROL_WRTC_MAX_SETTING_ITEMS		(22)
+#define FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN		(512)
+#define FWK_MSG_CONTROL_WRTC_MAX_URL_LEN			(512)
+#define FWK_MSG_CONTROL_WRTC_MAX_RECORD_TIME_MAX_LEN (20)
+#define FWK_MSG_CONTROL_WRTC_MAX_RECORD_NAME_MAX_LEN (30)
+#define FWK_MSG_CONTROL_WRTC_MAX_RECORD_LIST_ITEMS  (20)
+#define FWK_MSG_CONTROL_WRTC_MAX_RECORD_DIR_PATH  (30)
+
+typedef struct{
+	char itemName[FWK_MSG_CONTROL_WRTC_MAX_NAME_LEN+1];
+	int valueType;/*0:int   1:char*  2 bool  3 date*/
+	int value;
+	bool bValue;
+	char valueStr[FWK_MSG_CONTROL_WRTC_MAX_VALUE_LEN+1];
+	FWK_MSG_CONTROL_WRTC_DATE_TIME dt;
+}FWK_MSG_CONTROL_SETTING_ITEM;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char szName[FWK_MSG_CONTROL_WRTC_MAX_NAME_LEN+1];
+	int nCount;
+	FWK_MSG_CONTROL_SETTING_ITEM  items[FWK_MSG_CONTROL_WRTC_MAX_SETTING_ITEMS];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_SETTINGS_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_SETTINGS_REQ;
+
+typedef struct{
+	char fileName[FWK_MSG_CONTROL_WRTC_MAX_RECORD_NAME_MAX_LEN+1];
+	long fileSize;
+}FWK_MSG_CONTROL_RECORD_LIST_ITEM;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char szName[FWK_MSG_CONTROL_WRTC_MAX_NAME_LEN+1];
+	int nCount;
+	int result;
+	char dirPath[FWK_MSG_CONTROL_WRTC_MAX_RECORD_DIR_PATH+1];
+	FWK_MSG_CONTROL_RECORD_LIST_ITEM  items[FWK_MSG_CONTROL_WRTC_MAX_RECORD_LIST_ITEMS];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_RECORD_LIST_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+	char start_time[FWK_MSG_CONTROL_WRTC_MAX_RECORD_TIME_MAX_LEN+1];
+	char end_time[FWK_MSG_CONTROL_WRTC_MAX_RECORD_TIME_MAX_LEN+1];
+	int page_count;
+	int type;
+	char last_name[FWK_MSG_CONTROL_WRTC_MAX_RECORD_NAME_MAX_LEN+1];
+}FWK_MSG_CONTROL_WRTC_GET_RECORD_LIST_REQ;
+
+
+typedef struct{
+		FWK_MSG_PROTOCOL_TYPE ps_type;
+		char path[FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN+1];
+		int size;
+		int result;
+		FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_TAKE_PICTURE_NOTIFY;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_TAKE_PICTURE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char pwd[FWK_MSG_CONTROL_WRTC_MAX_VALUE_LEN+1];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_WIFI_PASSWD_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_WIFI_PASSWD_RSP;
+
+typedef enum{
+	FWK_MSG_CONTROL_WRTC_GET_FILES_PICTURE = 1,
+	FWK_MSG_CONTROL_WRTC_GET_FILES_VIDEO
+}FWK_MSG_CONTROL_FILE_REQ_TYPE_T;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_FILE_REQ_TYPE_T reqType;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_FILES_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_FILE_REQ_TYPE_T reqType;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_FILES_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char file_name[FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN+1];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_FILE_INFO_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char file_name[FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN+1];
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_FILE_INFO_RSP;
+
+typedef enum{
+	FWK_MSG_CONTROL_WRTC_GET_FILES_D_VIDEO = 1,
+	FWK_MSG_CONTROL_WRTC_GET_FILES_D_PICTURE,
+	FWK_MSG_CONTROL_WRTC_GET_FILES_D_EVENT_VIDEO
+}FWK_MSG_CONTROL_FILE_LIST_REQ_D_TYPE_T;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_FILE_LIST_REQ_D_TYPE_T reqType;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_FILE_LIST_D_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_FILE_LIST_REQ_D_TYPE_T reqType;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_FILE_LIST_D_RSP;
+
+#define FWK_MSG_MAX_NOTIFY_MESSAGE_ALARM_DESC        2048
+typedef enum{
+	FWK_MSG_ALARM_METHOD_ALL = 0,
+	FWK_MSG_ALARM_METHOD_TELE = 1,
+	FWK_MSG_ALARM_METHOD_DEVICE = 2 ,
+	FWK_MSG_ALARM_METHOD_SMS = 3,
+	FWK_MSG_ALARM_METHOD_GPS = 4,
+	FWK_MSG_ALARM_METHOD_VIDEO = 5,
+	FWK_MSG_ALARM_METHOD_DEVICE_FAULT = 6,
+	FWK_MSG_ALARM_METHOD_OTHER
+}FWK_MSG_ALARM_METHOD;
+
+typedef enum{
+	FWK_MSG_VIDEO_ALARM_TYPE_MANUAL = 1,
+	FWK_MSG_VIDEO_ALARM_TYPE_MOTION,
+	FWK_MSG_VIDEO_ALARM_TYPE_CARRY_OVER,
+	FWK_MSG_VIDEO_ALARM_TYPE_REMOVE,
+	FWK_MSG_VIDEO_ALARM_TYPE_TRIP_LINE,
+	FWK_MSG_VIDEO_ALARM_TYPE_INVASION,
+	FWK_MSG_VIDEO_ALARM_TYPE_CONVERSE,
+	FWK_MSG_VIDEO_ALARM_TYPE_LINGER,
+	FWK_MSG_VIDEO_ALARM_TYPE_FLOW,
+	FWK_MSG_VIDEO_ALARM_TYPE_DENSITY,
+	FWK_MSG_VIDEO_ALARM_TYPE_EXCEPTION,
+	FWK_MSG_VIDEO_ALARM_TYPE_RAPID
+}FWK_MSG_VIDEO_ALARM_TYPE;
+
+typedef struct{
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+    int alarm_priority;
+    int alarm_method;
+    char alarm_desc[FWK_MSG_MAX_NOTIFY_MESSAGE_ALARM_DESC+1];
+    double alarm_longitude;
+    double alarm_latitude;
+    int alarm_type;
+    int alarm_eventtype;
+}FWK_MSG_NOTIFY_MESSAGE_ALARM;
+
+typedef struct{
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+    FWK_MSG_IOTC_HEADER iotc_header;
+    char iotc_uid[FWK_MSG_UID_LEN+1];
+    int alarm_format;//0:not format, 1:need format
+    char alarm_desc[FWK_MSG_MAX_NOTIFY_MESSAGE_ALARM_DESC+1];
+}FWK_MSG_NOTIFY_SDCARD_ALARM;
+
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_TAKE_PICTURE			("TakePicture")
+#define FWK_MSG_CONTROL_WRTC_CMD_FORCR_IDR			("ForceIdr")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_RESOLUTION			("Resolutionl")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RESOLUTION_720P		("720P")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RESOLUTION_1080P		("1080P")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RESOLUTION_UNSUPPORT		("UnSupport")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_PICTURE_RESOLUTION			("PicQuality")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RESOLUTION_PICTURE_1M		("1M")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RESOLUTION_PICTURE_2M		("2M")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RESOLUTION_PICTURE_3M		("3M")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_RECORD_TIME			("RecordTime")
+#define FWK_MSG_CONTROL_WRTC_VALUE_RECORD_TIME_MINUTE		(60)
+#define FWK_MSG_CONTROL_WRTC_VALUE_RECORD_TIME_2MINUTE		(120)
+#define FWK_MSG_CONTROL_WRTC_VALUE_RECORD_TIME_3MINUTE		(180)
+#define FWK_MSG_CONTROL_WRTC_VALUE_RECORD_TIME_5MINUTE		(300)
+
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_EXPOSURE			("Exposure")
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_MINUS_3		(-3)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_MINUS_2		(-2)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_MINUS_1		(-1)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_ZERO		(0)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_1			(1)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_2			(2)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_3			(3)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_4			(4)
+#define FWK_MSG_CONTROL_WRTC_VALUE_EXPOSURE_5			(5)
+
+
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_WB					("WhiteBalance")
+#define FWK_MSG_CONTROL_WRTC_VALUE_WB_AUTO				("Auto")
+#define FWK_MSG_CONTROL_WRTC_VALUE_WB_DAYLIGHT			("Daylight")
+#define FWK_MSG_CONTROL_WRTC_VALUE_WB_CLOUDY			("Cloudy")
+#define FWK_MSG_CONTROL_WRTC_VALUE_WB_INCANDESCENT		("Incandescent")
+#define FWK_MSG_CONTROL_WRTC_VALUE_WB_FLUORESCENT		("Fluorescent")
+
+typedef enum{
+	FWK_MSG_STREAM_QUALITY_TYPE_MAX = 0x01,
+	FWK_MSG_STREAM_QUALITY_TYPE_HIGH = 0x02,
+	FWK_MSG_STREAM_QUALITY_TYPE_MIDDLE = 0x03,
+	FWK_MSG_STREAM_QUALITY_TYPE_LOW = 0x04,
+	FWK_MSG_STREAM_QUALITY_TYPE_MIN = 0x05
+}FWK_MSG_STREAM_QUALITY_TYPE;
+
+#define FWK_MSG_CONTROL_WRTC_SET_STREAM_QUALITY			("SetStreamCtrl")
+#define FWK_MSG_CONTROL_WRTC_STREAM_QUALITY_MAX			("QUALITY_MAX")
+#define FWK_MSG_CONTROL_WRTC_STREAM_QUALITY_HIGH		("QUALITY_HIGH")
+#define FWK_MSG_CONTROL_WRTC_STREAM_QUALITY_MIDDLE		("QUALITY_MIDDLE")
+#define FWK_MSG_CONTROL_WRTC_STREAM_QUALITY_LOW			("QUALITY_LOW")
+#define FWK_MSG_CONTROL_WRTC_STREAM_QUALITY_MIN			("QUALITY_MIN")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_REBOOT	                	("Reboot")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_CONTRAST			("Contrast")
+#define FWK_MSG_CONTROL_WRTC_VALUE_CONTRAST_0			(0)
+#define FWK_MSG_CONTROL_WRTC_VALUE_CONTRAST_1			(1)
+#define FWK_MSG_CONTROL_WRTC_VALUE_CONTRAST_2			(2)
+#define FWK_MSG_CONTROL_WRTC_VALUE_CONTRAST_3			(3)
+#define FWK_MSG_CONTROL_WRTC_VALUE_CONTRAST_4			(4)
+#define FWK_MSG_CONTROL_WRTC_VALUE_CONTRAST_5			(5)
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_WATERMARK			("WaterMark")
+#define FWK_MSG_CONTROL_WRTC_VALUE_BOOL_TRUE			("true")
+#define FWK_MSG_CONTROL_WRTC_VALUE_BOOL_FALSE			("false")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_3DNR				("3DNR")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_IDC				("IDC")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_LDW				("LDW")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_MOVING				("Moving")
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_MOVING_SENSITIVITY	("MovingSensitivity")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_ODT				("ODT")
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_ODT_LEVEL			("ODTLevel")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_WIFI				("WiFi")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_GPS				("Gps")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_MOBILE				("Mobile")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_FORMAT				("Format")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_RESET_FACTORY		("ResetFactory")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_ALL_PARAMS	("GetSettings")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_PLAY_CONFIG	("GetPlayConfig")
+#define FWK_MSG_CONTROL_WRTC_CMD_PLAY_BRIGHTNESS	("PlayBrightness")
+#define FWK_MSG_CONTROL_WRTC_CMD_RECOVERY_VALUE       ("Recovery_Value")
+#define FWK_MSG_CONTROL_WRTC_CMD_PLAY_VOLUME		("PlayVolume")
+#define FWK_MSG_CONTROL_WRTC_CMD_PLAY_CONTRAST		("PlayContrast")
+#define FWK_MSG_CONTROL_WRTC_CMD_PLAY_SATURATION	("PlaySaturation")
+#define FWK_MSG_CONTROL_WRTC_CMD_PLAY_SHARPNESS	("PlaySharpness")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_RECORD_LIST	("GetRecordList")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SETTINGS		("Settings")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_RECORD      ("Record")
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_SOUND        ("Sound")
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_DATE_TIME        ("DateTime")
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_WIFI_PASSWD	("WfiPasswd")
+
+#define FWK_MSG_CONTROL_WRTC_TAKE_PICTURE_RSP		("TakePictureLocation")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_PICTURE_FILES	("PictureList")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_VIDEO_FILES	("VideoList")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_FILE_INFO		("FileInfo")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_SDCARD_INFO	("GetSdcardInfo")
+#define FWK_MSG_CONTROL_WRTC_SDCARD_INFO	("SdcardInfo")
+#define FWK_MSG_CONTROL_WRTC_SDCARD_PICTURE_PATH				("/mnt/sdcard/PHOTO-FRONT")
+#define FWK_MSG_CONTROL_WRTC_SDCARD_VIDEO_PATH					("/mnt/sdcard/VIDEO-FRONT")
+#define FWK_MSG_CONTROL_WRTC_SDCARD_VIDEO_R_PATH				("/mnt/sdcard/VIDEO-REAR")
+#define FWK_MSG_CONTROL_WRTC_SDCARD_VIDEO_F_ALT_PATH			("/mnt/sdcard/video_f_rlt")
+#define FWK_MSG_CONTROL_WRTC_SDCARD_VIDEO_DCIM_PATH				("/mnt/sdcard/DCIM")
+#define FWK_MSG_CONTROL_MAX_ITEMS_PER_RSP_MSG					(15)
+#define FWK_MSG_CONTROL_MAX_FILED_ITEMS_PER_MSG_MSG				(6)
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_FILE_LIST_D			("FileListD")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_FILE_LIST_TYPE_V		("Video")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_FILE_LIST_TYPE_P		("Picture")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_FILE_LIST_TYPE_EV		("EventVideo")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_DEL_FILE			("DelFile")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_FAULT				("fault")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_ENCODER_PARAMS				("SetEncoderParameters")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_ENCODER_PARAMS				("GetEncoderParameters")
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char path[FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN+1];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_DEL_FILE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char path[FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN+1];
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_DEL_FILE_RSP;
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_DEVICE_INFO				("DeviceInfo")
+#define FWK_MSG_CONTROL_WRTC_DEVICE_INFO_CHIP_NAME				("RV1108")
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_AP_INFO				("ApInfo")
+
+typedef struct{
+	char ssid[FWK_MSG_CONTROL_WRTC_MAX_NAME_LEN+1];
+	char pwd[FWK_MSG_CONTROL_WRTC_MAX_VALUE_LEN+1];
+}FWK_MSG_CONTROL_AP_INFO;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_CONTROL_AP_INFO info;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_AP_INFO_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_AP_INFO_REQ;
+
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_CAM_NUMBER				("CamNumber")
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int number;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_CAM_NUMBER_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_CAM_NUMBER_REQ;
+
+
+
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_RTSP_URL				("RtspURL")
+typedef struct{
+	char camfront[FWK_MSG_CONTROL_WRTC_MAX_URL_LEN+1];
+	char camback[FWK_MSG_CONTROL_WRTC_MAX_URL_LEN+1];
+}FWK_MSG_RTSP_URL;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_RTSP_URL url;
+	int result;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_RTSP_URL_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_MSG_CONTROL_WRTC_GET_RTSP_URL_REQ;
+
+#define FWK_MSG_CONTROL_WRTC_CMD_ALARM_NOTIFY				("AlarmNotify")
+#define FWK_MSG_CONTROL_WRTC_CMD_ALARM_REASON_MOTION		("Motion Detect")
+#define FWK_MSG_CONTROL_WRTC_CMD_ALARM_REASON_DEVICE		("Device")
+#define FWK_MSG_CONTROL_WRTC_CMD_SDCARD_NOTIFY		        ("SdcardNotify")
+
+
+
+typedef enum
+{
+	FWK_PROTOCOL_PTZ_CMD_STOP					= 0,
+	FWK_PROTOCOL_PTZ_CMD_UP						= 1,
+	FWK_PROTOCOL_PTZ_CMD_DOWN					= 2,
+	FWK_PROTOCOL_PTZ_CMD_LEFT					= 3,
+	FWK_PROTOCOL_PTZ_CMD_LEFT_UP				= 4,
+	FWK_PROTOCOL_PTZ_CMD_LEFT_DOWN				= 5,
+	FWK_PROTOCOL_PTZ_CMD_RIGHT					= 6,
+	FWK_PROTOCOL_PTZ_CMD_RIGHT_UP				= 7,
+	FWK_PROTOCOL_PTZ_CMD_RIGHT_DOWN				= 8,
+	FWK_PROTOCOL_PTZ_CMD_AUTO					= 9,
+	FWK_PROTOCOL_PTZ_CMD_SET_POINT				= 10,
+	FWK_PROTOCOL_PTZ_CMD_CLEAR_POINT			= 11,
+	FWK_PROTOCOL_PTZ_CMD_GOTO_POINT				= 12,
+
+	FWK_PROTOCOL_PTZ_CMD_SET_MODE_START			= 13,
+	FWK_PROTOCOL_PTZ_CMD_SET_MODE_STOP			= 14,
+	FWK_PROTOCOL_PTZ_CMD_MODE_RUN				= 15,
+
+	FWK_PROTOCOL_PTZ_CMD_MENU_OPEN				= 16,
+	FWK_PROTOCOL_PTZ_CMD_MENU_EXIT				= 17,
+	FWK_PROTOCOL_PTZ_CMD_MENU_ENTER				= 18,
+
+	FWK_PROTOCOL_PTZ_CMD_FLIP					= 19,
+	FWK_PROTOCOL_PTZ_CMD_START					= 20,
+
+	FWK_PROTOCOL_PTZ_CMD_LENS_APERTURE_OPEN			= 21,
+	FWK_PROTOCOL_PTZ_CMD_LENS_APERTURE_CLOSE		= 22,
+
+	FWK_PROTOCOL_PTZ_CMD_LENS_ZOOM_IN				= 23,
+	FWK_PROTOCOL_PTZ_CMD_LENS_ZOOM_OUT				= 24,
+
+	FWK_PROTOCOL_PTZ_CMD_LENS_FOCAL_NEAR			= 25,
+	FWK_PROTOCOL_PTZ_CMD_LENS_FOCAL_FAR				= 26,
+
+	FWK_PROTOCOL_PTZ_CMD_AUTO_PAN_SPEED				= 27,
+	FWK_PROTOCOL_PTZ_CMD_AUTO_PAN_LIMIT				= 28,
+	FWK_PROTOCOL_PTZ_CMD_AUTO_PAN_START				= 29,
+
+	FWK_PROTOCOL_PTZ_CMD_PATTERN_START				= 30,
+	FWK_PROTOCOL_PTZ_CMD_PATTERN_STOP				= 31,
+	FWK_PROTOCOL_PTZ_CMD_PATTERN_RUN				= 32,
+
+	FWK_PROTOCOL_PTZ_CMD_SET_AUX					= 33,
+	FWK_PROTOCOL_PTZ_CMD_CLEAR_AUX					= 34,
+	FWK_PROTOCOL_PTZ_CMD_MOTOR_RESET_POSITION		= 35,
+}FWK_PROTOCOL_PTZ_CMD;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_PTZ_CMD cmd;
+}FWK_PROTOCOL_PTZ_REQ;
+
+typedef enum {
+	FWK_PROTOCOL_FRONT_DEVICE_CONTROL_PTZ,
+	FWK_PROTOCOL_FRONT_DEVICE_CONTROL_FI,
+	FWK_PROTOCOL_FRONT_DEVICE_CONTROL_PRESET,
+	FWK_PROTOCOL_FRONT_DEVICE_CONTROL_CRUISE,
+	FWK_PROTOCOL_FRONT_DEVICE_CONTROL_SCAN,
+	FWK_PROTOCOL_FRONT_DEVICE_CONTROL_AUX
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL;
+
+typedef struct {
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int pan;
+	int pan_speed;
+	int tilt;
+	int tilt_speed;
+	int zoom;
+	int zoom_speed;
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL_PTZ_REQ;
+
+typedef struct {
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int focus;
+	int focus_speed;
+	int iris;
+	int iris_speed;
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL_FI_REQ;
+
+typedef struct {
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int cmd_type;
+	int expand;
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL_PRESET_REQ;
+
+typedef struct {
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int cmd_type;
+	int group_num;
+	int pos_num;
+	int measure;
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL_CRUISE_REQ;
+
+typedef struct {
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int cmd_type;
+	int cmd_type2;
+	int group_num;
+	int measure;
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL_SCAN_REQ;
+
+typedef struct {
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int cmd_type;
+	int target;
+}FWK_PROTOCOL_FRONT_DEVICE_CONTROL_AUX_REQ;
+
+typedef struct{
+	int session_id;
+	int iotc_channel_id;
+	int avIndex;
+	int rdt_channel;
+}FWK_PROTOCOL_RDT_HEADER;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char file_location[FWK_MSG_MAX_FILE_NAME_LEN+1];
+}FWK_PROTOCOL_CONTROL_UPDATE;
+
+typedef struct{
+	int is_sd_exist;
+	long long free_size;
+	long long total_size;
+}FWK_PROTOCOL_CONTROL_SDCARD_INFO;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+	FWK_PROTOCOL_CONTROL_SDCARD_INFO sdcard_info;
+}FWK_MSG_CONTROL_WRTC_GET_SDCARD_INFO_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+	int reserved;
+}FWK_GLUE_REVERSE_CALLBACK_HEADER;
+
+typedef struct {
+	int width;
+	int height;
+	int bit_rate;
+	int frame_rate;
+	int level;
+	int gop_size;
+	int profile;
+	// quality - quality parameter
+	// mpp does not give the direct parameter in different protocol.
+	// mpp provide total 5 quality level 1 ~ 5
+	// 0 : MPP_ENC_RC_QUALITY_WORST
+	// 1 : MPP_ENC_RC_QUALITY_WORSE
+	// 2 : MPP_ENC_RC_QUALITY_MEDIUM
+	// 3 : MPP_ENC_RC_QUALITY_BETTER
+	// 4 : MPP_ENC_RC_QUALITY_BEST
+	// 5 : MPP_ENC_RC_QUALITY_CQP
+	//	   (extra CQP level means special constant-qp (CQP) mode)
+	int quality;
+	int qp_init;
+	int qp_step;
+	int qp_min;
+	int qp_max;
+	// rc_mode - rate control mode
+	// Mpp balances quality and bit rate by the mode index
+	// Mpp provide 2 level of balance mode of quality and bit rate
+	// 0 : MPP_ENC_RC_MODE_VBR
+	// 1 : MPP_ENC_RC_MODE_CBR
+	int rc_mode;
+} RK_VIDEO_CONFIG;
+
+typedef struct {
+	/*
+	0-8,
+	1-16,
+	2-32,
+	3-NB*/
+	int fmt;
+	int bit_rate;
+	int nb_samples;
+	int sample_rate;
+	int nb_channels;
+	//uint64_t channel_layout;
+}RK_AUDIO_CONFIG;
+
+typedef enum
+{
+	RK_AV_STREAM_TYPE_MAIN	= 0,
+	RK_AV_STREAM_TYPE_SUB	= 1,
+	RK_AV_STREAM_TYPE_THIRD = 2,
+}RK_AV_STREAM_TYPE;
+#define MAX_STREAMS (3)
+
+typedef struct _RK_AV_STREAM_INFO
+{
+	RK_AV_STREAM_TYPE stream_type;
+	RK_VIDEO_CONFIG video_config;
+	RK_AUDIO_CONFIG audio_config;
+}RK_AV_STREAM_INFO;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_PROTOCOL_VIDEO_GET_PARAM_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int stream_num;
+	RK_AV_STREAM_INFO stream_info[MAX_STREAMS];
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_PROTOCOL_VIDEO_GET_PARAM_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	RK_AV_STREAM_TYPE stream_type;
+	RK_AV_STREAM_INFO stream_info;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_PROTOCOL_VIDEO_SET_PARAM_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+	RK_AV_STREAM_INFO stream_info;
+	FWK_MSG_IOTC_HEADER iotc_header;
+}FWK_PROTOCOL_VIDEO_SET_PARAM_RSP;
+
+typedef enum {
+    WIFI_AP = 0,
+    WIFI_STATION,
+    WIFI_MONITOR,
+    ETHERNET,
+}NETWORK_TYPE;
+
+typedef struct {
+    FWK_MSG_PROTOCOL_TYPE ps_type;
+    FWK_MSG_IOTC_HEADER iotc_header;
+    NETWORK_TYPE network_type;
+    char ssid[65];
+    char password[65];
+    char dhcp_en;
+    char static_ip[64];
+    char netmask[64];
+    char gateway[64];
+    char dns1[64];
+    char dns2[64];
+} FWK_PROTOCOL_NETWORK_INFO;
+
+#define FWK_MSG_CONTROL_WRTC_CMD_SET_NETWORK_PARAMS				("SetNetworkParameters")
+#define FWK_MSG_CONTROL_WRTC_CMD_GET_NETWORK_PARAMS				("GetNetworkParameters")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_TYPE            ("NETWORK_TYPE")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_TYPE_WIFI			("WIFI")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_TYPE_ETH                   ("ETH")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_TYPE_WIFI_AP            ("AP")
+
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_DHCP_EN            ("DHCP_EN")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_STATIC_IP         ("STATIC_IP")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_NETMASK            ("NETMASK")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_GATEWAY            ("GATEWAY")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_DNS1                   ("DNS1")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_DNS2                  ("DNS2")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_SSID                  ("SSID")
+#define FWK_MSG_CONTROL_WRTC_CMD_NETWORK_PASSWD             ("PASSWD")
+
+
+#define FWK_MSG_ONVIF_MAX_NAME_STR									(64)
+#define FWK_MSG_ONVIF_MAX_URI_STR									(128)
+#define MAX_ONVIF_TOPICSET_ANY										(1024)
+#define FWK_MSG_ONVIF_MAX_FIXED_SCOPE_NUM					(4)
+#define FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM					(8)
+#define FWK_MSG_ONVIF_MAX_SCOPE_NUM							(FWK_MSG_ONVIF_MAX_FIXED_SCOPE_NUM + FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM)
+#define FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN					(64) //128
+#define MAX_TOPIC_NAME_SPACE_LOCATION_NUM	(1)
+
+
+#define ONVIF_DISCOVERY_ENDPOINT_LEN		(128)
+#define ONVIF_DISCOVERY_MAC_LEN			(20)
+#define ONVIF_DISCOVERY_IP_LEN			(32)
+#define ONVIF_EMPTY_IP		("0.0.0.0")
+
+#define ONVIF_ETH_IF_NAME	("eth0")
+#define ONVIF_WLAN_IF_NAME	("wlan0")
+
+#define SYS_DNS_FILE "/etc/resolv.conf"
+
+
+
+#define ONVIF_NVT_DEVICE_TYPE				("tdn:NetworkVideoTransmitter")
+#define ONVIF_FIX_SCOPE_0					("onvif://www.onvif.org/type/NVT")
+#define ONVIF_FIX_SCOPE_1					("onvif://www.onvif.org/type/Device")
+
+
+#define ONVIF_CONFIG_SCOPE_0					("onvif://www.onvif.org/Profile/Streaming")
+#define ONVIF_CONFIG_SCOPE_1					("onvif://www.onvif.org/hardware/RV1108")
+#define ONVIF_CONFIG_SCOPE_2					("onvif://www.onvif.org/name/ipc")
+#define ONVIF_CONFIG_SCOPE_3					("onvif://www.onvif.org/location/country/china")
+
+#define ONVIF_ENTRY_FORMAT								("http://%s:%d/onvif/device_service.cgi")
+#define ONVIF_UPGRADE_ENTRY_FORMAT						("http://%s:%d/onvif/onvif_service_firmware_upgrade.cgi")
+
+
+typedef struct{
+	unsigned char  disvovery_mode;
+	char device_type[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char fixed_scope[FWK_MSG_ONVIF_MAX_FIXED_SCOPE_NUM][FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+	char config_scope[FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM][FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+	unsigned char 		reserved[178]; 
+}RK_PROTOCOL_ONVIF_CFG;
+
+
+typedef struct {
+	int (*protocol_take_photo)(FWK_GLUE_REVERSE_CALLBACK_HEADER* preverse_header);
+	int (*protocol_set_video_resolution)(FWK_MSG_CONTROL_VIDEO_RESOLUTION v_resolution);
+	int (*protocol_set_picture_resolution)(FWK_MSG_CONTROL_PICTURE_RESOLUTION v_resolution);
+	int (*protocol_set_record_duration_time)(int rduration);
+	int (*protocol_set_exposure)(int eval);
+	int (*protocol_set_white_balance)(FWK_MSG_CONTROL_VALUE_WB wval);
+	int (*protocol_set_contrast)(int cval);
+	int (*protocol_set_gps_switch)(int on_off);
+	int (*protocol_set_wifi_switch)(int on_off);
+	int (*protocol_set_cellular_switch)(int on_off);
+	int (*protocol_set_watermark)(int on_off);
+	int (*protocol_set_motion_detect)(int on_off);
+	int (*protocol_sdcard_format)(FWK_GLUE_REVERSE_CALLBACK_HEADER* preverse_header);
+	int (*protocol_factory_reset)(void);
+	int (*protocol_set_record_switch)(int on_off);
+	int (*protocol_set_sound_switch)(int on_off);
+	int (*protocol_set_date_time)(FWK_MSG_DATA_T* pDate);
+	int (*protocol_set_ap_password)(char* pPwd);
+	int (*protocol_get_video_file_duration)(const char* video_file_name);
+	int (*protocol_get_device_info)(FWK_MSG_DEVICE_INFO* pdev_info);
+	int (*protocol_get_softap_info)(FWK_MSG_CONTROL_AP_INFO* pInfo);
+	int (*protocol_get_camera_number)(void);
+	int (*protocol_get_rtsp_url)(FWK_MSG_RTSP_URL* pUrl);
+	int (*protocol_read_protocol_cfg)(RK_PROTOCOL_CFG* pCfg);
+	int (*protocol_write_protocol_cfg)(RK_PROTOCOL_CFG* pCfg);
+	int (*protocol_read_platform_cfg)(RK_PLATFORM_CFG* pCfg);
+	int (*protocol_handle_ptz_cmd)(FWK_PROTOCOL_PTZ_CMD cmd, void* pArg);
+	int (*protocol_get_status_info)(FWK_MSG_STATUS_INFO* status_info);
+	int (*protocol_get_device_status)(FWK_MSG_DEVICE_STATUS* dev_status);
+	int (*protocol_set_3dnr)(int on_off);
+	int (*protocol_set_idc)(int on_off);
+	int (*protocol_reboot)(void);
+	int (*protocol_set_debug_recovery)(char value);
+	int (*protocol_get_debug_recovery)(char* value);
+	int (*protocol_set_ldw)(int on_off);
+	int (*protocol_set_stream_ctrl)(FWK_MSG_STREAM_QUALITY_TYPE stream_ctrl);
+	int (*protocol_get_stream_ctrl)(FWK_MSG_STREAM_QUALITY_TYPE* pType);
+	int	(*protocol_get_sdcard_info)(FWK_PROTOCOL_CONTROL_SDCARD_INFO* pSdcardInfo);
+	int (*protocol_firmware_update)(FWK_PROTOCOL_CONTROL_UPDATE* pUpdate);
+	int (*protocol_ctrl_video_transfer)(char* url);
+	int (*protocol_video_get_param)(FWK_PROTOCOL_VIDEO_GET_PARAM_RSP *rsp);
+	int (*protocol_video_set_param)(RK_AV_STREAM_INFO *info, RK_AV_STREAM_TYPE stream_type);
+	int (*protocol_force_idr)(FWK_MSG_PROTOCOL_TYPE type);
+	int (*protocol_set_moving_sensitivity)(int val);
+	int (*protocol_set_play_volume)(int val);
+	int (*protocol_get_play_volume)(int channel);
+	int (*protocol_set_odt)(int on_off);
+	int (*protocol_set_odt_level)(int val);
+	int (*protocol_get_odt_level)(void);
+	int (*protocol_set_play_brightness)(int val);
+	int (*protocol_get_play_brightness)();
+	int (*protocol_set_play_contrast)(int val);
+	int (*protocol_get_play_contrast)();
+	int (*protocol_set_play_saturation)(int val);
+	int (*protocol_get_play_saturation)();
+	int (*protocol_set_play_sharpness)(int val);
+	int (*protocol_get_play_sharpness)();
+	int (*protocol_get_record_list)(FWK_MSG_CONTROL_WRTC_GET_RECORD_LIST_REQ* req, FWK_MSG_CONTROL_WRTC_GET_RECORD_LIST_RSP* rsp);
+	int (*protocol_get_network_param)(FWK_PROTOCOL_NETWORK_INFO *network);
+	int (*protocol_set_network_param)(FWK_PROTOCOL_NETWORK_INFO *network);
+	int (*protocol_read_onvif_cfg)(RK_PROTOCOL_ONVIF_CFG* pCfg);
+	int (*protocol_write_onvif_cfg)(RK_PROTOCOL_ONVIF_CFG* pCfg);
+
+}FWK_GLUE_PROTOCOL_CALLBACK;
+
+typedef enum 
+{
+	RK_IOTC_AV_MEDIA_CODEC_UNKNOWN			= 0x00,
+	RK_IOTC_AV_MEDIA_CODEC_VIDEO_MPEG4		= 0x4C,
+	RK_IOTC_AV_MEDIA_CODEC_VIDEO_H263		= 0x4D,
+	RK_IOTC_AV_MEDIA_CODEC_VIDEO_H264		= 0x4E,
+	RK_IOTC_AV_MEDIA_CODEC_VIDEO_MJPEG		= 0x4F,
+	
+    RK_IOTC_AV_MEDIA_CODEC_AUDIO_AAC       	= 0x88,
+    RK_IOTC_AV_MEDIA_CODEC_AUDIO_G711U     	= 0x89,
+    RK_IOTC_AV_MEDIA_CODEC_AUDIO_G711A     	= 0x8A,
+    RK_IOTC_AV_MEDIA_CODEC_AUDIO_ADPCM     	= 0X8B,
+	RK_IOTC_AV_MEDIA_CODEC_AUDIO_PCM		= 0x8C,
+	RK_IOTC_AV_MEDIA_CODEC_AUDIO_SPEEX		= 0x8D,
+	RK_IOTC_AV_MEDIA_CODEC_AUDIO_MP3		= 0x8E,
+    RK_IOTC_AV_MEDIA_CODEC_AUDIO_G726      	= 0x8F,
+
+}RK_IOTC_AV_ENUM_CODECID;
+
+
+typedef enum 
+{
+	RK_IOTC_AV_FRAME_FLAG_PBFRAME	= 0x00,	/* A/V P/B frame..  */
+	RK_IOTC_AV_FRAME_FLAG_IFRAME	= 0x01,	/* A/V I frame. */
+	RK_IOTC_AV_FRAME_FLAG_MD		= 0x02,	/* For motion detection. */
+	RK_IOTC_AV_FRAME_FLAG_IO		= 0x03,	/* For Alarm IO detection. */
+}RK_IOTC_AV_ENUM_FRAMEFLAG;
+
+
+typedef enum
+{
+	RK_IOTC_AV_AUDIO_SAMPLE_8K		= 0x00,
+	RK_IOTC_AV_AUDIO_SAMPLE_11K		= 0x01,
+	RK_IOTC_AV_AUDIO_SAMPLE_12K		= 0x02,
+	RK_IOTC_AV_AUDIO_SAMPLE_16K		= 0x03,
+	RK_IOTC_AV_AUDIO_SAMPLE_22K		= 0x04,
+	RK_IOTC_AV_AUDIO_SAMPLE_24K		= 0x05,
+	RK_IOTC_AV_AUDIO_SAMPLE_32K		= 0x06,
+	RK_IOTC_AV_AUDIO_SAMPLE_44K		= 0x07,
+	RK_IOTC_AV_AUDIO_SAMPLE_48K		= 0x08,
+}RK_IOTC_AV_ENUM_AUDIO_SAMPLERATE;
+
+
+typedef enum
+{
+	RK_IOTC_AV_AUDIO_DATABITS_8		= 0,
+	RK_IOTC_AV_AUDIO_DATABITS_16	= 1,
+}RK_IOTC_AV_ENUM_AUDIO_DATABITS;
+
+
+typedef enum
+{
+	RK_IOTC_AV_AUDIO_CHANNEL_MONO		= 0,
+	RK_IOTC_AV_AUDIO_CHANNEL_STERO		= 1,
+}RK_IOTC_AV_ENUM_AUDIO_CHANNEL;
+
+
+typedef struct _RK_IOTC_AV_FRAMEINFO
+{
+	unsigned short codec_id;
+	unsigned char flags;
+	unsigned char cam_index;
+
+	unsigned char onlineNum;/*number of client connected this device*/
+	unsigned char reserve1[3];
+
+	unsigned int reserve2;
+	unsigned int timestamp;	/* Timestamp of the frame, in milliseconds */
+	unsigned int videoWidth;
+    	unsigned int videoHeight;
+}RK_IOTC_AV_FRAMEINFO;
+
+
+typedef enum{
+	RK_IOTC_AV_TYPE_VIDEO = 1,
+	RK_IOTC_AV_TYPE_AUDIO
+}RK_IOTC_AV_TYPE;
+
+typedef struct{
+	int (*protocol_iotc_av_get_frame_info)(RK_IOTC_AV_TYPE av_type, RK_IOTC_AV_FRAMEINFO* pFrameinfo);
+	int (*protocol_iotc_av_get_video_frame)(char* frame_data,int frame_size,RK_IOTC_AV_FRAMEINFO* pFrameinfo);
+	int (*protocol_iotc_av_get_audio_frame)(char* frame_data,int frame_size,RK_IOTC_AV_FRAMEINFO* pFrameinfo);
+	int (*protocol_iotc_av_play_audio)(char* buf,int buf_size,RK_IOTC_AV_FRAMEINFO* pFrameinfo);
+	void (*protocol_iotc_av_on_audio_transfer_start)(void);
+	void (*protocol_iotc_av_on_audio_transfer_stop)(void);
+	void (*protocol_iotc_av_on_video_transfer_start)(void);
+	void (*protocol_iotc_av_on_video_transfer_stop)(void);
+	void (*protocol_iotc_av_on_video_client_login)(void);
+
+}FWK_PROTOCOL_IOTC_AV_CALLBACK;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+	char path[FWK_MSG_CONTROL_WRTC_MAX_FILE_NAME_LEN+1];
+	int result;
+}FWK_PROTOCOL_TAKE_PHOTO_NOTIFY;
+
+typedef struct {
+	int (*protocol_reverse_notify_sdcard_format)(FWK_GLUE_REVERSE_CALLBACK_HEADER* preverse_header, int l_result);
+    int (*protocol_reverse_message_alarm)(FWK_MSG_NOTIFY_MESSAGE_ALARM* para);
+	int (*protocol_reverse_notify_take_photo)(FWK_PROTOCOL_TAKE_PHOTO_NOTIFY* preverse_header);
+	int (*protocol_reverse_notify_device_fault)(void);
+	int (*protocol_reverse_notify_sdcard_alarm)(FWK_MSG_NOTIFY_SDCARD_ALARM* parm);
+}FWK_GLUE_PROTOCOL_REVERSE_CALLBACK;
+
+#define FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE			(1024)
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char cmd_buffer[FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE+1];
+}FWK_PROTOCOL_RDT_CMD_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char cmd_buffer[FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE+1];
+	char file_name[FWK_MSG_MAX_FILE_NAME_LEN+1];
+	unsigned int file_size;
+	int l_result;
+}FWK_PROTOCOL_RDT_CMD_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char file_name[FWK_MSG_MAX_FILE_NAME_LEN+1];
+	long start_pos;
+	long end_pos;
+}FWK_PROTOCOL_RDT_FILE_TRANSFER_IND;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char cmd_buffer[FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE+1];
+	char file_name[FWK_MSG_MAX_FILE_NAME_LEN+1];
+	int ftyp_size;
+	int free_size;
+	int mdat_size;
+	int moov_size;
+	int l_result;
+}FWK_PROTOCOL_RDT_MP4_FILE_CUT_CMD_RSP;
+
+
+#define FWK_MSG_CONTROL_FILE_TRANSFER_CMD				("FileTransfer")
+#define FWK_MSG_CONTROL_START_FILE_TRANSFER_CMD			("StartFileTransfer")
+#define FWK_MSG_CONTROL_MP4_FILE_CUT_CMD				("Mp4FileCut")
+
+
+typedef enum{
+	FWK_PROTOCOL_FILE_DOWNLOAD_SAVE_LOCATION_TYPE_MEMORY = 0x01,
+	FWK_PROTOCOL_FILE_DOWNLOAD_SAVE_LOCATION_TYPE_STORAGE = 0x02
+}FWK_PROTOCOL_FILE_DOWNLOAD_SAVE_LOCATION;
+
+typedef enum{
+	FWK_PROTOCOL_FILE_DOWNLOAD_TYPE_UPDATER = 0x01,
+	FWK_PROTOCOL_FILE_DOWNLOAD_TYPE_NORMAL = 0x02
+}FWK_PROTOCOL_FILE_DOWNLOAD_TYPE;
+
+typedef enum{
+	FWK_PROTOCOL_FILE_CHECK_STATUS_OK = 0x01,
+	FWK_PROTOCOL_FILE_CHECK_STATUS_DAMAGE = 0x02
+}FWK_PROTOCOL_FILE_CHECK_STATUS;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char cmd_buffer[FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE+1];
+	unsigned int file_crc;
+	FWK_PROTOCOL_FILE_DOWNLOAD_SAVE_LOCATION save_location;
+	unsigned int file_size;
+	char file_location[FWK_MSG_MAX_FILE_NAME_LEN+1];
+	int l_result;
+}FWK_PROTOCOL_RDT_FILE_DOWNLOAD_CMD_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	unsigned int file_crc;
+	unsigned int file_size;
+	char file_location[FWK_MSG_MAX_FILE_NAME_LEN+1];
+}FWK_PROTOCOL_RDT_DOWNLOAD_NOTIFY;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char cmd_buffer[FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE+1];
+	unsigned int file_crc;
+	unsigned int file_size;
+	char file_location[FWK_MSG_MAX_FILE_NAME_LEN+1];
+	FWK_PROTOCOL_FILE_CHECK_STATUS download_file_status;
+}FWK_PROTOCOL_RDT_DOWNLOAD_NOTIFY_RSP;
+
+
+typedef enum{
+	FWK_PROTOCOL_FILE_CHECK_FIRMWARE_STATUS_OK = 0x01,
+	FWK_PROTOCOL_FILE_CHECK_FIRMWARE_STATUS_NOT_FIRMWARE = 0x02,
+	FWK_PROTOCOL_FILE_CHECK_FIRMWARE_STATUS_FILE_NOT_EXIST = 0x03
+}FWK_PROTOCOL_FILE_CHECK_FIRMWARE_STATUS;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_PROTOCOL_RDT_HEADER rdt_header;
+	char cmd_buffer[FWK_PROTOCOLRK_IOTC_RDT_CMD_BUF_SIZE+1];
+	char file_location[FWK_MSG_MAX_FILE_NAME_LEN+1];
+	FWK_PROTOCOL_FILE_CHECK_FIRMWARE_STATUS download_file_status;
+}FWK_PROTOCOL_RDT_UPDATE_INFO;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char url[FWK_MSG_CONTROL_WRTC_MAX_URL_LEN+1];
+}FWK_PROTOCOL_VIDEO_TRANSFER_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_PROTOCOL_VIDEO_TRANSFER_RSP;
+
+
+
+
+#define FWK_MSG_CONTROL_FILE_DOWNLOAD_CMD					("FileDownload")
+
+
+#define FWK_MSG_CONTROL_FILE_DOWNLOAD_NOTIFY_CMD			("FileDownloadDone")
+#define FWK_MSG_CONTROL_UPDATER_CMD							("Updater")
+
+#define FWK_PROTOCOL_FILE_DOWNLOAD_SAVE_LOCATION_MEMORY_PATH	("/tmp/")
+#define FWK_PROTOCOL_FILE_DOWNLOAD_SAVE_LOCATION_STORAGE_PATH	("/mnt/sdcard/")
+
+#define FWK_MSG_CONTROL_FILE_CHECK_STATUS_OK					("OK")
+#define FWK_MSG_CONTROL_FILE_CHECK_STATUS_DAMAGE				("File Damage")
+
+#define FWK_MSG_CONTROL_FILE_CHECK_STATUS_NOT_FIRMWARE			("Not Firmware")
+#define FWK_MSG_CONTROL_FILE_CHECK_STATUS_FILE_NOT_EXIST		("File Not Exist")
+
+#define FWK_PROTOCOL_FILE_DOWNLOAD_NO_SPACE						("No Space Left")
+#define FWK_PROTOCOL_FILE_DOWNLOAD_NO_SD_CARD					("SD Card Not Exist")
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IOTC_HEADER iotc_header;
+	char old_password[FWK_MSG_MAX_PASSWORD_LEN+1];
+	char new_password[FWK_MSG_MAX_PASSWORD_LEN+1];
+	int result;
+}FWK_MSG_PASSWORD_INFO;
+
+#ifndef _MGUI_COMMON_H
+typedef int HWND;
+typedef int WPARAM;
+typedef WPARAM LPARAM;
+typedef unsigned UINT;;
+#endif
+
+typedef struct
+{
+  int msgid;
+  WPARAM wparam;
+  LPARAM lparam;
+  int buf_len;
+  char buf[0];
+}ipc_msg;
+
+typedef enum  {
+	DISCONNECTED = 0,
+	CONNECTING,
+	CONNECTED,
+}NETWORK_STATE;
+
+typedef struct {
+	int msg_id;
+	NETWORK_TYPE network_type;
+	NETWORK_STATE network_state;
+	char ssid[65];
+	char password[65];
+	char dhcp_en;
+	char static_ip[64];
+	char netmask[64];
+	char gateway[64];
+	char dns1[64];
+	char dns2[64];
+} network_info;
+
+#define MSG_USER 0x0800 /*<minigui/window.h>*/
+#define MSG_SDCHANGE (MSG_USER + 1)
+#define MSG_BATTERY (MSG_USER + 2)
+#define MSG_CAMERA (MSG_USER + 3)
+#define MSG_VIDEOREC (MSG_USER + 4)
+#define MSG_VIDEOPLAY (MSG_USER + 5)
+#define MSG_SDCARDFORMAT (MSG_USER + 6)
+#define MSG_USBCHAGE (MSG_USER + 7)
+#define MSG_FILTER (MSG_USER + 8)
+#define MSG_SDMOUNTFAIL (MSG_USER + 9)
+#define MSG_SDNOTFIT (MSG_USER + 10)
+#define MSG_ADAS (MSG_USER + 11)
+#define MSG_MD (MSG_USER + 12)
+#define MSG_PHOTOEND (MSG_USER + 13)
+#define MSG_REPAIR (MSG_USER + 14)
+#define MSG_FSINITFAIL (MSG_USER + 15)
+#define MSG_HDMI (MSG_USER + 16)
+#define MSG_USB_DISCONNECT (MSG_USER + 17)
+#define MSG_RK_USER (MSG_USER + 30)
+#define MSG_ATTACH_USER_MUXER (MSG_RK_USER + 0)
+#define MSG_DETACH_USER_MUXER (MSG_RK_USER + 1)
+#define MSG_ATTACH_USER_MDPROCESSOR (MSG_RK_USER + 2)
+#define MSG_DETACH_USER_MDPROCESSOR (MSG_RK_USER + 3)
+#define MSG_RECORD_RATE_CHANGE (MSG_RK_USER + 4)
+#define MSG_COLLISION (MSG_RK_USER + 5)
+#define MSG_NTP_SYNCED (MSG_RK_USER + 6)
+
+
+#define MSG_VIDEO 0x0A00
+#define MSG_VIDEO_COMMAND (MSG_VIDEO + 1)
+#define MSG_VIDEO_KEYDOWN (MSG_VIDEO + 2)
+#define MSG_VIDEO_KEYUP (MSG_VIDEO + 3)
+#define MSG_VIDEO_KEYLONGPRESS (MSG_VIDEO + 4)
+#define MSG_VIDEO_TIMER (MSG_VIDEO + 5)
+#define MSG_VIDEO_GET_PARAMS (MSG_VIDEO + 6)
+
+#define MSG_WIFI 0x0B00
+#define MSG_WIFI_COMMAND (MSG_WIFI + 1)
+
+
+#define WIFI_MODE_AP 0
+#define WIFI_MODE_STATION 1
+#define WIFI_MODE_MONITOR 2
+
+#define REQUEST_ID 0x0A00
+#define REQUEST_SET_STATION_MODE	(REQUEST_ID + 1)
+#define REQUEST_SET_AP_MODE		(REQUEST_ID + 2)
+#define REQUEST_SET_MONITOR_MODE	(REQUEST_ID + 3)
+#define REQUEST_SET_WIFI_STOP	(REQUEST_ID + 4)
+#define REQUEST_SET_ROUTE_AND_DNS	(REQUEST_ID + 5)
+
+#define RESPONSE_ID 0x0B00
+#define RESPONSE_NETWORK_SSID_AND_PASSWD	(RESPONSE_ID + 1)
+#define RESPONSE_NETWORK_STATE	(RESPONSE_ID + 2)
+#define RESPONSE_RESTART_SIMPLE_CONFIG	(RESPONSE_ID + 3)
+
+#define NETWORK_ID 0x0C00
+#define NETWORK_DISCONNECTED	(NETWORK_ID + 1)
+#define NETWORK_ETHERNET_DISCONNECTED	(NETWORK_ID + 2)
+#define NETWORK_ETHERNET_CONNECTED		(NETWORK_ID + 3)
+#define NETWORK_WIFI_DISCONNECTED	(NETWORK_ID + 4)
+#define NETWORK_WIFI_CONNECTED		(NETWORK_ID + 5)
+
+
+#define FWK_MSG_ONVIF_WSDL_URL 		("http://www.onvif.org/ver10/device/wsdl/devicemgmt.wsdl")
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_WSDL_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char wsdl_url[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_GET_WSDL_RSP;
+
+#define FWK_MSG_ONVIF_VERSION_MAJOR		(2)
+#define FWK_MSG_ONVIF_VERSION_MINOR		(20)
+
+typedef struct{
+	int major;
+	int minor;
+}FWK_MSG_ONVIF_VERSION;
+
+#define ONVIF_MAX_SERVICE_CAPABILITY_STRING							(1024)
+
+typedef struct{
+	char capabilityString[ONVIF_MAX_SERVICE_CAPABILITY_STRING+1];
+}FWK_MSG_CAPABILITY_STRING;
+
+#define FWK_MSG_ONVIF_DEVICE_NAMESPACE			("http://www.onvif.org/ver10/device/wsdl")
+#define FWK_MSG_ONVIF_MEDIA_NAMESPACE			("http://www.onvif.org/ver10/media/wsdl")
+#define FWK_MSG_ONVIF_PTZ_NAMESPACE				("http://www.onvif.org/ver20/ptz/wsdl")
+#define FWK_MSG_ONVIF_EVENT_NAMESPACE			("http://www.onvif.org/ver10/events/wsdl")
+#define FWK_MSG_ONVIF_IMAGE_NAMESPACE			("http://www.onvif.org/ver20/imaging/wsdl")
+#define FWKMSG_ONVIF_DEVICEIO_NAMESPACE			("http://www.onvif.org/ver10/deviceIO/wsdl")
+
+typedef struct{
+	char device_xaddr[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char media_xaddr[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char ptz_xaddr[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char events_xaddr[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char images_xaddr[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char deviceio_xaddr[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_ONVIF_SERVICES_ENTRY;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_SERVICES_ENTRY_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_ONVIF_SERVICES_ENTRY entry;
+}FWK_MSG_ONVIF_SERVICES_ENTRY_RSP;
+
+
+typedef enum{
+	FWK_MSG_IP_TYPES_V4,
+	FWK_MSG_IP_TYPES_V6
+}FWK_MSG_IP_TYPES;
+
+typedef struct{
+	FWK_MSG_IP_TYPES ip_type;
+	char ip_addr[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_IP_INFO;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IP_TYPES ip_type;
+}FWK_MSG_IP_INFO_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_IP_INFO info;
+}FWK_MSG_IP_INFO_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_DATATIME_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_DATA_T dt;
+}FWK_MSG_GET_DATATIME_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_SCOPE_REQ;
+
+typedef enum{
+	FWK_MSG_ONVIF_SCOPE_DEF_FIXED = 0,
+	FWK_MSG_ONVIF_SCOPE_DEF_CONFIGURABLE
+}FWK_MSG_ONVIF_SCOPE_DEF;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_SCOPE_DEF scope_def;
+	char ScopeItem[FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+}FWK_MSG_NVIF_SCOPE_ITEM;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeScopes;	
+	FWK_MSG_NVIF_SCOPE_ITEM scopes[FWK_MSG_ONVIF_MAX_SCOPE_NUM];
+	int result;
+}FWK_MSG_ONVIF_GET_SCOPE_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeScopes;	
+	char Scopes[FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM][FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+}FWK_MSG_ONVIF_SET_SCOPE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_MSG_ONVIF_SET_SCOPE_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeScopeItem;
+	char ScopeItem[FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM][FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+}FWK_MSG_ONVIF_ADD_SCOPE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_MSG_ONVIF_ADD_SCOPE_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeScopeItem;
+	char ScopeItem[FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM][FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+}FWK_MSG_ONVIF_REMOVE_SCOPE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeScopeItem;
+	char ScopeItem[FWK_MSG_ONVIF_MAX_CONFIG_SCOPE_NUM][FWK_MSG_ONVIF_MAX_SCOPE_STRING_LEN+1];
+	int result;
+}FWK_MSG_ONVIF_REMOVE_SCOPE_RSP;
+
+typedef enum{
+	FWK_MSG_ONVIF_DISCOVERY_MODE_DISCOVERABLE = 0,
+	FWK_MSG_ONVIF_DISCOVERY_MODE_NONDISCOVERABLE = 1
+}FWK_MSG_ONVIF_DISCOVERY_MODE;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_DISCOVERY_MODE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_ONVIF_DISCOVERY_MODE DiscoveryMode;
+	int result;
+}FWK_MSG_ONVIF_GET_DISCOVERY_MODE_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_ONVIF_DISCOVERY_MODE DiscoveryMode;
+}FWK_MSG_ONVIF_SET_DISCOVERY_MODE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_MSG_ONVIF_SET_DISCOVERY_MODE_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_ENDPOINT_REF_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char guid[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	int result;
+}FWK_MSG_GET_ENDPOINT_REF_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_HOSTNAME_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	unsigned char FromDHCP;
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int result;
+}FWK_MSG_GET_HOSTNAME_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_SET_HOSTNAME_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_MSG_SET_HOSTNAME_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_NETWORK_PROTOCOL_REQ;
+
+typedef enum{
+	FWK_MSG_ONVIF_PROTOCOL_TYPE_HTTP = 0,
+	FWK_MSG_ONVIF_PROTOCOL_TYPE_HTTPS = 1,
+	FWK_MSG_ONVIF_PROTOCOL_TYPE_RTSP = 2
+}FWK_MSG_ONVIF_PROTOCOL_TYPE;
+
+#define FWK_MSG_MAX_ONVIF_NET_PROTOCOLS							(3)
+#define FWK_MSG_MAX_ONVIF_PORTS_PER_PROTOCOL					(1)
+
+
+typedef struct{
+	FWK_MSG_ONVIF_PROTOCOL_TYPE Name;	
+	unsigned char Enabled;
+	int __sizePort;
+	int Port[FWK_MSG_MAX_ONVIF_PORTS_PER_PROTOCOL];
+}FWK_MSG_NETWORK_PROTOCOL;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeNetworkProtocols;
+	FWK_MSG_NETWORK_PROTOCOL NetworkProtocols[FWK_MSG_MAX_ONVIF_NET_PROTOCOLS];
+	int result;
+}FWK_MSG_GET_NETWORK_PROTOCOL_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_START_UPGRADE_IND_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char UploadUri[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+	char UploadDelay[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char ExpectedDownTime[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int delay;
+	int expected_down_time;
+	int result;
+}FWK_MSG_START_UPGRADE_IND_RSP;
+
+#define FWK_MSG_ONVIF_FIRMWARE_LOCATION			("/mnt/sdcard/onvif_update_firmware.img")
+#define FWK_MSG_ONVIF_FIRMWARE_CONTENT_TYPE		("application/octet-stream")
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int fileSize;
+	char content_type[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_START_UPGRADE_STATUS_CHECK_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char FileLocation[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+	int result;
+}FWK_MSG_START_UPGRADE_STATUS_CHECK_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char file_location[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_START_UPGRADE_ACTION_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_MSG_START_UPGRADE_ACTION_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char username[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_GET_USER_INFO_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char username[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char password[FWK_MSG_MAX_PASSWORD_LEN+1];
+	int result;
+}FWK_MSG_GET_USER_INFO_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_EVENT_PROPERTY_REQ;
+
+typedef struct{
+	int __size;
+	char __any[1][MAX_ONVIF_TOPICSET_ANY];
+}FWK_MSG_ONVIF_TOPIC_SET_TYPE;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeTopicNamespaceLocation;
+	char TopicNamespaceLocation[MAX_TOPIC_NAME_SPACE_LOCATION_NUM][FWK_MSG_ONVIF_MAX_NAME_STR+1];  
+	int Onvif__FixedTopicSet;	
+	FWK_MSG_ONVIF_TOPIC_SET_TYPE Onvif__TopicSet;	 
+	int __sizeTopicExpressionDialect;	
+	char Onvif__TopicExpressionDialect[2][FWK_MSG_ONVIF_MAX_NAME_STR+1];	
+	int __sizeMessageContentFilterDialect;	
+	char MessageContentFilterDialect[1][FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int __sizeMessageContentSchemaLocation;	
+	char MessageContentSchemaLocation[1][FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_GET_EVENT_PROPERTY_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_GET_USERS_REQ;
+
+typedef enum {
+	FWK_MSG_USER_LEVEL__Administrator = 0, 
+	FWK_MSG_USER_LEVEL__Operator = 1, 
+	FWK_MSG_USER_LEVEL__User = 2,
+	FWK_MSG_USER_LEVEL__Anonymous = 3, 
+	FWK_MSG_USER_LEVEL__Extended = 4
+}FWK_MSG_USER_LEVEL;
+
+typedef struct{
+	char Username[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char Password[FWK_MSG_MAX_PASSWORD_LEN+1];
+	FWK_MSG_USER_LEVEL UserLevel;
+}FWK_MSG_USER;
+
+#define FWK_MSG_MAX_USER_NUMBER		(1)
+#define MAX_ONVIF_USER_NUM			FWK_MSG_MAX_USER_NUMBER
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeUser;
+	FWK_MSG_USER User[MAX_ONVIF_USER_NUM];
+	int result;
+}FWK_MSG_GET_USERS_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeUser;
+	FWK_MSG_USER User[MAX_ONVIF_USER_NUM];
+}FWK_MSG_SET_USERS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int result;
+}FWK_MSG_SET_USERS_RSP;
+
+typedef enum
+{
+	FWK_MSG_ONVIF_PULLPOINT_TYPE_BASE = 0,
+	FWK_MSG_ONVIF_PULLPOINT_TYPE_REAL = 1,
+	FWK_MSG_ONVIF_PULLPOINT_TYPE_PULL = 2
+}FWK_MSG_ONVIF_PULLPOINT_TYPE;
+
+
+typedef enum 
+{
+	filter__boolean__topic_ = 0, 
+	filter__boolean__content_ = 1
+}filterType__boolean;
+
+typedef enum
+{
+	content__boolean__no_ = -1,
+	content__boolean__and_ = 0,
+	content__boolean__or_ = 1
+}contentMark__boolean;
+
+
+typedef struct{
+	char Address[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+}FWK_MSG_ONVIF_EP_REFERENCE_TYPE;
+
+#define MAX_ONEVENT_SUBSCRIBE				(30)
+#define MAX_ONEVENT_ANYSTR					(128)
+#define MAX_ONEVENT_MESSAGE_COUNT			(4)
+#define MAX_ONEVENT_FILTER_CHILD			(3)
+#define MAX_ONEVENT_FILTER_ANY				(384)
+#define MAX_ONEVENT_SUBSCRIPTION_POLICY		(3)
+#define MAX_ONEVENT_MESSAGE					(1024)
+
+
+typedef struct{
+	int __size;
+	char __any[MAX_ONEVENT_FILTER_CHILD][MAX_ONEVENT_FILTER_ANY+1];
+}FWK_MSG_ONVIF_FILTER_TYPE;
+
+typedef struct{
+	int __size;
+	char __any[MAX_ONEVENT_SUBSCRIPTION_POLICY][MAX_ONEVENT_ANYSTR+1];
+}FWK_MSG_ONVIF_SUBSCRIBE_SUBSCRIPTIONPOLICY;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_ONVIF_PULLPOINT_TYPE pullPointFlag;
+	FWK_MSG_ONVIF_EP_REFERENCE_TYPE ConsumerReference;	
+	FWK_MSG_ONVIF_FILTER_TYPE Filter;	
+	char InitialTerminationTime[MAX_ONEVENT_ANYSTR+1];
+	FWK_MSG_ONVIF_SUBSCRIBE_SUBSCRIPTIONPOLICY SubscriptionPolicy;
+}FWK_MSG_ONVIF_SUBSCRIBE_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_EP_REFERENCE_TYPE SubscriptionReference;
+	time_t CurrentTime;
+	time_t TerminationTime;
+}FWK_MSG_ONVIF_SUBSCRIBE_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char managerId[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char TerminationTime[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_RENEW_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	time_t Onvif__TerminationTime;
+	time_t Onvif__CurrentTime;
+}FWK_MSG_ONVIF_RENEW_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char managerId[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_ONVIF_UNSUBSCRIBE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_UNSUBSCRIBE_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char managerId[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_ONVIF_PAUSE_SUBSCRIPTION_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_PAUSE_SUBSCRIPTION_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char managerId[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_ONVIF_RESUME_SUBSCRIPTION_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_RESUME_SUBSCRIPTION_RSP;
+
+typedef struct{
+	char __any[MAX_ONEVENT_MESSAGE+1];
+}FWK_MSG_ONVIF_NOTIFICATION_MESSAGE_HOLDER_TYPE_MESSAGE;
+
+
+typedef struct{
+	char __any[MAX_ONEVENT_ANYSTR+1];
+	char Dialect[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+}FWK_MSG_ONVIF_TOPIC_EXPRESSION_TYPE;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_EP_REFERENCE_TYPE SubscriptionReference;
+	FWK_MSG_ONVIF_TOPIC_EXPRESSION_TYPE Topic;
+	FWK_MSG_ONVIF_EP_REFERENCE_TYPE ProducerReference;
+	FWK_MSG_ONVIF_NOTIFICATION_MESSAGE_HOLDER_TYPE_MESSAGE Message;
+}FWK_MSG_ONVIF_NOTIFICATION_MESSAGE_HOLDER_TYPE;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char managerId[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char Timeout[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int MessageLimit;	
+}FWK_MSG_ONVIF_PULL_MESSAGE_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	time_t CurrentTime;
+	time_t TerminationTime;	
+	int __sizeNotificationMessage;
+	FWK_MSG_ONVIF_NOTIFICATION_MESSAGE_HOLDER_TYPE ns3__NotificationMessage[MAX_ONEVENT_MESSAGE_COUNT];
+}FWK_MSG_ONVIF_PULL_MESSAGE_RSP;
+
+#define ONVIF_VIDEO_SOURCE_NAME									("VI0_name")
+#define ONVIF_VIDEO_SOURCE_TOKEN									("VI0_token")
+
+#define ONVIF_VIDEO_SOURCE_CONFIG_NAME							("Video_source_config")
+#define ONVIF_VIDEO_SOURCE_CONFIG_TOKEN							("Video_source_config_token")
+
+#define ONVIF_VIDEO_SOURCE_BOUND_WIDTH					(1920)
+#define ONVIF_VIDEO_SOURCE_BOUND_HEIGHT					(1080)
+
+
+
+#define ONVIF_VIDEO_ANALYSIS_CONFIG_NAME						("Video_analytics_config_name")
+#define ONVIF_VIDEO_ANALYSIS_CONFIG_TOKEN						("Video_analytics_config_token")
+
+#define ONVIF_VA_RULE_CELLMOTION_NAME				("IPCCellMotionDetector")
+#define ONVIF_VA_RULE_CELLMOTION_TYPE				("tt:CellMotionDetector")
+
+#define ONVIF_MOTIONDETECTOR_RULE		ONVIF_VA_RULE_CELLMOTION_NAME
+
+#define LOCAL_TIMEZONE					(8)	
+#define MAX_ONVIF_PTZ_NODE				(1)
+#define MAX_ONVIF_PTZ_SPACE					(1)
+
+#define MAX_ONVIF_PTZ_TOKEN_LEN				(64)
+#define MAX_ONVIF_PTZ_SPACE_LEN				(100)
+
+#define PTZ_NODE_TOKEN								("ptz_node_token_01")
+#define PTZ_NODE_NAME								("ptz_node_name_01")
+#define PTZ_CONFIGURATION_TOKEN						("ptz_configuration_token_01")
+#define PTZ_CONFIGURATION_NAME						("ptz_configuration_name_01")
+
+
+#define MAX_ONVIF_PTZ_CONFIG							(1)
+
+#define MAX_ONVIF_PROFILE_NUM							(1)
+#define MAX_ONVIF_RESERVE_PROFILE						(1)
+
+#define ONVIF_DEAULT_SESSION_TIMEOUT								("PT60S")
+#define DEFAULT_ONVIF_PTZ_TIMEOUT							("PT60S")
+#define MIN_ONVIF_PTZ_TIMEOUT								("PT1S")
+#define MAX_ONVIF_PTZ_TIMEOUT								("PT2M")
+
+
+#define ONVIF_STREAM_PROFILE_TOKEN					("rtsp_stream_profile_token")
+#define ONVIF_STREAM_PROFILE_NAME					("rtsp_stream_profile_name")
+
+#define ONVIF_VIDEO_ENCODER_CONFIG_RTSP_STREAM_NAME				("Video_encoder_config_rtsp_stream")
+#define ONVIF_VIDEO_ENCODER_CONFIG_RTSP_STREAM_TOKEN			("Video_encoder_config_rtsp_stream_token")
+
+#define MAX_ONVIF_VIDEO_SOURCE						(1)
+#define MAX_ONVIF_VIDEO_SOURCE_CONFIG				(1)
+#define MAX_ONVIF_VIDEO_ENCODER_CONFIG				(1)
+
+#define ONVIF_MIN_BIRATE_RTSP				(5)
+#define ONVIF_MAX_BIRATE_RTSP				(1000000)
+
+#define MAX_ONVIF_H264_STREAM_NUM			(1) //32
+#define MAX_ONVIF_JPEG_NUM					(0)
+
+#define MAX_ONVIF_NET_INTERFACE_NUM					(2)
+#define MAX_ONVIF_IP_PER_INTERFACE					(1)
+#define MAX_ONVIF_DNS_SEARCH_DOMAIN					(2)
+#define MAX_ONVIF_DNS_FROM_DHCP_IP					(2)
+#define MAX_ONVIF_DNS_MANNUAL_IP					(2)
+#define MAX_ONVIF_GATEWAY_IP						(1)
+
+
+
+
+
+typedef struct{
+	float Min;	
+	float Max;
+}FWK_ONVIF_FLOAT_RANGE;
+
+typedef struct{
+	int Min;
+	int Max;
+}FWK_ONVIF_INT_RANGE;
+
+
+typedef struct{
+	char URI[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+	FWK_ONVIF_FLOAT_RANGE XRange;
+}FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION;
+
+typedef struct{
+	char URI[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+	FWK_ONVIF_FLOAT_RANGE XRange;
+	FWK_ONVIF_FLOAT_RANGE YRange;
+}FWK_ONVIF_PTZ_SPACE_2D_DESCRIPTION;
+
+typedef struct{
+	int __sizeAbsolutePanTiltPositionSpace;
+	FWK_ONVIF_PTZ_SPACE_2D_DESCRIPTION AbsolutePanTiltPositionSpace[MAX_ONVIF_PTZ_SPACE];	
+	int __sizeAbsoluteZoomPositionSpace;	
+	FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION AbsoluteZoomPositionSpace[MAX_ONVIF_PTZ_SPACE];
+	int __sizeRelativePanTiltTranslationSpace;	
+	FWK_ONVIF_PTZ_SPACE_2D_DESCRIPTION RelativePanTiltTranslationSpace[MAX_ONVIF_PTZ_SPACE];
+	int __sizeRelativeZoomTranslationSpace;
+	FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION RelativeZoomTranslationSpace[MAX_ONVIF_PTZ_SPACE];
+	int __sizeContinuousPanTiltVelocitySpace;
+	FWK_ONVIF_PTZ_SPACE_2D_DESCRIPTION ContinuousPanTiltVelocitySpace[MAX_ONVIF_PTZ_SPACE];
+	int __sizeContinuousZoomVelocitySpace;
+	FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION ContinuousZoomVelocitySpace[MAX_ONVIF_PTZ_SPACE];
+	int __sizePanTiltSpeedSpace;	
+	FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION PanTiltSpeedSpace[MAX_ONVIF_PTZ_SPACE];
+	int __sizeZoomSpeedSpace;
+	FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION ZoomSpeedSpace[MAX_ONVIF_PTZ_SPACE];
+}FWK_MSG_ONVIF_PTZ_SPACES;
+
+
+typedef struct{
+	char token[MAX_ONVIF_PTZ_TOKEN_LEN+1];
+	char Name[MAX_ONVIF_PTZ_TOKEN_LEN+1];
+	FWK_MSG_ONVIF_PTZ_SPACES SupportedPTZSpaces;
+}FWK_MSG_ONVIF_PTZ_NODE;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_NODES_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizePTZNode;
+	FWK_MSG_ONVIF_PTZ_NODE PTZNode[MAX_ONVIF_PTZ_NODE];
+}FWK_MSG_ONVIF_GET_NODES_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char NodeToken[MAX_ONVIF_PTZ_TOKEN_LEN+1];
+}FWK_MSG_ONVIF_GET_NODE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_PTZ_NODE PTZNode;
+}FWK_MSG_ONVIF_GET_NODE_RSP;
+
+
+typedef struct{
+	float x;
+	float y;
+	char space[FWK_MSG_ONVIF_MAX_URI_STR+1];	
+}FWK_MSG_ONVIF_VECTOR2D;
+
+typedef struct{
+	float x;
+	char space[FWK_MSG_ONVIF_MAX_URI_STR+1];
+}FWK_MSG_ONVIF_VECTOR1D;
+
+typedef struct{
+	FWK_MSG_ONVIF_VECTOR2D PanTilt;	
+	FWK_MSG_ONVIF_VECTOR1D Zoom;
+}FWK_MSG_ONVIF_PTZ_SPEED;
+
+
+typedef struct{
+	FWK_ONVIF_PTZ_SPACE_2D_DESCRIPTION Range;	
+}FWK_MSG_ONVIF_PANTILT_LIMITS;
+
+typedef struct{
+	FWK_ONVIF_PTZ_SPACE_1D_DESCRIPTION Range;
+}FWK_MSG_ONVIF_ZOOM_LIMITS;
+
+
+typedef struct{
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int UseCount;
+	char token[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char NodeToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char DefaultAbsolutePantTiltPositionSpace[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char DefaultAbsoluteZoomPositionSpace[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char DefaultRelativePanTiltTranslationSpace[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char DefaultRelativeZoomTranslationSpace[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char DefaultContinuousPanTiltVelocitySpace[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	char DefaultContinuousZoomVelocitySpace[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	FWK_MSG_ONVIF_PTZ_SPEED DefaultPTZSpeed;
+	char DefaultPTZTimeout[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	FWK_MSG_ONVIF_PANTILT_LIMITS PanTiltLimits;	
+	FWK_MSG_ONVIF_ZOOM_LIMITS ZoomLimits;
+}FWK_MSG_ONVIF_PTZ_CONFIGURATION;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_PTZ_GET_CONFIGURATIONS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizePTZConfiguration;
+	FWK_MSG_ONVIF_PTZ_CONFIGURATION PTZConfiguration[MAX_ONVIF_PTZ_CONFIG];	
+}FWK_MSG_ONVIF_PTZ_GET_CONFIGURATIONS_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char PTZConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_CONFIGURATION_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_PTZ_CONFIGURATION PTZConfiguration;
+}FWK_MSG_ONVIF_GET_CONFIGURATION_RSP;
+
+
+typedef struct{
+	char Min[FWK_MSG_ONVIF_MAX_NAME_STR+1];	
+	char Max[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_DURATION_RANGE;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_CONFIGURATION_OPTIONS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_PTZ_SPACES Spaces;
+	FWK_MSG_ONVIF_DURATION_RANGE PTZTimeout;
+}FWK_MSG_ONVIF_GET_CONFIGURATION_OPTIONS_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	FWK_MSG_ONVIF_PTZ_SPEED Velocity;
+	char Timeout[FWK_MSG_ONVIF_MAX_NAME_STR+1];	
+}FWK_MSG_ONVIF_CONTINUOUS_MOVE_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_CONTINUOUS_MOVE_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int PanTilt;
+	int Zoom;
+}FWK_MSG_ONVIF_STOP_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_STOP_RSP;
+
+
+typedef enum{
+	FWK_MSG_ONVIF_MOVE_STATUS__IDLE = 0,
+	FWK_MSG_ONVIF_MOVE_STATUS__MOVING = 1,
+	FWK_MSG_ONVIF_MOVE_STATUS__UNKNOWN = 2
+}FWK_MSG_ONVIF_MOVE_STATUS;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_MOVE_STATUS PanTilt;
+	FWK_MSG_ONVIF_MOVE_STATUS Zoom;
+}FWK_MSG_ONVIF_PTZ_MOVE_STATUS;
+
+typedef struct{
+	FWK_MSG_ONVIF_VECTOR2D PanTilt;	
+	FWK_MSG_ONVIF_VECTOR1D Zoom;
+}FWK_MSG_ONVIF_PTZ_VECTOR;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_PTZ_VECTOR Position;
+	FWK_MSG_ONVIF_PTZ_MOVE_STATUS MoveStatus;
+	char Error[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	time_t UtcTime;
+}FWK_MSG_ONVIF_PTZ_STATUS;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_STATUS_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_PTZ_STATUS PTZStatus;	
+}FWK_MSG_ONVIF_GET_STATUS_RSP;
+
+
+
+typedef struct{
+	int x;	
+	int y;
+	int width;
+	int height;
+}FWK_MSG_ONVIF_INT_RECTANGLE;
+
+typedef struct{
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int UseCount;
+	char token[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char SourceToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	FWK_MSG_ONVIF_INT_RECTANGLE Bounds;
+}FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION;
+
+typedef enum{
+	FWK_MSG_ONVIF_VIDEO_ENCODING__JPEG = 0,
+	FWK_MSG_ONVIF_VIDEO_ENCODING__MPEG4 = 1,
+	FWK_MSG_ONVIF_VIDEO_ENCODING__H264 = 2
+}FWK_MSG_ONVIF_VIDEO_ENCODING;
+
+typedef struct{
+	int Width;
+	int Height;
+}FWK_MSG_ONVIF_VIDEO_RESOLUTION;
+
+typedef struct{
+	int FrameRateLimit;
+	int EncodingInterval; 
+	int BitrateLimit;
+}FWK_MSG_ONVIF_VIDEO_RATE_CONTROL;
+
+typedef enum{
+	FWK_MSG_ONVIF_H264_PROFILE__Baseline = 0,
+	FWK_MSG_ONVIF_H264_PROFILE__Main = 1,
+	FWK_MSG_ONVIF_H264_PROFILE__Extended = 2,
+	FWK_MSG_ONVIF_H264_PROFILE__High = 3
+}FWK_MSG_ONVIF_H264_PROFILE;
+
+typedef struct{
+	int GovLength;
+	FWK_MSG_ONVIF_H264_PROFILE H264Profile;
+}FWK_MSG_ONVIF_H264_CONFIGURATION;
+
+
+typedef struct{
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int UseCount;
+	char token[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	FWK_MSG_ONVIF_VIDEO_ENCODING Encoding;
+	FWK_MSG_ONVIF_VIDEO_RESOLUTION Res;
+	float Quality;
+	FWK_MSG_ONVIF_VIDEO_RATE_CONTROL RateControl;
+	FWK_MSG_ONVIF_H264_CONFIGURATION H264;
+	char SessionTimeout[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION;
+
+
+typedef struct{
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION VideoSourceConfiguration;
+	FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION VideoEncoderConfiguration;
+	FWK_MSG_ONVIF_PTZ_CONFIGURATION PTZConfiguration;
+	char token[FWK_MSG_ONVIF_MAX_NAME_STR+1];	
+	int fixed;
+}FWK_MSG_ONVIF_PROFILE;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_PROFILES_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeProfiles;
+	FWK_MSG_ONVIF_PROFILE Profiles[MAX_ONVIF_PROFILE_NUM];
+}FWK_MSG_ONVIF_GET_PROFILES_RSP;
+
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_PROFILE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_PROFILE Profiles[1];
+}FWK_MSG_ONVIF_GET_PROFILE_RSP;
+
+
+typedef enum{
+	FWK_MSG_ONVIF_STREAM_TYPE_RTP_Unicast = 0,
+	FWK_MSG_ONVIF_STREAM_TYPE__RTP_Multicast = 1
+}FWK_MSG_ONVIF_STREAM_TYPE;
+
+typedef enum{
+	FWK_MSG_ONVIF_TRANSPORT_PROTOCOL__UDP = 0,
+	FWK_MSG_ONVIF_TRANSPORT_PROTOCOL__TCP = 1,
+	FWK_MSG_ONVIF_TRANSPORT_PROTOCOL__RTSP = 2,
+	FWK_MSG_ONVIF_TRANSPORT_PROTOCOL__HTTP = 3
+}FWK_MSG_ONVIF_TRANSPORT_PROTOCOL;
+
+typedef struct{
+	FWK_MSG_ONVIF_TRANSPORT_PROTOCOL Protocol;
+}FWK_MSG_ONVIF_TRANSPORT;
+
+typedef struct{
+	FWK_MSG_ONVIF_STREAM_TYPE Stream;
+	FWK_MSG_ONVIF_TRANSPORT Transport;
+}FWK_MSG_ONVIF_STREAM_SETUP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	FWK_MSG_ONVIF_STREAM_SETUP StreamSetup;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_STREAM_URI_REQ;
+
+typedef struct{
+	char Uri[FWK_MSG_ONVIF_MAX_URI_STR+1];
+	unsigned char InvalidAfterConnect;	
+	unsigned char InvalidAfterReboot;
+	char Timeout[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_MEDIA_URI;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_MEDIA_URI MediaUri;
+}FWK_MSG_ONVIF_GET_STREAM_URI_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_SET_SYNCHRONIZATION_POINT_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_SET_SYNCHRONIZATION_POINT_RSP;
+
+
+typedef struct{
+	char token[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	float Framerate;
+	FWK_MSG_ONVIF_VIDEO_RESOLUTION Res;
+}FWK_MSG_ONVIF_VIDEO_SOURCE;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCES_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeVideoSources;
+	FWK_MSG_ONVIF_VIDEO_SOURCE VideoSources[MAX_ONVIF_VIDEO_SOURCE];	
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCES_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCE_CONFIGURATION_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION Configuration;
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCE_CONFIGURATION_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCE_CONFIGURATIONS_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeConfigurations;	
+	FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION Configurations[MAX_ONVIF_VIDEO_SOURCE_CONFIG];
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCE_CONFIGURATIONS_RSP;
+
+
+typedef struct{
+	int Min;
+	int Max;
+}FWK_MSG_ONVIF_INT_RANGE;
+
+typedef struct {
+	FWK_MSG_ONVIF_INT_RANGE XRange;	
+	FWK_MSG_ONVIF_INT_RANGE YRange;	
+	FWK_MSG_ONVIF_INT_RANGE WidthRange;
+	FWK_MSG_ONVIF_INT_RANGE HeightRange;
+}FWK_MSG_ONVIF_INT_RECTANGLE_RANGE;
+
+typedef struct{
+	FWK_MSG_ONVIF_INT_RECTANGLE_RANGE BoundsRange;
+	int __sizeVideoSourceTokensAvailable;
+	char VideoSourceTokensAvailable[MAX_ONVIF_VIDEO_SOURCE_CONFIG][FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION_OPTIONS;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCE_CONFIGURATION_OPTIONS_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION_OPTIONS Options;
+}FWK_MSG_ONVIF_GET_VIDEO_SOURCE_CONFIGURATION_OPTIONS_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_VIDEO_ENCODER_CONFIGURATIONS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeConfigurations;	
+	FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION Configurations[MAX_ONVIF_VIDEO_ENCODER_CONFIG];
+}FWK_MSG_ONVIF_GET_VIDEO_ENCODER_CONFIGURATIONS_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_VIDEO_CONFIG_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION Configuration;	
+}FWK_MSG_ONVIF_GET_VIDEO_CONFIG_RSP;
+
+#define MAX_ONVIF_H264_ALL_RES						(5)
+#define MAX_ONVIF_H264_PROFILE						(5)
+
+typedef struct{
+	int __sizeResolutionsAvailable;
+	FWK_MSG_ONVIF_VIDEO_RESOLUTION ResolutionsAvailable[MAX_ONVIF_H264_ALL_RES];
+	FWK_MSG_ONVIF_INT_RANGE GovLengthRange;
+	FWK_MSG_ONVIF_INT_RANGE FrameRateRange;
+	FWK_MSG_ONVIF_INT_RANGE EncodingIntervalRange;
+	int __sizeH264ProfilesSupported;
+	FWK_MSG_ONVIF_H264_PROFILE H264ProfilesSupported[MAX_ONVIF_H264_PROFILE];
+}FWK_MSG_ONVIF_H264_OPTIONS;
+
+
+typedef struct{
+	int __sizeResolutionsAvailable;	
+	FWK_MSG_ONVIF_VIDEO_RESOLUTION ResolutionsAvailable[MAX_ONVIF_H264_ALL_RES];
+	FWK_MSG_ONVIF_INT_RANGE GovLengthRange;	
+	FWK_MSG_ONVIF_INT_RANGE FrameRateRange;	
+	FWK_MSG_ONVIF_INT_RANGE EncodingIntervalRange;	
+	int __sizeH264ProfilesSupported;	
+	FWK_MSG_ONVIF_H264_PROFILE H264ProfilesSupported[MAX_ONVIF_H264_PROFILE];	
+	FWK_MSG_ONVIF_INT_RANGE BitrateRange;
+}FWK_MSG_ONVIF_H264_OPTIONS2;
+
+typedef struct{
+	FWK_MSG_ONVIF_H264_OPTIONS2 H264;
+}FWK_MSG_ONVIF_VIDEO_ENCODER_OPTIONS_EXTENSION;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_INT_RANGE QualityRange;
+	FWK_MSG_ONVIF_H264_OPTIONS H264;
+	FWK_MSG_ONVIF_VIDEO_ENCODER_OPTIONS_EXTENSION Extension;	
+}FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION_OPTIONS;
+
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_VIDEO_CONFIG_OPT_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION_OPTIONS Options;	
+}FWK_MSG_ONVIF_GET_VIDEO_CONFIG_OPT_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ConfigurationToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_GUARANTEED_NUMBER_OF_VIDEO_ENCODER_INSTANCE_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int TotalNumber;	
+	int JPEG;
+	int H264;
+	int MPEG4;
+}FWK_MSG_ONVIF_GET_GUARANTEED_NUMBER_OF_VIDEO_ENCODER_INSTANCE_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int is_rc_valid;
+	int is_h264_valid;
+	FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION Configuration;
+	unsigned char ForcePersistence;
+}FWK_MSG_ONVIF_SET_VIDEO_ENCODER_CONFIGURATION_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_SET_VIDEO_ENCODER_CONFIGURATION_RSP;
+
+
+typedef enum{
+	FWK_MSG_ONVIF_IRCUT_FILTER_MODE__ON = 0,
+	FWK_MSG_ONVIF_IRCUT_FILTER_MODE_OFF = 1,
+	FWK_MSG_ONVIF_IRCUT_FILTER_MODE__AUTO = 2
+}FWK_MSG_ONVIF_IRCUT_FILTER_MODE;
+
+typedef enum{
+	FWK_MSG_ONVIF_WIDE_DYNAMIC_MODE_OFF = 0,
+	FWK_MSG_ONVIF_WIDE_DYNAMIC_MODE_ON = 1
+}FWK_MSG_ONVIF_WIDE_DYNAMIC_MODE;
+
+typedef enum{
+	FWK_MSG_ONVIF_WHITE_BALANCE_MODE__AUTO = 0,
+	FWK_MSG_ONVIF_WHITE_BALANCE_MODE__MANUAL = 1
+}FWK_MSG_ONVIF_WHITE_BALANCE_MODE;
+
+typedef enum{
+	FWK_MSG_ONVIF_BACKLIGHT_COMPENSATION_MODE_OFF = 0,
+	FWK_MSG_ONVIF_BACKLIGHT_COMPENSATION_MODE_ON = 1
+}FWK_MSG_ONVIF_BACKLIGHT_COMPENSATION_MODE;
+
+typedef enum{
+	FWK_MSG_ONVIF_EXPOSURE_MODE_AUTO = 0,
+	FWK_MSG_ONVIF_EXPOSURE_MODE_MANUAL = 1
+}FWK_MSG_ONVIF_EXPOSURE_MODE;
+
+typedef enum{
+	FWK_MSG_ONVIF_EXPOSURE_PRIORITY_LowNoise = 0,
+	FWK_MSG_ONVIF_EXPOSURE_PRIORITY_FrameRate = 1
+}FWK_MSG_ONVIF_EXPOSURE_PRIORITY;
+
+typedef struct{
+	float bottom;
+	float top;
+	float right;
+	float left;
+}FWK_MSG_ONVIF_RECTANGLE;
+
+typedef enum{
+	FWK_MSG_ONVIF_AUTO_FOCUS_MODE_AUTO = 0,
+	FWK_MSG_ONVIF_AUTO_FOCUS_MODE_MANUAL = 1
+}FWK_MSG_ONVIF_AUTO_FOCUS_MODE;
+
+
+
+typedef struct{
+	FWK_MSG_ONVIF_BACKLIGHT_COMPENSATION_MODE Mode;
+	float Level;
+}FWK_MSG_ONVIF_BACKLIGHT_COMPENSATION20;
+
+typedef struct{
+	FWK_MSG_ONVIF_EXPOSURE_MODE Mode;
+	FWK_MSG_ONVIF_EXPOSURE_PRIORITY Priority;
+	FWK_MSG_ONVIF_RECTANGLE Window;
+	unsigned char is_used_exporusetime;
+	unsigned char is_used_gain;
+	unsigned char is_used_iris;
+	float MinExposureTime;
+	float MaxExposureTime;	
+	float MinGain;
+	float MaxGain;
+	float MinIris;	
+	float MaxIris;	
+	float ExposureTime;	
+	float Gain;
+	float Iris;	
+}FWK_MSG_ONVIF_EXPOSURE20;
+
+typedef struct{
+	FWK_MSG_ONVIF_AUTO_FOCUS_MODE AutoFocusMode;
+	unsigned char is_used_speed;
+	unsigned char is_used_nearlimit;
+	unsigned char is_used_FarLimit;
+	float DefaultSpeed;
+	float NearLimit;
+	float FarLimit;
+}FWK_MSG_ONVIF_FOCUS_CONFIGURATION20;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_WIDE_DYNAMIC_MODE Mode;
+	float Level;
+	unsigned char is_used_level;
+}FWK_MSG_ONVIF_WIDE_DYNAMIC_RANGE20;
+
+
+typedef struct{
+	FWK_MSG_ONVIF_WHITE_BALANCE_MODE Mode;
+	float CrGain;	
+	float CbGain;
+}FWK_MSG_ONVIF_WHITE_BALANCE20;
+
+
+typedef struct{
+	//unsigned char is_used_backlight;
+	//FWK_MSG_ONVIF_BACKLIGHT_COMPENSATION20 BacklightCompensation;
+	float Brightness;	
+	float ColorSaturation;
+	float Contrast;
+	//unsigned char is_used_exposure;
+	//FWK_MSG_ONVIF_EXPOSURE20 Exposure;	
+	//unsigned char is_used_focus;
+	//FWK_MSG_ONVIF_FOCUS_CONFIGURATION20 Focus;
+	//unsigned char is_used_IRCut;
+	//FWK_MSG_ONVIF_IRCUT_FILTER_MODE IrCutFilter;	
+	float Sharpness;
+	//unsigned char is_used_wdr;
+	//FWK_MSG_ONVIF_WIDE_DYNAMIC_RANGE20 WideDynamicRange;
+	//unsigned char is_used_whitebalance;
+	//FWK_MSG_ONVIF_WHITE_BALANCE20 WhiteBalance;
+}FWK_MSG_ONVIF_IMAGING_SETTINGS20;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char VideoSourceToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_IMAGING_SETTINGS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_IMAGING_SETTINGS20 ImagingSettings;	
+}FWK_MSG_ONVIF_GET_IMAGING_SETTINGS_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char VideoSourceToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	int is_brightness_valid;
+	int is_contrast_valid;
+	int is_saturation_valid;
+	int is_sharpness_valid;
+	FWK_MSG_ONVIF_IMAGING_SETTINGS20 ImagingSettings;
+	unsigned char ForcePersistence_x0020;
+}FWK_MSG_ONVIF_SET_IMAGING_SETTINGS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_SET_IMAGING_SETTINGS_RSP;
+
+
+
+typedef struct{
+	float Min;	
+	float Max;
+}FWK_MSG_ONVIF_FLOAT_RANGE;
+
+typedef struct{ 
+	FWK_MSG_ONVIF_FLOAT_RANGE Brightness;
+	FWK_MSG_ONVIF_FLOAT_RANGE ColorSaturation;
+	FWK_MSG_ONVIF_FLOAT_RANGE Contrast;
+	FWK_MSG_ONVIF_FLOAT_RANGE Sharpness;	
+}FWK_MSG_ONVIF_IMAGING_OPTIONS20;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char VideoSourceToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_IMAGE_GET_OPTIONS_REQ;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_IMAGING_OPTIONS20 ImagingOptions;
+}FWK_MSG_ONVIF_IMAGE_GET_OPTIONS_RSP;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_COMPATIBLE_VIDEO_SOURCE_CONFIGS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeConfigurations;	
+	FWK_MSG_ONVIF_VIDEO_SOURCE_CONFIGURATION Configurations[MAX_ONVIF_VIDEO_SOURCE_CONFIG];
+}FWK_MSG_ONVIF_GET_COMPATIBLE_VIDEO_SOURCE_CONFIGS_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_COMPATIBLE_VIDEO_ENCODER_CONFIGS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeConfigurations;	
+	FWK_MSG_ONVIF_VIDEO_ENCODER_CONFIGURATION Configurations[MAX_ONVIF_VIDEO_ENCODER_CONFIG];
+}FWK_MSG_ONVIF_GET_COMPATIBLE_VIDEO_ENCODER_CONFIGS_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char ProfileToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+}FWK_MSG_ONVIF_GET_COMPATIBLE_PTZ_CONFIGS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizePTZConfiguration;
+	FWK_MSG_ONVIF_PTZ_CONFIGURATION PTZConfiguration[MAX_ONVIF_PTZ_CONFIG];	
+}FWK_MSG_ONVIF_GET_COMPATIBLE_PTZ_CONFIGS_RSP;
+
+typedef struct{
+	char Name[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	char HwAddress[ONVIF_DISCOVERY_MAC_LEN+1];
+	int MTU;
+}FWK_MSG_ONVIF_NETWORK_INTERFACE_INFO;
+
+typedef struct{
+	char Address[ONVIF_DISCOVERY_IP_LEN+1];	
+	int PrefixLength;
+}FWK_MSG_ONVIF_PREFIXED_IPV4ADDRESS;
+
+typedef struct{
+	int __sizeManual;	
+	FWK_MSG_ONVIF_PREFIXED_IPV4ADDRESS Manual[MAX_ONVIF_IP_PER_INTERFACE];
+	FWK_MSG_ONVIF_PREFIXED_IPV4ADDRESS LinkLocal;
+	FWK_MSG_ONVIF_PREFIXED_IPV4ADDRESS FromDHCP;
+	unsigned char DHCP;
+}FWK_MSG_ONVIF_IPV4_CONFIGURATION;
+
+typedef struct{
+	unsigned char Enabled;
+	FWK_MSG_ONVIF_IPV4_CONFIGURATION Config;
+}FWK_MSG_ONVIF_IPV4_NETWORK_INTERFACE;
+
+
+typedef struct{
+	char token[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	unsigned char Enabled;
+	FWK_MSG_ONVIF_NETWORK_INTERFACE_INFO Info;
+	FWK_MSG_ONVIF_IPV4_NETWORK_INTERFACE IPv4;	
+}FWK_MSG_ONVIF_NTWORK_INTERFACE;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_NETWORKINTERFACES_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	int __sizeNetworkInterfaces;
+	FWK_MSG_ONVIF_NTWORK_INTERFACE NetworkInterfaces[MAX_ONVIF_NET_INTERFACE_NUM];	
+}FWK_MSG_ONVIF_GET_NETWORKINTERFACES_RSP;
+
+
+typedef struct{
+	unsigned char Enabled;
+	int __sizeManual;	
+	FWK_MSG_ONVIF_PREFIXED_IPV4ADDRESS Manual[MAX_ONVIF_IP_PER_INTERFACE];	
+	unsigned char DHCP;
+}FWK_MSG_ONVIF_IPV4_NETWORK_INTERFACE_SET_CONFIGURATION;
+
+typedef struct{
+	unsigned char Enabled;
+	int MTU;	
+	FWK_MSG_ONVIF_IPV4_NETWORK_INTERFACE_SET_CONFIGURATION IPv4;
+}FWK_MSG_ONVIF_NETWORK_INTERFACE_SET_CONFIGURATION;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	char InterfaceToken[FWK_MSG_ONVIF_MAX_NAME_STR+1];
+	FWK_MSG_ONVIF_NETWORK_INTERFACE_SET_CONFIGURATION NetworkInterface;
+}FWK_MSG_ONVIF_SET_NETWORK_INTERFACES_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	unsigned char RebootNeeded;	
+}FWK_MSG_ONVIF_SET_NETWORK_INTERFACES_RSP;
+
+typedef struct{
+	FWK_MSG_IP_TYPES Type;	
+	char IPv4Address[ONVIF_DISCOVERY_IP_LEN+1];
+	char IPv6Address[ONVIF_DISCOVERY_IP_LEN+1];
+}FWK_MSG_ONVIF_IP_ADDRESS;
+
+
+typedef struct{
+	unsigned char FromDHCP;
+	int __sizeDNSFromDHCP;
+	FWK_MSG_ONVIF_IP_ADDRESS DNSFromDHCP[MAX_ONVIF_DNS_FROM_DHCP_IP];
+	int __sizeDNSManual;	
+	FWK_MSG_ONVIF_IP_ADDRESS DNSManual[MAX_ONVIF_DNS_MANNUAL_IP];	
+}FWK_MSG_ONVIF_DNS_INFORMATION;
+
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_DNS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_DNS_INFORMATION DNSInformation;
+}FWK_MSG_ONVIF_GET_DNS_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	unsigned char FromDHCP;
+	int __sizeDNSManual;	
+	FWK_MSG_ONVIF_IP_ADDRESS DNSManual[MAX_ONVIF_DNS_MANNUAL_IP];
+}FWK_MSG_ONVIF_SET_DNS_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_SET_DNS_RSP;
+
+
+typedef struct{
+	int __sizeIPv4Address;
+	char IPv4Address[MAX_ONVIF_GATEWAY_IP][ONVIF_DISCOVERY_IP_LEN+1];
+}FWK_MSG_ONVIF_NETWORK_GATEWAY;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+}FWK_MSG_ONVIF_GET_NETWORK_DEFAULT_GATEWAY_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+	FWK_MSG_ONVIF_NETWORK_GATEWAY NetworkGateway;
+}FWK_MSG_ONVIF_GET_NETWORK_DEFAULT_GATEWAY_RSP;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int __sizeIPv4Address;
+	char IPv4Address[MAX_ONVIF_GATEWAY_IP][ONVIF_DISCOVERY_IP_LEN+1];
+}FWK_MSG_ONVIF_SET_NETWORK_DEFAULT_GATEWAY_REQ;
+
+typedef struct{
+	FWK_MSG_PROTOCOL_TYPE ps_type;
+	int ret;
+}FWK_MSG_ONVIF_SET_NETWORK_DEFAULT_GATEWAY_RSP;
+
+
+
+#endif /* _FWK_GL_DEF_837689389163_*/
diff --git a/noui/libvui/fwk_gl_msg.h b/noui/libvui/fwk_gl_msg.h
new file mode 100644
index 0000000..19d7003
--- /dev/null
+++ b/noui/libvui/fwk_gl_msg.h
@@ -0,0 +1,503 @@
+/*   ----------------------------------------------------------------------
+Copyright (C) 2014-2016 Fuzhou Rockchip Electronics Co., Ltd
+
+     Sec Class: Rockchip Confidential
+
+V1.0 Dayao Ji <jdy@rock-chips.com>
+---------------------------------------------------------------------- */
+
+
+#ifndef _FWK_GL_MSG_9383837383_
+#define _FWK_GL_MSG_9383837383_
+
+#include "fwk_gl_def.h"
+
+
+#define MSG_ID_FWK_FRAMEWORK_START_BASE								(FWK_MOD_FWK<<16)
+
+
+/*control message*/
+#define MSG_ID_FWK_CONTROL_START_BASE								(FWK_MOD_CONTROL<<16)
+#define MSG_ID_FWK_CONTROL_DEMO_REQ									(MSG_ID_FWK_CONTROL_START_BASE+1)
+#define MSG_ID_FWK_CONTROL_DEMO_RSP									(MSG_ID_FWK_CONTROL_START_BASE+2)
+#define MSG_ID_FWK_CONTROL_COMMU_SWITCH_REQ							(MSG_ID_FWK_CONTROL_START_BASE+3)
+#define MSG_ID_FWK_CONTROL_COMMU_SWITCH_RSP							(MSG_ID_FWK_CONTROL_START_BASE+4)
+#define MSG_ID_FWK_CONTROL_WRTC_CALL_REQ							(MSG_ID_FWK_CONTROL_START_BASE+5)
+#define MSG_ID_FWK_CONTROL_WRTC_CALL_RSP							(MSG_ID_FWK_CONTROL_START_BASE+6)
+#define MSG_ID_FWK_CONTROL_TAKE_PICTURE_REQ							(MSG_ID_FWK_CONTROL_START_BASE+7)
+#define MSG_ID_FWK_CONTROL_TAKE_PICTURE_RSP							(MSG_ID_FWK_CONTROL_START_BASE+8)
+#define MSG_ID_FWK_CONTROL_SET_VALUE_REQ							(MSG_ID_FWK_CONTROL_START_BASE+9)
+#define MSG_ID_FWK_CONTROL_SET_VALUE_RSP							(MSG_ID_FWK_CONTROL_START_BASE+10)
+#define MSG_ID_FWK_CONTROL_GET_PARAS_REQ							(MSG_ID_FWK_CONTROL_START_BASE+11)
+#define MSG_ID_FWK_CONTROL_GET_PARAS_RSP							(MSG_ID_FWK_CONTROL_START_BASE+12)
+#define MSG_ID_FWK_CONTROL_SET_DATE_TIME_REQ						(MSG_ID_FWK_CONTROL_START_BASE+13)
+#define MSG_ID_FWK_CONTROL_SET_DATE_TIME_RSP						(MSG_ID_FWK_CONTROL_START_BASE+14)
+#define MSG_ID_FWK_CONTROL_SET_WIFIPASSWD_REQ						(MSG_ID_FWK_CONTROL_START_BASE+15)
+#define MSG_ID_FWK_CONTROL_SET_WIFIPASSWD_RSP						(MSG_ID_FWK_CONTROL_START_BASE+16)
+#define MSG_ID_FWK_CONTROL_GET_FILES_REQ							(MSG_ID_FWK_CONTROL_START_BASE+17)
+#define MSG_ID_FWK_CONTROL_GET_FILES_RSP							(MSG_ID_FWK_CONTROL_START_BASE+18)
+#define MSG_ID_FWK_CONTROL_GET_FILE_INFO_REQ						(MSG_ID_FWK_CONTROL_START_BASE+19)
+#define MSG_ID_FWK_CONTROL_GET_FILE_INFO_RSP						(MSG_ID_FWK_CONTROL_START_BASE+20)
+#define MSG_ID_FWK_CONTROL_GET_GPS_INFO_REQ							(MSG_ID_FWK_CONTROL_START_BASE+21)
+#define MSG_ID_FWK_CONTROL_GET_GPS_INFO_RSP							(MSG_ID_FWK_CONTROL_START_BASE+22)
+#define MSG_ID_FWK_CONTROL_GET_FILE_LIST_D_REQ						(MSG_ID_FWK_CONTROL_START_BASE+23)
+#define MSG_ID_FWK_CONTROL_GET_FILE_LIST_D_RSP						(MSG_ID_FWK_CONTROL_START_BASE+24)
+#define MSG_ID_FWK_CONTROL_DEL_FILE_REQ								(MSG_ID_FWK_CONTROL_START_BASE+25)
+#define MSG_ID_FWK_CONTROL_DEL_FILE_RSP								(MSG_ID_FWK_CONTROL_START_BASE+26)
+#define MSG_ID_FWK_CONTROL_DEVICE_INFO_REQ							(MSG_ID_FWK_CONTROL_START_BASE+27)
+#define MSG_ID_FWK_CONTROL_DEVICE_INFO_RSP							(MSG_ID_FWK_CONTROL_START_BASE+28)
+#define MSG_ID_FWK_CONTROL_AP_INFO_REQ								(MSG_ID_FWK_CONTROL_START_BASE+29)
+#define MSG_ID_FWK_CONTROL_AP_INFO_RSP								(MSG_ID_FWK_CONTROL_START_BASE+30)
+#define MSG_ID_FWK_CONTROL_CAM_NUMBER_INFO_REQ						(MSG_ID_FWK_CONTROL_START_BASE+31)
+#define MSG_ID_FWK_CONTROL_CAM_NUMBER_INFO_RSP						(MSG_ID_FWK_CONTROL_START_BASE+32)
+#define MSG_ID_FWK_CONTROL_RTSP_URL_REQ								(MSG_ID_FWK_CONTROL_START_BASE+33)
+#define MSG_ID_FWK_CONTROL_RTSP_URL_RSP								(MSG_ID_FWK_CONTROL_START_BASE+34)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_VIDEO_REQ						(MSG_ID_FWK_CONTROL_START_BASE+35)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_VIDEO_RSP						(MSG_ID_FWK_CONTROL_START_BASE+36)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_IMAGE_REQ						(MSG_ID_FWK_CONTROL_START_BASE+37)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_IMAGE_RSP						(MSG_ID_FWK_CONTROL_START_BASE+38)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_STATUS_IND						(MSG_ID_FWK_CONTROL_START_BASE+39)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_UPLOAD_REQ						(MSG_ID_FWK_CONTROL_START_BASE+40) 
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_UPLOAD_RSP						(MSG_ID_FWK_CONTROL_START_BASE+41) 
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_GET_STORAGE_TOKEN_REQ			(MSG_ID_FWK_CONTROL_START_BASE+42)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_GET_STORAGE_TOKEN_RSP			(MSG_ID_FWK_CONTROL_START_BASE+43)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_UPLOAD_DONE_IND				(MSG_ID_FWK_CONTROL_START_BASE+44)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_NOTIFY_IND						(MSG_ID_FWK_CONTROL_START_BASE+45)
+#define MSG_ID_FWK_CONTROL_3G_REMOTE_ALARM_IND						(MSG_ID_FWK_CONTROL_START_BASE+46)
+#define MSG_ID_FWK_CONTROL_DEVICE_CATALOG_REQ                       (MSG_ID_FWK_CONTROL_START_BASE+47)
+#define MSG_ID_FWK_CONTROL_DEVICE_CATALOG_RSP                       (MSG_ID_FWK_CONTROL_START_BASE+48)
+#define MSG_ID_FWK_CONTROL_DEVICE_STATUS_REQ                        (MSG_ID_FWK_CONTROL_START_BASE+49)
+#define MSG_ID_FWK_CONTROL_DEVICE_STATUS_RSP                        (MSG_ID_FWK_CONTROL_START_BASE+50)
+#define MSG_ID_FWK_CONTROL_NOTIFY_ALARM_REQ                         (MSG_ID_FWK_CONTROL_START_BASE+51)
+#define MSG_ID_FWK_CONTROL_NOTIFY_ALARM_RSP                         (MSG_ID_FWK_CONTROL_START_BASE+52)
+#define MSG_ID_FWK_CONTROL_RK_JSON_MESSAGE_REQ		                (MSG_ID_FWK_CONTROL_START_BASE+53)
+#define MSG_ID_FWK_CONTROL_RK_JSON_MESSAGE_RSP		                (MSG_ID_FWK_CONTROL_START_BASE+54)
+#define MSG_ID_FWK_CONTROL_DEVICE_PTZ_CMD_REQ                       (MSG_ID_FWK_CONTROL_START_BASE+55)
+#define MSG_ID_FWK_CONTROL_DEVICE_PTZ_CMD_RSP                       (MSG_ID_FWK_CONTROL_START_BASE+56)
+#define MSG_ID_FWK_CONTROL_DEVICE_RECORD_CMD_REQ                    (MSG_ID_FWK_CONTROL_START_BASE+57)
+#define MSG_ID_FWK_CONTROL_DEVICE_RECORD_CMD_RSP                    (MSG_ID_FWK_CONTROL_START_BASE+58)
+#define MSG_ID_FWK_CONTROL_DEVICE_GUARD_CMD_REQ                     (MSG_ID_FWK_CONTROL_START_BASE+59)
+#define MSG_ID_FWK_CONTROL_DEVICE_GUARD_CMD_RSP                     (MSG_ID_FWK_CONTROL_START_BASE+60)
+#define MSG_ID_FWK_CONTROL_DEVICE_TELEBOOT_CMD_REQ                  (MSG_ID_FWK_CONTROL_START_BASE+61)
+#define MSG_ID_FWK_CONTROL_DEVICE_TELEBOOT_CMD_RSP                  (MSG_ID_FWK_CONTROL_START_BASE+62)
+#define MSG_ID_FWK_CONTROL_PROTOCOL_CFG_REQ		                	(MSG_ID_FWK_CONTROL_START_BASE+63)
+#define MSG_ID_FWK_CONTROL_PROTOCOL_CFG_RSP		                	(MSG_ID_FWK_CONTROL_START_BASE+64)
+#define MSG_ID_FWK_CONTROL_PTZ_REQ		                			(MSG_ID_FWK_CONTROL_START_BASE+65)
+#define MSG_ID_FWK_CONTROL_RDT_CMD_REQ		                		(MSG_ID_FWK_CONTROL_START_BASE+66)
+#define MSG_ID_FWK_CONTROL_RDT_CMD_RSP		                		(MSG_ID_FWK_CONTROL_START_BASE+67)
+#define MSG_ID_FWK_CONTROL_RDT_FILE_TRANSFER_IND		            (MSG_ID_FWK_CONTROL_START_BASE+68)
+#define MSG_ID_FWK_CONTROL_STATUS_INFO_REQ		                	(MSG_ID_FWK_CONTROL_START_BASE+69)
+#define MSG_ID_FWK_CONTROL_STATUS_INFO_RSP		                	(MSG_ID_FWK_CONTROL_START_BASE+70)
+#define MSG_ID_FWK_CONTROL_READ_PROTOCOL_CFG_REQ                    (MSG_ID_FWK_CONTROL_START_BASE+71)
+#define MSG_ID_FWK_CONTROL_MESSAGE_ALARM_REQ                        (MSG_ID_FWK_CONTROL_START_BASE+72)
+#define MSG_ID_FWK_CONTROL_MESSAGE_ALARM_RSP                        (MSG_ID_FWK_CONTROL_START_BASE+73)
+#define MSG_ID_FWK_CONTROL_FRONT_DEVICE_CONTROL_PTZ_REQ             (MSG_ID_FWK_CONTROL_START_BASE+74)
+#define MSG_ID_FWK_CONTROL_FRONT_DEVICE_CONTROL_FI_REQ              (MSG_ID_FWK_CONTROL_START_BASE+75)
+#define MSG_ID_FWK_CONTROL_FRONT_DEVICE_CONTROL_PRESET_REQ          (MSG_ID_FWK_CONTROL_START_BASE+76)
+#define MSG_ID_FWK_CONTROL_FRONT_DEVICE_CONTROL_CRUISE_REQ          (MSG_ID_FWK_CONTROL_START_BASE+77)
+#define MSG_ID_FWK_CONTROL_FRONT_DEVICE_CONTROL_SCAN_REQ            (MSG_ID_FWK_CONTROL_START_BASE+78)
+#define MSG_ID_FWK_CONTROL_FRONT_DEVICE_CONTROL_AUX_REQ             (MSG_ID_FWK_CONTROL_START_BASE+79)
+#define MSG_ID_FWK_CONTROL_RDT_FILE_DOWNLOAD_REQ		            (MSG_ID_FWK_CONTROL_START_BASE+80)
+#define MSG_ID_FWK_CONTROL_RDT_FILE_DOWNLOAD_RSP		            (MSG_ID_FWK_CONTROL_START_BASE+81)
+#define MSG_ID_FWK_CONTROL_RDT_FILE_DOWNLOAD_NOTIFY		            (MSG_ID_FWK_CONTROL_START_BASE+82)
+#define MSG_ID_FWK_CONTROL_RDT_FILE_DOWNLOAD_NOTIFY_RSP		        (MSG_ID_FWK_CONTROL_START_BASE+83)
+#define MSG_ID_FWK_CONTROL_RDT_UPDATE_REQ		            		(MSG_ID_FWK_CONTROL_START_BASE+84)
+#define MSG_ID_FWK_CONTROL_RDT_UPDATE_RSP		            		(MSG_ID_FWK_CONTROL_START_BASE+85)
+#define MSG_ID_FWK_CONTROL_VIDEO_TRANSFER_REQ						(MSG_ID_FWK_CONTROL_START_BASE+86)
+#define MSG_ID_FWK_CONTROL_VIDEO_TRANSFER_RSP						(MSG_ID_FWK_CONTROL_START_BASE+87)
+#define MSG_ID_FWK_CONTROL_NOTIFY_SDCARD_ALARM_REQ					(MSG_ID_FWK_CONTROL_START_BASE+88)
+#define MSG_ID_FWK_CONTROL_NOTIFY_SDCARD_ALARM_RSP					(MSG_ID_FWK_CONTROL_START_BASE+89)
+#define MSG_ID_FWK_CONTROL_VIDEO_GET_PARAM_REQ						(MSG_ID_FWK_CONTROL_START_BASE+90)
+#define MSG_ID_FWK_CONTROL_VIDEO_GET_PARAM_RSP						(MSG_ID_FWK_CONTROL_START_BASE+91)
+#define MSG_ID_FWK_CONTROL_VIDEO_SET_PARAM_REQ						(MSG_ID_FWK_CONTROL_START_BASE+92)
+#define MSG_ID_FWK_CONTROL_VIDEO_SET_PARAM_RSP						(MSG_ID_FWK_CONTROL_START_BASE+93)
+#define MSG_ID_FWK_CONTROL_GET_PLAY_CONFIG_REQ						(MSG_ID_FWK_CONTROL_START_BASE+94)
+#define MSG_ID_FWK_CONTROL_GET_PLAY_CONFIG_RSP						(MSG_ID_FWK_CONTROL_START_BASE+95)
+#define MSG_ID_FWK_CONTROL_GET_SDCARD_INFO_REQ						(MSG_ID_FWK_CONTROL_START_BASE+96)
+#define MSG_ID_FWK_CONTROL_GET_SDCARD_INFO_RSP						(MSG_ID_FWK_CONTROL_START_BASE+97)
+#define MSG_ID_FWK_CONTROL_GET_RECORD_LIST_REQ						(MSG_ID_FWK_CONTROL_START_BASE+98)
+#define MSG_ID_FWK_CONTROL_GET_RECORD_LIST_RSP						(MSG_ID_FWK_CONTROL_START_BASE+99)
+#define MSG_ID_FWK_CONTROL_GET_TEST_VALUE_REQ                       (MSG_ID_FWK_CONTROL_START_BASE+100)
+#define MSG_ID_FWK_CONTROL_GET_TEST_VALUE_RSP                       (MSG_ID_FWK_CONTROL_START_BASE+101)
+#define MSG_ID_FWK_CONTROL_SET_PASSWORD_REQ                       	(MSG_ID_FWK_CONTROL_START_BASE+102)
+#define MSG_ID_FWK_CONTROL_SET_PASSWORD_RSP                       	(MSG_ID_FWK_CONTROL_START_BASE+103)
+#define MSG_ID_FWK_CONTROL_RDT_MP4_FILE_CUT_CMD_RSP					(MSG_ID_FWK_CONTROL_START_BASE+104)
+#define MSG_ID_FWK_CONTROL_GET_NETWORK_REQ						(MSG_ID_FWK_CONTROL_START_BASE+105)
+#define MSG_ID_FWK_CONTROL_GET_NETWORK_RSP						(MSG_ID_FWK_CONTROL_START_BASE+106)
+#define MSG_ID_FWK_CONTROL_SET_NETWORK_REQ						(MSG_ID_FWK_CONTROL_START_BASE+107)
+#define MSG_ID_FWK_CONTROL_SET_NETWORK_RSP						(MSG_ID_FWK_CONTROL_START_BASE+108)
+#define MSG_ID_FWK_CONTROL_START_UPGRADE_STATUS_CHECK_REQ			(MSG_ID_FWK_CONTROL_START_BASE+109)
+#define MSG_ID_FWK_CONTROL_START_UPGRADE_STATUS_CHECK_RSP			(MSG_ID_FWK_CONTROL_START_BASE+110)
+
+
+
+
+
+
+
+
+
+/*view message*/
+#define MSG_ID_FWK_VIEW_START_BASE										(FWK_MOD_VIEW<<16)
+
+
+/*camera message*/
+#define MSG_ID_FWK_CAMERA_START_BASE									(FWK_MOD_CAMERA<<16)
+
+
+
+
+/*parameter message*/
+#define MSG_ID_FWK_PARAMETER_START_BASE									(FWK_MOD_PARAMETER<<16)
+
+
+
+
+/*storage message*/
+#define MSG_ID_FWK_STORAGE_START_BASE									(FWK_MOD_STORAGE<<16)
+
+
+
+/*gps message*/
+#define MSG_ID_FWK_GPS_START_BASE										(FWK_MOD_GPS<<16)
+
+
+
+/*wifi message*/
+#define MSG_ID_FWK_WIFI_START_BASE										(FWK_MOD_WIFI<<16)
+
+
+
+/*cellular message*/
+#define MSG_ID_FWK_CELLULAR_START_BASE									(FWK_MOD_CELLULAR<<16)
+
+
+
+/*wrtc message*/
+#define MSG_ID_FWK_WRTC_START_BASE										(FWK_MOD_WRTC<<16)
+
+
+/*GB28181 message*/
+#define MSG_ID_FWK_GB28181_START_BASE									(FWK_MOD_GB28181<<16)
+#define MSG_ID_FWK_GB28181_DEVICE_INFO_REQ								(MSG_ID_FWK_GB28181_START_BASE+1)
+#define MSG_ID_FWK_GB28181_DEVICE_INFO_RSP								(MSG_ID_FWK_GB28181_START_BASE+2)
+#define MSG_ID_FWK_GB28181_CFG_CHANGE_IND								(MSG_ID_FWK_GB28181_START_BASE+3)
+#define MSG_ID_FWK_GB28181_DEVICE_CATALOG_REQ                           (MSG_ID_FWK_GB28181_START_BASE+4)
+#define MSG_ID_FWK_GB28181_DEVICE_CATALOG_RSP                           (MSG_ID_FWK_GB28181_START_BASE+5)
+#define MSG_ID_FWK_GB28181_DEVICE_STATUS_REQ                            (MSG_ID_FWK_GB28181_START_BASE+6)
+#define MSG_ID_FWK_GB28181_DEVICE_STATUS_RSP                            (MSG_ID_FWK_GB28181_START_BASE+7)
+#define MSG_ID_FWK_GB28181_NOTIFY_ALARM_REQ                             (MSG_ID_FWK_GB28181_START_BASE+8)
+#define MSG_ID_FWK_GB28181_NOTIFY_ALARM_RSP                             (MSG_ID_FWK_GB28181_START_BASE+9)
+#define MSG_ID_FWK_GB28181_DEVICE_PTZ_CMD_REQ                           (MSG_ID_FWK_GB28181_START_BASE+10)
+#define MSG_ID_FWK_GB28181_DEVICE_PTZ_CMD_RSP                           (MSG_ID_FWK_GB28181_START_BASE+11)
+#define MSG_ID_FWK_GB28181_DEVICE_RECORD_CMD_REQ                        (MSG_ID_FWK_GB28181_START_BASE+12)
+#define MSG_ID_FWK_GB28181_DEVICE_RECORD_CMD_RSP                        (MSG_ID_FWK_GB28181_START_BASE+13)
+#define MSG_ID_FWK_GB28181_DEVICE_GUARD_CMD_REQ                         (MSG_ID_FWK_GB28181_START_BASE+14)
+#define MSG_ID_FWK_GB28181_DEVICE_GUARD_CMD_RSP                         (MSG_ID_FWK_GB28181_START_BASE+15)
+#define MSG_ID_FWK_GB28181_DEVICE_TELEBOOT_CMD_REQ                      (MSG_ID_FWK_GB28181_START_BASE+16)
+#define MSG_ID_FWK_GB28181_DEVICE_TELEBOOT_CMD_RSP                      (MSG_ID_FWK_GB28181_START_BASE+17)
+#define MSG_ID_FWK_GB28181_STATUS_INFO_REQ                              (MSG_ID_FWK_GB28181_START_BASE+18)
+#define MSG_ID_FWK_GB28181_STATUS_INFO_RSP                              (MSG_ID_FWK_GB28181_START_BASE+19)
+#define MSG_ID_FWK_GB28181_PROTOCOL_CFG_REQ                             (MSG_ID_FWK_GB28181_START_BASE+20)
+#define MSG_ID_FWK_GB28181_PROTOCOL_CFG_RSP                             (MSG_ID_FWK_GB28181_START_BASE+21)
+#define MSG_ID_FWK_GB28181_MESSAGE_ALARM_REQ                            (MSG_ID_FWK_GB28181_START_BASE+22)
+#define MSG_ID_FWK_GB28181_MESSAGE_ALARM_RSP                            (MSG_ID_FWK_GB28181_START_BASE+23)
+#define MSG_ID_FWK_GB28181_FRONT_DEVICE_CONTROL_PTZ_REQ                 (MSG_ID_FWK_GB28181_START_BASE+24)
+#define MSG_ID_FWK_GB28181_FRONT_DEVICE_CONTROL_FI_REQ                  (MSG_ID_FWK_GB28181_START_BASE+25)
+#define MSG_ID_FWK_GB28181_FRONT_DEVICE_CONTROL_PRESET_REQ              (MSG_ID_FWK_GB28181_START_BASE+26)
+#define MSG_ID_FWK_GB28181_FRONT_DEVICE_CONTROL_CRUISE_REQ              (MSG_ID_FWK_GB28181_START_BASE+27)
+#define MSG_ID_FWK_GB28181_FRONT_DEVICE_CONTROL_SCAN_REQ                (MSG_ID_FWK_GB28181_START_BASE+28)
+#define MSG_ID_FWK_GB28181_FRONT_DEVICE_CONTROL_AUX_REQ                 (MSG_ID_FWK_GB28181_START_BASE+29)
+#define MSG_ID_FWK_GB28181_CONTROL_VIDEO_TRANSFER_REQ					(MSG_ID_FWK_GB28181_START_BASE+30)
+#define MSG_ID_FWK_GB28181_CONTROL_VIDEO_TRANSFER_RSP					(MSG_ID_FWK_GB28181_START_BASE+31)
+
+
+
+
+/*Glue message*/
+#define MSG_ID_FWK_GLUE_START_BASE										(FWK_MOD_GLUE<<16)
+#define MSG_ID_FWK_GLUE_DEVICE_INFO_REQ									(MSG_ID_FWK_GLUE_START_BASE+1)
+#define MSG_ID_FWK_GLUE_DEVICE_INFO_RSP									(MSG_ID_FWK_GLUE_START_BASE+2)
+#define MSG_ID_FWK_GLUE_DEVICE_CATALOG_REQ                              (MSG_ID_FWK_GLUE_START_BASE+3)
+#define MSG_ID_FWK_GLUE_DEVICE_CATALOG_RSP                              (MSG_ID_FWK_GLUE_START_BASE+4)
+#define MSG_ID_FWK_GLUE_DEVICE_STATUS_REQ                               (MSG_ID_FWK_GLUE_START_BASE+5)
+#define MSG_ID_FWK_GLUE_DEVICE_STATUS_RSP                               (MSG_ID_FWK_GLUE_START_BASE+6)
+#define MSG_ID_FWK_GLUE_NOTIFY_ALARM_REQ                                (MSG_ID_FWK_GLUE_START_BASE+7)
+#define MSG_ID_FWK_GLUE_NOTIFY_ALARM_RSP                                (MSG_ID_FWK_GLUE_START_BASE+8)
+#define MSG_ID_FWK_GLUE_DEVICE_PTZ_CMD_REQ                              (MSG_ID_FWK_GLUE_START_BASE+9)
+#define MSG_ID_FWK_GLUE_DEVICE_PTZ_CMD_RSP                              (MSG_ID_FWK_GLUE_START_BASE+10)
+#define MSG_ID_FWK_GLUE_DEVICE_RECORD_CMD_REQ                           (MSG_ID_FWK_GLUE_START_BASE+11)
+#define MSG_ID_FWK_GLUE_DEVICE_RECORD_CMD_RSP                           (MSG_ID_FWK_GLUE_START_BASE+12)
+#define MSG_ID_FWK_GLUE_DEVICE_GUARD_CMD_REQ                            (MSG_ID_FWK_GLUE_START_BASE+13)
+#define MSG_ID_FWK_GLUE_DEVICE_GUARD_CMD_RSP                            (MSG_ID_FWK_GLUE_START_BASE+14)
+#define MSG_ID_FWK_GLUE_DEVICE_TELEBOOT_CMD_REQ                         (MSG_ID_FWK_GLUE_START_BASE+15)
+#define MSG_ID_FWK_GLUE_DEVICE_TELEBOOT_CMD_RSP                         (MSG_ID_FWK_GLUE_START_BASE+16)
+#define MSG_ID_FWK_GLUE_TAKE_PICTURE_REQ								(MSG_ID_FWK_GLUE_START_BASE+17)
+#define MSG_ID_FWK_GLUE_TAKE_PICTURE_RSP								(MSG_ID_FWK_GLUE_START_BASE+18)
+#define MSG_ID_FWK_GLUE_SET_VALUE_REQ									(MSG_ID_FWK_GLUE_START_BASE+19)
+#define MSG_ID_FWK_GLUE_SET_VALUE_RSP									(MSG_ID_FWK_GLUE_START_BASE+20)
+#define MSG_ID_FWK_GLUE_GET_PARAS_REQ									(MSG_ID_FWK_GLUE_START_BASE+21)
+#define MSG_ID_FWK_GLUE_GET_PARAS_RSP									(MSG_ID_FWK_GLUE_START_BASE+22)
+#define MSG_ID_FWK_GLUE_SET_DATE_TIME_REQ								(MSG_ID_FWK_GLUE_START_BASE+23)
+#define MSG_ID_FWK_GLUE_SET_DATE_TIME_RSP								(MSG_ID_FWK_GLUE_START_BASE+24)
+#define MSG_ID_FWK_GLUE_SET_WIFIPASSWD_REQ								(MSG_ID_FWK_GLUE_START_BASE+25)
+#define MSG_ID_FWK_GLUE_SET_WIFIPASSWD_RSP								(MSG_ID_FWK_GLUE_START_BASE+26)
+#define MSG_ID_FWK_GLUE_GET_FILES_REQ									(MSG_ID_FWK_GLUE_START_BASE+27)
+#define MSG_ID_FWK_GLUE_GET_FILES_RSP									(MSG_ID_FWK_GLUE_START_BASE+28)
+#define MSG_ID_FWK_GLUE_GET_FILE_INFO_REQ								(MSG_ID_FWK_GLUE_START_BASE+29)
+#define MSG_ID_FWK_GLUE_GET_FILE_INFO_RSP								(MSG_ID_FWK_GLUE_START_BASE+30)
+#define MSG_ID_FWK_GLUE_GET_GPS_INFO_REQ								(MSG_ID_FWK_GLUE_START_BASE+31)
+#define MSG_ID_FWK_GLUE_GET_GPS_INFO_RSP								(MSG_ID_FWK_GLUE_START_BASE+32)
+#define MSG_ID_FWK_GLUE_GET_FILE_LIST_D_REQ								(MSG_ID_FWK_GLUE_START_BASE+33)
+#define MSG_ID_FWK_GLUE_GET_FILE_LIST_D_RSP								(MSG_ID_FWK_GLUE_START_BASE+34)
+#define MSG_ID_FWK_GLUE_DEL_FILE_REQ									(MSG_ID_FWK_GLUE_START_BASE+35)
+#define MSG_ID_FWK_GLUE_DEL_FILE_RSP									(MSG_ID_FWK_GLUE_START_BASE+36)
+#define MSG_ID_FWK_GLUE_AP_INFO_REQ										(MSG_ID_FWK_GLUE_START_BASE+37)
+#define MSG_ID_FWK_GLUE_AP_INFO_RSP										(MSG_ID_FWK_GLUE_START_BASE+38)
+#define MSG_ID_FWK_GLUE_CAM_NUMBER_INFO_REQ								(MSG_ID_FWK_GLUE_START_BASE+39)
+#define MSG_ID_FWK_GLUE_CAM_NUMBER_INFO_RSP								(MSG_ID_FWK_GLUE_START_BASE+40)
+#define MSG_ID_FWK_GLUE_RTSP_URL_REQ									(MSG_ID_FWK_GLUE_START_BASE+41)
+#define MSG_ID_FWK_GLUE_RTSP_URL_RSP									(MSG_ID_FWK_GLUE_START_BASE+42)
+#define MSG_ID_FWK_GLUE_COMMU_SWITCH_REQ								(MSG_ID_FWK_GLUE_START_BASE+43)
+#define MSG_ID_FWK_GLUE_COMMU_SWITCH_RSP								(MSG_ID_FWK_GLUE_START_BASE+44)
+#define MSG_ID_FWK_GLUE_PTZ_REQ		                					(MSG_ID_FWK_GLUE_START_BASE+45)
+#define MSG_ID_FWK_GLUE_STATUS_INFO_REQ 								(MSG_ID_FWK_GLUE_START_BASE+46)
+#define MSG_ID_FWK_GLUE_MESSAGE_ALARM_REQ                               (MSG_ID_FWK_GLUE_START_BASE+47)
+#define MSG_ID_FWK_GLUE_MESSAGE_ALARM_RSP                               (MSG_ID_FWK_GLUE_START_BASE+48)
+#define MSG_ID_FWK_GLUE_FRONT_DEVICE_CONTROL_PTZ_REQ                    (MSG_ID_FWK_GLUE_START_BASE+49)
+#define MSG_ID_FWK_GLUE_FRONT_DEVICE_CONTROL_FI_REQ                     (MSG_ID_FWK_GLUE_START_BASE+50)
+#define MSG_ID_FWK_GLUE_FRONT_DEVICE_CONTROL_PRESET_REQ                 (MSG_ID_FWK_GLUE_START_BASE+51)
+#define MSG_ID_FWK_GLUE_FRONT_DEVICE_CONTROL_CRUISE_REQ                 (MSG_ID_FWK_GLUE_START_BASE+52)
+#define MSG_ID_FWK_GLUE_FRONT_DEVICE_CONTROL_SCAN_REQ                   (MSG_ID_FWK_GLUE_START_BASE+53)
+#define MSG_ID_FWK_GLUE_FRONT_DEVICE_CONTROL_AUX_REQ                    (MSG_ID_FWK_GLUE_START_BASE+54)
+#define MSG_ID_FWK_GLUE_UPDATE_REQ                    					(MSG_ID_FWK_GLUE_START_BASE+55)
+#define MSG_ID_FWK_GLUE_UPDATE_RSP                    					(MSG_ID_FWK_GLUE_START_BASE+56)
+#define MSG_ID_FWK_GLUE_CONTROL_VIDEO_TRANSFER_REQ						(MSG_ID_FWK_GLUE_START_BASE+57)
+#define MSG_ID_FWK_GLUE_CONTROL_VIDEO_TRANSFER_RSP						(MSG_ID_FWK_GLUE_START_BASE+58)
+#define MSG_ID_FWK_GLUE_VIDEO_GET_PARAM_REQ								(MSG_ID_FWK_GLUE_START_BASE+59)
+#define MSG_ID_FWK_GLUE_VIDEO_GET_PARAM_RSP								(MSG_ID_FWK_GLUE_START_BASE+60)
+#define MSG_ID_FWK_GLUE_VIDEO_SET_PARAM_REQ								(MSG_ID_FWK_GLUE_START_BASE+61)
+#define MSG_ID_FWK_GLUE_VIDEO_SET_PARAM_RSP								(MSG_ID_FWK_GLUE_START_BASE+62)
+#define MSG_ID_FWK_GLUE_GET_PLAY_CONFIG_REQ								(MSG_ID_FWK_GLUE_START_BASE+63)
+#define MSG_ID_FWK_GLUE_GET_PLAY_CONFIG_RSP								(MSG_ID_FWK_GLUE_START_BASE+64)
+#define MSG_ID_FWK_GLUE_GET_RECORD_LIST_REQ								(MSG_ID_FWK_GLUE_START_BASE+65)
+#define MSG_ID_FWK_GLUE_GET_RECORD_LIST_RSP								(MSG_ID_FWK_GLUE_START_BASE+66)
+#define MSG_ID_FWK_GLUE_TEST_VALUE_REQ                                  (MSG_ID_FWK_GLUE_START_BASE+67)
+#define MSG_ID_FWK_GLUE_GET_NETWORK_REQ						(MSG_ID_FWK_CONTROL_START_BASE+68)
+#define MSG_ID_FWK_GLUE_SET_NETWORK_REQ						(MSG_ID_FWK_CONTROL_START_BASE+70)
+
+
+
+
+
+
+/*IOTC message*/
+#define MSG_ID_FWK_IOTC_START_BASE										(FWK_MOD_IOTC<<16)
+#define MSG_ID_FWK_IOTC_DEVICE_INFO_REQ									(MSG_ID_FWK_IOTC_START_BASE+1)
+#define MSG_ID_FWK_IOTC_DEVICE_INFO_RSP									(MSG_ID_FWK_IOTC_START_BASE+2)
+#define MSG_ID_FWK_IOTC_RK_JSON_MESSAGE_RSP		                		(MSG_ID_FWK_IOTC_START_BASE+3)
+#define MSG_ID_FWK_IOTC_PROTOCOL_CFG_REQ		                		(MSG_ID_FWK_IOTC_START_BASE+4)
+#define MSG_ID_FWK_IOTC_PROTOCOL_CFG_RSP		                		(MSG_ID_FWK_IOTC_START_BASE+5)
+#define MSG_ID_FWK_IOTC_RDT_CMD_REQ		                				(MSG_ID_FWK_IOTC_START_BASE+6)
+#define MSG_ID_FWK_IOTC_RDT_CMD_RSP		                				(MSG_ID_FWK_IOTC_START_BASE+7)
+#define MSG_ID_FWK_IOTC_RDT_FILE_TRANSFER_IND		                	(MSG_ID_FWK_IOTC_START_BASE+8)
+#define MSG_ID_FWK_IOTC_MESSAGE_ALARM_REQ								(MSG_ID_FWK_IOTC_START_BASE+9)
+#define MSG_ID_FWK_IOTC_RDT_FILE_DOWNLOAD_REQ		                	(MSG_ID_FWK_IOTC_START_BASE+10)
+#define MSG_ID_FWK_IOTC_RDT_FILE_DOWNLOAD_RSP		                	(MSG_ID_FWK_IOTC_START_BASE+11)
+#define MSG_ID_FWK_IOTC_RDT_FILE_DOWNLOAD_NOTIFY		                (MSG_ID_FWK_IOTC_START_BASE+12)
+#define MSG_ID_FWK_IOTC_RDT_FILE_DOWNLOAD_NOTIFY_RSP		            (MSG_ID_FWK_IOTC_START_BASE+13)
+#define MSG_ID_FWK_IOTC_RDT_UPDATE_REQ		            				(MSG_ID_FWK_IOTC_START_BASE+14)
+#define MSG_ID_FWK_IOTC_RDT_UPDATE_RSP		            				(MSG_ID_FWK_IOTC_START_BASE+15)
+#define MSG_ID_FWK_IOTC_SET_PASSWORD_REQ		            			(MSG_ID_FWK_IOTC_START_BASE+16)
+#define MSG_ID_FWK_IOTC_SET_PASSWORD_RSP		            			(MSG_ID_FWK_IOTC_START_BASE+17)
+
+
+
+
+
+/*FWK_MOD_Reserverd1 message*/
+#define MSG_ID_FWK_RESERVERD1_START_BASE								(FWK_MOD_Reserverd1<<16)
+#define MSG_ID_FWK_RESERVERD1_RDT_CMD_REQ		                		(MSG_ID_FWK_RESERVERD1_START_BASE+1)
+#define MSG_ID_FWK_RESERVERD1_RDT_CMD_RSP		                		(MSG_ID_FWK_RESERVERD1_START_BASE+2)
+#define MSG_ID_FWK_RESERVERD1_RDT_FILE_TRANSFER_IND		                (MSG_ID_FWK_RESERVERD1_START_BASE+3)
+#define MSG_ID_FWK_RESERVERD1_RDT_FILE_DOWNLOAD_REQ		                (MSG_ID_FWK_RESERVERD1_START_BASE+4)
+#define MSG_ID_FWK_RESERVERD1_RDT_FILE_DOWNLOAD_RSP		                (MSG_ID_FWK_RESERVERD1_START_BASE+5)
+#define MSG_ID_FWK_RESERVERD1_RDT_FILE_DOWNLOAD_NOTIFY		            (MSG_ID_FWK_RESERVERD1_START_BASE+6)
+#define MSG_ID_FWK_RESERVERD1_RDT_FILE_DOWNLOAD_NOTIFY_RSP		        (MSG_ID_FWK_RESERVERD1_START_BASE+7)
+#define MSG_ID_FWK_RESERVERD1_RDT_UPDATE_REQ		        			(MSG_ID_FWK_RESERVERD1_START_BASE+8)
+#define MSG_ID_FWK_RESERVERD1_RDT_UPDATE_RSP		        			(MSG_ID_FWK_RESERVERD1_START_BASE+9)
+
+
+
+/*ONVIF message*/
+#define MSG_ID_FWK_ONVIF_START_BASE										(FWK_MOD_ONVIF<<16)
+#define MSG_ID_FWK_ONVIF_DEVICE_INFO_REQ								(MSG_ID_FWK_ONVIF_START_BASE+1)
+#define MSG_ID_FWK_ONVIF_DEVICE_INFO_RSP								(MSG_ID_FWK_ONVIF_START_BASE+2)
+#define MSG_ID_FWK_ONVIF_WSDL_URL_REQ									(MSG_ID_FWK_ONVIF_START_BASE+3)
+#define MSG_ID_FWK_ONVIF_WSDL_URL_RSP									(MSG_ID_FWK_ONVIF_START_BASE+4)
+#define MSG_ID_FWK_ONVIF_SERVICES_RNTRY_REQ								(MSG_ID_FWK_ONVIF_START_BASE+5)
+#define MSG_ID_FWK_ONVIF_SERVICES_RNTRY_RSP								(MSG_ID_FWK_ONVIF_START_BASE+6)
+#define MSG_ID_FWK_ONVIF_IP_INFO_REQ									(MSG_ID_FWK_ONVIF_START_BASE+7)
+#define MSG_ID_FWK_ONVIF_IP_INFO_RSP									(MSG_ID_FWK_ONVIF_START_BASE+8)
+#define MSG_ID_FWK_ONVIF_GET_DATATIME_REQ								(MSG_ID_FWK_ONVIF_START_BASE+9)
+#define MSG_ID_FWK_ONVIF_GET_DATATIME_RSP								(MSG_ID_FWK_ONVIF_START_BASE+10)
+#define MSG_ID_FWK_ONVIF_SET_DATATIME_REQ								(MSG_ID_FWK_ONVIF_START_BASE+11)
+#define MSG_ID_FWK_ONVIF_SET_DATATIME_RSP								(MSG_ID_FWK_ONVIF_START_BASE+12)
+#define MSG_ID_FWK_ONVIF_FACTORY_RESET_REQ								(MSG_ID_FWK_ONVIF_START_BASE+13)
+#define MSG_ID_FWK_ONVIF_FACTORY_RESET_RSP								(MSG_ID_FWK_ONVIF_START_BASE+14)
+#define MSG_ID_FWK_ONVIF_REBOOT_REQ										(MSG_ID_FWK_ONVIF_START_BASE+15)
+#define MSG_ID_FWK_ONVIF_REBOOT_RSP										(MSG_ID_FWK_ONVIF_START_BASE+16)
+#define MSG_ID_FWK_ONVIF_GET_SCOPES_REQ									(MSG_ID_FWK_ONVIF_START_BASE+17)
+#define MSG_ID_FWK_ONVIF_GET_SCOPES_RSP									(MSG_ID_FWK_ONVIF_START_BASE+18)
+#define MSG_ID_FWK_ONVIF_SET_SCOPES_REQ									(MSG_ID_FWK_ONVIF_START_BASE+19)
+#define MSG_ID_FWK_ONVIF_SET_SCOPES_RSP									(MSG_ID_FWK_ONVIF_START_BASE+20)
+#define MSG_ID_FWK_ONVIF_ADD_SCOPES_REQ									(MSG_ID_FWK_ONVIF_START_BASE+21)
+#define MSG_ID_FWK_ONVIF_ADD_SCOPES_RSP									(MSG_ID_FWK_ONVIF_START_BASE+22)
+#define MSG_ID_FWK_ONVIF_REMOVE_SCOPES_REQ								(MSG_ID_FWK_ONVIF_START_BASE+23)
+#define MSG_ID_FWK_ONVIF_REMOVE_SCOPES_RSP								(MSG_ID_FWK_ONVIF_START_BASE+24)
+#define MSG_ID_FWK_ONVIF_GET_DISCOVERY_MODE_REQ							(MSG_ID_FWK_ONVIF_START_BASE+25)
+#define MSG_ID_FWK_ONVIF_GET_DISCOVERY_MODE_RSP							(MSG_ID_FWK_ONVIF_START_BASE+26)
+#define MSG_ID_FWK_ONVIF_FW_UPDATE_REQ									(MSG_ID_FWK_ONVIF_START_BASE+27)
+#define MSG_ID_FWK_ONVIF_FW_UPDATE_RSP									(MSG_ID_FWK_ONVIF_START_BASE+28)
+#define MSG_ID_FWK_ONVIF_GET_ENDPOINT_REF_REQ							(MSG_ID_FWK_ONVIF_START_BASE+29)
+#define MSG_ID_FWK_ONVIF_GET_ENDPOINT_REF_RSP							(MSG_ID_FWK_ONVIF_START_BASE+30)
+#define MSG_ID_FWK_ONVIF_GET_HOSTNAME_REQ								(MSG_ID_FWK_ONVIF_START_BASE+31)
+#define MSG_ID_FWK_ONVIF_GET_HOSTNAME_RSP								(MSG_ID_FWK_ONVIF_START_BASE+32)
+#define MSG_ID_FWK_ONVIF_SET_HOSTNAME_REQ								(MSG_ID_FWK_ONVIF_START_BASE+33)
+#define MSG_ID_FWK_ONVIF_SET_HOSTNAME_RSP								(MSG_ID_FWK_ONVIF_START_BASE+34)
+#define MSG_ID_FWK_ONVIF_GET_NETWORK_PROTOCOL_REQ						(MSG_ID_FWK_ONVIF_START_BASE+35)
+#define MSG_ID_FWK_ONVIF_GET_NETWORK_PROTOCOL_RSP						(MSG_ID_FWK_ONVIF_START_BASE+36)
+#define MSG_ID_FWK_ONVIF_SET_NETWORK_PROTOCOL_REQ						(MSG_ID_FWK_ONVIF_START_BASE+37)
+#define MSG_ID_FWK_ONVIF_SET_NETWORK_PROTOCOL_RSP						(MSG_ID_FWK_ONVIF_START_BASE+38)
+#define MSG_ID_FWK_ONVIF_METADATA										(MSG_ID_FWK_ONVIF_START_BASE+39)	
+#define MSG_ID_FWK_ONVIF_SET_DISCOVERY_MODE_REQ							(MSG_ID_FWK_ONVIF_START_BASE+40)
+#define MSG_ID_FWK_ONVIF_SET_DISCOVERY_MODE_RSP							(MSG_ID_FWK_ONVIF_START_BASE+41)
+#define MSG_ID_FWK_ONVIF_EVENT_DISCOVERYMODE							(MSG_ID_FWK_ONVIF_START_BASE+42)
+#define MSG_ID_FWK_ONVIF_START_UPGRADE_IND_REQ							(MSG_ID_FWK_ONVIF_START_BASE+43)
+#define MSG_ID_FWK_ONVIF_START_UPGRADE_IND_RSP							(MSG_ID_FWK_ONVIF_START_BASE+44)
+#define MSG_ID_FWK_ONVIF_START_UPGRADE_STATUS_CHECK_REQ					(MSG_ID_FWK_ONVIF_START_BASE+45)
+#define MSG_ID_FWK_ONVIF_START_UPGRADE_STATUS_CHECK_RSP					(MSG_ID_FWK_ONVIF_START_BASE+46)
+#define MSG_ID_FWK_ONVIF_GET_USER_INFO_REQ								(MSG_ID_FWK_ONVIF_START_BASE+47)
+#define MSG_ID_FWK_ONVIF_GET_USER_INFO_RSP								(MSG_ID_FWK_ONVIF_START_BASE+48)
+#define MSG_ID_FWK_ONVIF_EVENT_GET_PROPERTIES_REQ						(MSG_ID_FWK_ONVIF_START_BASE+49)
+#define MSG_ID_FWK_ONVIF_EVENT_GET_PROPERTIES_RSP						(MSG_ID_FWK_ONVIF_START_BASE+50)
+#define MSG_ID_FWK_ONVIF_CREATE_USERS_REQ								(MSG_ID_FWK_ONVIF_START_BASE+51)
+#define MSG_ID_FWK_ONVIF_CREATE_USERS_RSP								(MSG_ID_FWK_ONVIF_START_BASE+52)
+#define MSG_ID_FWK_ONVIF_DEL_USERS_REQ									(MSG_ID_FWK_ONVIF_START_BASE+53)
+#define MSG_ID_FWK_ONVIF_DEL_USERS_RSP									(MSG_ID_FWK_ONVIF_START_BASE+54)
+#define MSG_ID_FWK_ONVIF_GET_USERS_REQ									(MSG_ID_FWK_ONVIF_START_BASE+55)
+#define MSG_ID_FWK_ONVIF_GET_USERS_RSP									(MSG_ID_FWK_ONVIF_START_BASE+56)
+#define MSG_ID_FWK_ONVIF_SET_USERS_REQ									(MSG_ID_FWK_ONVIF_START_BASE+57)
+#define MSG_ID_FWK_ONVIF_SET_USERS_RSP									(MSG_ID_FWK_ONVIF_START_BASE+58)
+#define MSG_ID_FWK_ONVIF_EVENT_PRODUCER_SUBSCRIBE_REQ					(MSG_ID_FWK_ONVIF_START_BASE+59)
+#define MSG_ID_FWK_ONVIF_EVENT_PRODUCER_SUBSCRIBE_RSP					(MSG_ID_FWK_ONVIF_START_BASE+60)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_RENEW_REQ						(MSG_ID_FWK_ONVIF_START_BASE+61)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_RENEW_RSP						(MSG_ID_FWK_ONVIF_START_BASE+62)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_UNSUBSCRIBE_REQ				(MSG_ID_FWK_ONVIF_START_BASE+63)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_UNSUBSCRIBE_RSP				(MSG_ID_FWK_ONVIF_START_BASE+64)
+#define MSG_ID_FWK_ONVIF_EVENT_PULL_MESSAGE_REQ							(MSG_ID_FWK_ONVIF_START_BASE+65)
+#define MSG_ID_FWK_ONVIF_EVENT_PULL_MESSAGE_RSP							(MSG_ID_FWK_ONVIF_START_BASE+66)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_PAUSE_REQ						(MSG_ID_FWK_ONVIF_START_BASE+67)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_PAUSE_RSP						(MSG_ID_FWK_ONVIF_START_BASE+68)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_RESUME_REQ					(MSG_ID_FWK_ONVIF_START_BASE+69)
+#define MSG_ID_FWK_ONVIF_EVENT_SUBMANAGER_RESUME_RSP					(MSG_ID_FWK_ONVIF_START_BASE+70)
+#define MSG_ID_FWK_ONVIF_EVENT_MOTO_ALARM_IND							(MSG_ID_FWK_ONVIF_START_BASE+71)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_NODES_REQ								(MSG_ID_FWK_ONVIF_START_BASE+72)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_NODES_RSP								(MSG_ID_FWK_ONVIF_START_BASE+73)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_NODE_REQ								(MSG_ID_FWK_ONVIF_START_BASE+74)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_NODE_RSP								(MSG_ID_FWK_ONVIF_START_BASE+75)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_CONFIGURATIONS_REQ						(MSG_ID_FWK_ONVIF_START_BASE+76)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_CONFIGURATIONS_RSP						(MSG_ID_FWK_ONVIF_START_BASE+77)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_CONFIGURATION_REQ						(MSG_ID_FWK_ONVIF_START_BASE+78)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_CONFIGURATION_RSP						(MSG_ID_FWK_ONVIF_START_BASE+79)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_COM_CONFIGURATION_REQ					(MSG_ID_FWK_ONVIF_START_BASE+80)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_COM_CONFIGURATION_RSP					(MSG_ID_FWK_ONVIF_START_BASE+81)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_CONFIGURATION_OPTIONS_REQ				(MSG_ID_FWK_ONVIF_START_BASE+82)
+#define MSG_ID_FWK_ONVIF_GET_PTZ_CONFIGURATION_OPTIONS_RSP				(MSG_ID_FWK_ONVIF_START_BASE+83)
+#define MSG_ID_FWK_ONVIF_SET_PTZ_CONFIGURATION_REQ						(MSG_ID_FWK_ONVIF_START_BASE+84)
+#define MSG_ID_FWK_ONVIF_SET_PTZ_CONFIGURATION_RSP						(MSG_ID_FWK_ONVIF_START_BASE+85)
+#define MSG_ID_FWK_ONVIF_PTZ_ABSOLUTE_MOVE_REQ							(MSG_ID_FWK_ONVIF_START_BASE+86)
+#define	MSG_ID_FWK_ONVIF_PTZ_ABSOLUTE_MOVE_RSP							(MSG_ID_FWK_ONVIF_START_BASE+87)
+#define MSG_ID_FWK_ONVIF_PTZ_RELATIVE_MOVE_REQ							(MSG_ID_FWK_ONVIF_START_BASE+88)
+#define MSG_ID_FWK_ONVIF_PTZ_RELATIVE_MOVE_RSP							(MSG_ID_FWK_ONVIF_START_BASE+89)
+#define MSG_ID_FWK_ONVIF_PTZ_CONTINUOUS_MOVE_REQ						(MSG_ID_FWK_ONVIF_START_BASE+90)
+#define MSG_ID_FWK_ONVIF_PTZ_CONTINUOUS_MOVE_RSP						(MSG_ID_FWK_ONVIF_START_BASE+91)
+#define MSG_ID_FWK_ONVIF_PTZ_STOP_REQ									(MSG_ID_FWK_ONVIF_START_BASE+92)
+#define MSG_ID_FWK_ONVIF_PTZ_STOP_RSP									(MSG_ID_FWK_ONVIF_START_BASE+93)
+#define MSG_ID_FWK_ONVIF_PTZ_GET_STATUS_REQ								(MSG_ID_FWK_ONVIF_START_BASE+94)
+#define MSG_ID_FWK_ONVIF_PTZ_GET_STATUS_RSP								(MSG_ID_FWK_ONVIF_START_BASE+95)
+
+#define MSG_ID_FWK_ONVIF_GET_ALL_PROFILES_REQ							(MSG_ID_FWK_ONVIF_START_BASE+96)
+#define MSG_ID_FWK_ONVIF_GET_ALL_PROFILES_RSP							(MSG_ID_FWK_ONVIF_START_BASE+97)
+#define MSG_ID_FWK_ONVIF_GET_SPECIFIC_PROFILE_REQ						(MSG_ID_FWK_ONVIF_START_BASE+98)
+#define MSG_ID_FWK_ONVIF_GET_SPECIFIC_PROFILE_RSP						(MSG_ID_FWK_ONVIF_START_BASE+99)
+
+
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_REQ							(MSG_ID_FWK_ONVIF_START_BASE+100)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_RSP							(MSG_ID_FWK_ONVIF_START_BASE+101)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_CONFIG_REQ					(MSG_ID_FWK_ONVIF_START_BASE+102)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_CONFIG_RSP					(MSG_ID_FWK_ONVIF_START_BASE+103)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_ALL_CONFIGS_REQ				(MSG_ID_FWK_ONVIF_START_BASE+104)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_ALL_CONFIGS_RSP				(MSG_ID_FWK_ONVIF_START_BASE+105)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_CONFIG_OPT_REQ				(MSG_ID_FWK_ONVIF_START_BASE+106)
+#define MSG_ID_FWK_ONVIF_GET_VIDEO_SOURCES_CONFIG_OPT_RSP				(MSG_ID_FWK_ONVIF_START_BASE+107)
+
+#define MSG_ID_FWK_ONVIF_GET_VENCODER_ALL_CONFIGS_REQ					(MSG_ID_FWK_ONVIF_START_BASE+108)
+#define MSG_ID_FWK_ONVIF_GET_VENCODER_ALL_CONFIGS_RSP					(MSG_ID_FWK_ONVIF_START_BASE+109)
+#define MSG_ID_FWK_ONVIF_GET_VENCODER_SPEC_CONFIG_REQ					(MSG_ID_FWK_ONVIF_START_BASE+110)
+#define MSG_ID_FWK_ONVIF_GET_VENCODER_SPEC_CONFIG_RSP					(MSG_ID_FWK_ONVIF_START_BASE+111)
+#define MSG_ID_FWK_ONVIF_GET_VENCODER_CONFIG_OPT_REQ					(MSG_ID_FWK_ONVIF_START_BASE+112)
+#define MSG_ID_FWK_ONVIF_GET_VENCODER_CONFIG_OPT_RSP					(MSG_ID_FWK_ONVIF_START_BASE+113)
+#define MSG_ID_FWK_ONVIF_GET_GUA_NUM_VENCODER_REQ						(MSG_ID_FWK_ONVIF_START_BASE+114)
+#define MSG_ID_FWK_ONVIF_GET_GUA_NUM_VENCODER_RSP						(MSG_ID_FWK_ONVIF_START_BASE+115)
+#define MSG_ID_FWK_ONVIF_SET_VENCODER_CONFIG_REQ						(MSG_ID_FWK_ONVIF_START_BASE+116)
+#define MSG_ID_FWK_ONVIF_SET_VENCODER_CONFIG_RSP						(MSG_ID_FWK_ONVIF_START_BASE+117)
+
+
+#define MSG_ID_FWK_ONVIF_GET_STREAM_URI_REQ								(MSG_ID_FWK_ONVIF_START_BASE+118)
+#define MSG_ID_FWK_ONVIF_GET_STREAM_URI_RSP								(MSG_ID_FWK_ONVIF_START_BASE+119)
+#define MSG_ID_FWK_ONVIF_GET_SNAPSHOT_REQ								(MSG_ID_FWK_ONVIF_START_BASE+120)
+#define MSG_ID_FWK_ONVIF_GET_SNAPSHOT_RSP								(MSG_ID_FWK_ONVIF_START_BASE+121)
+#define MSG_ID_FWK_ONVIF_SET_SYNCHRONIZATION_POINT_REQ					(MSG_ID_FWK_ONVIF_START_BASE+122)
+#define MSG_ID_FWK_ONVIF_SET_SYNCHRONIZATION_POINT_RSP					(MSG_ID_FWK_ONVIF_START_BASE+123)
+
+#define MSG_ID_FWK_ONVIF_GET_IMAGE_SETTINGS_REQ							(MSG_ID_FWK_ONVIF_START_BASE+124)
+#define MSG_ID_FWK_ONVIF_GET_IMAGE_SETTINGS_RSP							(MSG_ID_FWK_ONVIF_START_BASE+125)
+#define MSG_ID_FWK_ONVIF_SET_IMAGE_SETTINGS_REQ							(MSG_ID_FWK_ONVIF_START_BASE+126)
+#define MSG_ID_FWK_ONVIF_SET_IMAGE_SETTINGS_RSP							(MSG_ID_FWK_ONVIF_START_BASE+127)
+#define MSG_ID_FWK_ONVIF_GET_IMAGE_OPTIONS_REQ							(MSG_ID_FWK_ONVIF_START_BASE+128)
+#define MSG_ID_FWK_ONVIF_GET_IMAGE_OPTIONS_RSP							(MSG_ID_FWK_ONVIF_START_BASE+129)
+
+#define MSG_ID_FWK_ONVIF_GET_COMPATIBLE_VIDEO_SOURCES_CONFIGS_REQ		(MSG_ID_FWK_ONVIF_START_BASE+130)
+#define MSG_ID_FWK_ONVIF_GET_COMPATIBLE_VIDEO_SOURCES_CONFIGS_RSP		(MSG_ID_FWK_ONVIF_START_BASE+131)
+#define MSG_ID_FWK_ONVIF_GET_COMPATIBLE_VENCODER_CONFIGS_REQ			(MSG_ID_FWK_ONVIF_START_BASE+132)
+#define MSG_ID_FWK_ONVIF_GET_COMPATIBLE_VENCODER_CONFIGS_RSP			(MSG_ID_FWK_ONVIF_START_BASE+133)
+#define MSG_ID_FWK_ONVIF_GET_COMPATIBLE_PTZ_CONFIGS_REQ					(MSG_ID_FWK_ONVIF_START_BASE+134)
+#define MSG_ID_FWK_ONVIF_GET_COMPATIBLE_PTZ_CONFIGS_RSP					(MSG_ID_FWK_ONVIF_START_BASE+135)
+
+#define MSG_ID_FWK_ONVIF_GET_NET_INTERFACE_CONFIG_REQ					(MSG_ID_FWK_ONVIF_START_BASE+136)
+#define MSG_ID_FWK_ONVIF_GET_NET_INTERFACE_CONFIG_RSP					(MSG_ID_FWK_ONVIF_START_BASE+137)
+#define MSG_ID_FWK_ONVIF_SET_NET_INTERFACE_CONFIG_REQ					(MSG_ID_FWK_ONVIF_START_BASE+138)
+#define MSG_ID_FWK_ONVIF_SET_NET_INTERFACE_CONFIG_RSP					(MSG_ID_FWK_ONVIF_START_BASE+139)
+
+#define MSG_ID_FWK_ONVIF_GET_DNS_REQ									(MSG_ID_FWK_ONVIF_START_BASE+140)
+#define MSG_ID_FWK_ONVIF_GET_DNS_RSP									(MSG_ID_FWK_ONVIF_START_BASE+141)
+#define MSG_ID_FWK_ONVIF_SET_DNS_REQ									(MSG_ID_FWK_ONVIF_START_BASE+142)
+#define MSG_ID_FWK_ONVIF_SET_DNS_RSP									(MSG_ID_FWK_ONVIF_START_BASE+143)
+
+#define MSG_ID_FWK_ONVIF_GET_GATEWAY_REQ								(MSG_ID_FWK_ONVIF_START_BASE+144)
+#define MSG_ID_FWK_ONVIF_GET_GATEWAY_RSP								(MSG_ID_FWK_ONVIF_START_BASE+145)
+#define MSG_ID_FWK_ONVIF_SET_GATEWAY_REQ								(MSG_ID_FWK_ONVIF_START_BASE+146)
+#define MSG_ID_FWK_ONVIF_SET_GATEWAY_RSP								(MSG_ID_FWK_ONVIF_START_BASE+147)
+
+
+
+
+
+
+
+
+
+
+
+#endif
diff --git a/noui/libvui/fwk_mem.cpp b/noui/libvui/fwk_mem.cpp
new file mode 100644
index 0000000..ea2c09f
--- /dev/null
+++ b/noui/libvui/fwk_mem.cpp
@@ -0,0 +1,122 @@
+/*   ----------------------------------------------------------------------
+Copyright (C) 2014-2016 Fuzhou Rockchip Electronics Co., Ltd
+
+     Sec Class: Rockchip Confidential
+
+V1.0 Dayao Ji <jdy@rock-chips.com>
+---------------------------------------------------------------------- */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include "fwk_gl_def.h"
+#include "fwk_gl_api.h"
+
+
+
+
+#define ASSERT(__X__, RET_VAL, _FILE_, _LINE_)	do{\
+							if((__X__))\
+							{\
+								printf("\n\nFATAL ERROR:%s:%s at %s:%d\n\n",__FUNCTION__, #__X__, (_FILE_),  (_LINE_));\
+								return (RET_VAL);\
+							}\
+						}while(0);
+
+#define ASSERT0(__X__, _FILE_, _LINE_)	do{\
+							if((__X__))\
+							{\
+								printf("\n\nFATAL ERROR:%s:%s at %s:%d\n\n",__FUNCTION__, #__X__, (_FILE_),  (_LINE_));\
+							}\
+						}while(0);
+
+
+
+void* FWK_Malloc(int size, const char *file, int line)
+{
+	void* pMem;
+
+	ASSERT((size < 0), NULL, file, line);
+
+	pMem = malloc(size);
+	if(pMem == NULL)
+	{
+		printf("fwk_msg  NO MEMORY!!!!!! file=%s, line=%d\n\n", file, line);
+		ASSERT(1, NULL, file, line);
+	}
+	return pMem;
+}
+
+
+
+
+
+void FWK_Free(const char *file, int line, void * mem)
+{
+	if(mem == NULL)
+	{
+		printf("fwk_msg Free NULL memory!!!!!! file=%s, line=%d\n\n", file, line);
+		ASSERT0(1, file, line);
+		return;
+	}
+
+	free(mem);
+
+	return;
+}
+
+
+
+void *_FWK_MEMCPY (void * _DEST_PTR, int _DEST_LEN, void *  _SRC_PTR, int _SRC_LEN, int _SIZE, const char *file, int line)
+{
+	ASSERT((_DEST_PTR == NULL || _SRC_PTR == NULL), NULL, file, line);
+	ASSERT((_DEST_LEN < _SIZE || _SRC_LEN < _SIZE), NULL, file, line);
+	return memcpy(_DEST_PTR, _SRC_PTR, _SIZE);
+}
+
+void *_FWK_MEMSET(void *_DEST_PTR, int _VAL, int _SIZE, const char *file, int line)
+{
+	ASSERT((_DEST_PTR == NULL), NULL, file, line);
+	return memset(_DEST_PTR, _VAL, _SIZE);
+}
+
+char * _FWK_STRNCPY (char * _DEST_PTR, int  _DEST_LEN, const char *_SRC_PTR, int _SIZE, const char *file, int line)
+{
+	ASSERT((_DEST_PTR == NULL || _SRC_PTR == NULL), NULL, file, line);
+	ASSERT((_DEST_LEN < _SIZE), NULL, file, line);
+	FWK_MEMSET(_DEST_PTR, 0, _DEST_LEN);
+	return strncpy(_DEST_PTR, _SRC_PTR, _SIZE);
+}
+#define MAX_SPRINTF_BUFFER_SIZE   (8*1024)
+int _FWK_SPRINTF (char * _DEST_PTR, int  _DEST_LEN, const char *file, int line, const char *_FMT, ...)
+{
+	int size;
+	char *buffer = NULL;
+	va_list ap;
+
+	buffer = (char*)FWK_MALLOC(MAX_SPRINTF_BUFFER_SIZE);
+	if (buffer == NULL)
+		return -1;
+	FWK_MEMSET(buffer, 0, MAX_SPRINTF_BUFFER_SIZE);
+	va_start(ap, _FMT);
+	size = vsnprintf(buffer, MAX_SPRINTF_BUFFER_SIZE, _FMT, ap);
+	va_end(ap);
+	ASSERT((_DEST_PTR == NULL || _DEST_LEN < FWK_STRLEN(buffer)), -1, file, line);
+	FWK_MEMSET(_DEST_PTR, 0, _DEST_LEN);
+	FWK_STRNCPY(_DEST_PTR, _DEST_LEN, buffer, FWK_STRLEN(buffer));
+	FWK_FREE(buffer);
+	return size;
+}
+
+char *_FWK_STRCAT(char *_DEST_PTR, int  _DEST_LEN, const char *_SRC_PTR, const char *file, int line)
+{
+	ASSERT((_DEST_PTR == NULL || _SRC_PTR == NULL || _DEST_LEN <= FWK_STRLEN((char*)_SRC_PTR)), NULL, file, line);
+	return strcat(_DEST_PTR, _SRC_PTR);
+}
+int _FWK_STRLEN (char *_STR_PTR, const char *file, int line)
+{
+	ASSERT0((_STR_PTR == NULL), file, line);
+	return strlen(_STR_PTR);
+}
diff --git a/noui/libvui/fwk_msg.cpp b/noui/libvui/fwk_msg.cpp
new file mode 100644
index 0000000..ae7bdd1
--- /dev/null
+++ b/noui/libvui/fwk_msg.cpp
@@ -0,0 +1,266 @@
+/*   ----------------------------------------------------------------------
+Copyright (C) 2014-2016 Fuzhou Rockchip Electronics Co., Ltd
+
+     Sec Class: Rockchip Confidential
+
+V1.0 Dayao Ji <jdy@rock-chips.com>
+---------------------------------------------------------------------- */
+
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <errno.h>
+#include <pthread.h>
+#include <ctype.h>
+#include <asm/unistd.h>
+#include <stddef.h>
+#include <signal.h>
+#include <sys/wait.h>
+#include <sys/select.h>
+#include <sys/socket.h>
+#include <sys/types.h>
+#include <sys/ipc.h>
+#include <sys/msg.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/signal.h>
+//#include <linux/types.h>
+//#include <linux/ipc.h>
+//#include <linux/msg.h>
+
+#include <sys/syscall.h>
+//#include <linux/unistd.h>
+//#include <asm/unistd_32.h>
+
+#include "fwk_gl_msg.h"
+#include "fwk_gl_api.h"
+
+#define MAX_QUEQUE_NUM	100
+
+#define MAX_BUF_SIZE 8000 //4096
+typedef struct{
+	long mtype;
+	char text[MAX_BUF_SIZE];
+}SYS_MSG;
+
+static int fwk_quelist[MAX_QUEQUE_NUM];
+
+#if 0
+
+int msgget(key_t key, int msgflag)
+{
+	return syscall(__NR_ipc, 13,key, msgflag);
+}
+
+int msgsnd(int msqid, const void* msgp, size_t msgsz, int msgflag)
+{
+	return syscall(__NR_ipc, 11, msqid, msgsz, msgflag, (void*)msgp, (long)NULL);
+}
+
+ssize_t msgrcv(int msqid, void* msgp, size_t msgsz, long msgtyp, int msgflg)
+{
+	struct ipc_kludge tmp;
+
+
+   tmp.msgp = (struct msgbuf *) msgp;
+   tmp.msgtyp = msgtyp;
+	return syscall(__NR_ipc, 12, msqid, msgsz, msgflg, &tmp, (long)NULL);
+}
+
+int msgctl(int msqid, int cmd, struct msqid_ds* buf)
+{
+	return syscall(__NR_ipc, 14, msqid, cmd, 0, buf, (long)NULL);
+}
+#endif
+
+void fwk_remove_queue(void)
+{
+	int i;
+	for(i=0; i<MAX_QUEQUE_NUM; i++)
+	{
+		msgctl(fwk_quelist[i], IPC_RMID, NULL);
+		fwk_quelist[i] = -1;
+	}
+}
+
+int fwk_create_queue(int mod_id)
+{
+	int key = mod_id;
+	int queque;
+
+	queque = msgget(key, IPC_CREAT|0666);
+	if(queque != -1) {
+		if (mod_id < FWK_MOD_NUM)
+			fwk_quelist[mod_id]	= queque;
+	} else {
+		perror("fwk_create_queue msgget");
+	}
+	return queque;
+}
+
+static int fwk_get_queueid(int key)
+{
+	int queue;
+
+	if (key < FWK_MOD_NUM)
+	{
+		return fwk_quelist[key];
+	}
+
+	queue = msgget(key, IPC_CREAT|0666);
+	if(queue == -1)
+	{
+		perror("fwk_create_queue msgget");
+	}
+
+	//printf("fwk_create_queue key %d, queue %d\n", key, queue);
+
+	return queue;
+}
+
+void dump_msg(SYS_MSG *sys_msg)
+{
+    int i;
+    FWK_MSG *pmsg = (FWK_MSG *)sys_msg->text;
+
+    printf("+++++dump msg start+++++\n");
+    printf("sys_msg: type %d\n", sys_msg->mtype);
+    printf("fwk_msg:size = %d\n", pmsg->size);
+    printf("fwk_msg:source = %d\n", pmsg->source);
+    printf("fwk_msg:msg_id = %d\n", pmsg->msg_id);
+    printf("fwk_msg:dest = %d\n", pmsg->dest);
+    printf("fwk_msg:data[0] = %x\n", pmsg->para[0]);
+    printf("+++++dump msg end+++++\n");
+}
+static int fwk_send_message(SYS_MSG *SysMsg, int length)
+{
+	int queque, ret;
+	FWK_MSG *msg = (FWK_MSG *)SysMsg->text;
+
+	queque = fwk_get_queueid(msg->dest);
+
+	//printf("fwk_send_message, dest queue id %d\n",queque);
+
+	if (queque == -1)
+	{
+		return -1;
+	}
+
+	SysMsg->mtype = 1;
+
+	if (length > MAX_BUF_SIZE) {
+		printf("error, fwk_send_message msg too long %d > limit %d, trim to limit\n", length, MAX_BUF_SIZE);
+		length = MAX_BUF_SIZE;
+	}
+
+	ret = msgsnd(queque, SysMsg, length - sizeof(long), IPC_NOWAIT);
+	if(ret)
+	{
+		fwk_debug("%s\n", strerror(errno));
+		perror("fwk_send_message\n");
+		dump_msg(SysMsg);
+	}
+	return ret;
+}
+
+
+
+int fwk_send_message_ext(int sour, int dest,int msg_id, void *data, int size)
+{
+	int ret;
+	int length = sizeof(FWK_MSG) + size + sizeof(long);
+	SYS_MSG *SysMsg = (SYS_MSG *)FWK_MALLOC(sizeof(FWK_MSG) + size + sizeof(long));
+	FWK_MSG *pmsg = (FWK_MSG *)SysMsg->text;
+
+	if (SysMsg == NULL)
+	{
+		printf("fwk_msg malloc error \n");
+		return -1;
+	}
+
+	//printf("fwk_send_message_ext, %d,%d,%d,size %d\n",sour,dest,msg_id,size);
+
+	pmsg->source = sour;
+	pmsg->dest = dest;
+	pmsg->msg_id = msg_id;
+	pmsg->size = size;
+	if (!(size == 0 || data == NULL))
+	{
+		FWK_MEMCPY(pmsg->para, size, data, size, size);
+	}
+
+	ret = fwk_send_message(SysMsg, length);
+
+	FWK_FREE(SysMsg);
+	return ret;
+}
+
+FWK_MSG* fwk_get_message(int queque, int msgflg, int * result)
+{
+
+	SYS_MSG *sys_msg = (SYS_MSG *)FWK_MALLOC(sizeof(SYS_MSG));
+	int ret;
+
+	FWK_MEMSET(sys_msg, 0, sizeof(SYS_MSG));
+	ret = msgrcv(queque, sys_msg, sizeof(SYS_MSG), 0,  msgflg);
+	if(ret == -1) {
+		*result = ret;
+		perror("fwk_get_message ");
+		FWK_FREE(sys_msg);
+		return NULL;
+	}
+	*result = ret;
+	return (FWK_MSG*)sys_msg->text;
+}
+
+FWK_MSG* fwk_get_message_timeout(int queque, int timeout_ms, int * result)
+{
+
+	SYS_MSG *sys_msg = (SYS_MSG *)FWK_MALLOC(sizeof(SYS_MSG));
+	int ret;
+
+	FWK_MEMSET(sys_msg, 0, sizeof(SYS_MSG));
+
+	while (timeout_ms > 0) {
+		ret = msgrcv(queque, sys_msg, sizeof(SYS_MSG), 0,  IPC_NOWAIT);
+
+		if(ret > 0) {
+			break;
+		}
+		timeout_ms -= 1;
+		usleep(1000);
+	}
+	*result = ret;
+
+	return (FWK_MSG*)sys_msg->text;
+}
+
+int fwk_free_message(FWK_MSG **msg)
+{
+	SYS_MSG *sys_msg;
+
+	if(*msg == NULL)
+		return -1;
+
+	sys_msg = (SYS_MSG *)(int(*msg) - sizeof(long));
+
+	FWK_FREE(sys_msg);
+	*msg = NULL;
+	return 0;
+}
+
+int fwk_msg_init(void)
+{
+	int i;
+	for(i=0; i<MAX_QUEQUE_NUM; i++)
+	{
+		fwk_quelist[i] = -1;
+	}
+	return 0;
+}
+
+
diff --git a/noui/libvui/msg_api.c b/noui/libvui/msg_api.c
new file mode 100644
index 0000000..561ff02
--- /dev/null
+++ b/noui/libvui/msg_api.c
@@ -0,0 +1,119 @@
+#include <stdbool.h>
+#include "fwk_gl_api.h"
+#include "fwk_gl_def.h"
+#include "fwk_gl_msg.h"
+#define VM 3 /* must */
+#define VE 2 /* error */
+#define VI 1 /* info */
+#define VUIDBGMSG( c, x ) c > 0? printf x : 0
+
+#ifndef BOOL
+typedef int BOOL;
+#define TRUE  1
+#define FALSE 0
+#endif
+void *get_proc(void);
+typedef int (*pfn_mainproc)(HWND, int, WPARAM, LPARAM);
+static int fwk_video_queue;
+static int fwk_wifi_queue;
+static int create_message_queue(void)
+{
+
+    fwk_video_queue = fwk_create_queue(FWK_MOD_VIDEO);
+    if (fwk_video_queue == -1) {
+        VUIDBGMSG(VE, ("fwk_msg unable to create queue for main \n"));
+        return -1;
+    }
+    VUIDBGMSG(VI, ("create_message_queue, fwk_video_queue  id %d\n",fwk_video_queue));
+#if 0
+    fwk_wifi_queue = fwk_create_queue(FWK_MOD_WIFI);
+    if (fwk_wifi_queue == -1)
+    {
+        printf("fwk_msg unable to create queue for wifi \n");
+        return -1;
+    }
+    printf("create_message_queue, fwk_wifi_queue  id %d\n",fwk_wifi_queue);
+#endif
+    return 0;
+}
+
+int vui_init_msg()
+{
+	return create_message_queue();
+}
+
+typedef struct _MSG
+{
+    HWND             hwnd;
+    int              message;
+    WPARAM           wParam;
+    LPARAM           lParam;
+    unsigned int     time;
+	void *priv;
+} MSG;
+typedef MSG* PMSG;
+
+int PostMessage(int hWnd, int iMsg, WPARAM wParam, LPARAM lParam)
+{
+  int ret;
+  MSG msg;
+
+  memset(&msg, 0, sizeof(msg));
+  msg.message = iMsg;
+  msg.wParam = wParam;
+  msg.lParam = lParam;
+  ret = fwk_send_message_ext(FWK_MOD_VIDEO, FWK_MOD_VIDEO, FWK_MSG_COMMON_IPC_MSG, &msg, sizeof(msg));
+  if (ret < 0)
+    VUIDBGMSG(VI, ("PostMessage %d failed\n", iMsg));
+  return ret;
+}
+
+static BOOL PeekMessageEx (PMSG pMsg, HWND hWnd,  int iMsgFilterMin, int iMsgFilterMax,  BOOL bWait, UINT uRemoveMsg)
+{
+	FWK_MSG *msg = NULL;
+	int ret = -1;
+	PMSG ipc_req;
+
+	if(!pMsg)
+		return -1;
+	while (1) {
+		msg = fwk_get_message(fwk_video_queue, MSG_GET_WAIT_ROREVER, &ret);
+		if ((ret < 0) ||(msg == NULL)) {
+	    	VUIDBGMSG(VI, ("get message NULL\n"));
+	    	continue;
+	    }
+		ipc_req = (PMSG )msg->para;
+		ipc_req->priv = msg;
+		*pMsg = *ipc_req;
+		break;
+	}
+	return 0;
+}
+
+bool GetMessage (PMSG pMsg, HWND hWnd)
+{
+	return PeekMessageEx (pMsg, hWnd, 0, 0, 0, 0);
+}
+
+int DispatchMessage (PMSG pMsg)
+{
+	FWK_MSG *msg = NULL;
+	pfn_mainproc pfun;
+	if(!pMsg) {
+		VUIDBGMSG(VI, ("pMsg 0x%08X\n", pMsg));
+		return -1;
+	}
+	msg = (FWK_MSG *)pMsg->priv;
+	pfun = (pfn_mainproc)get_proc();
+	if(pfun) {
+		pfun(pMsg->hwnd, pMsg->message, pMsg->wParam, pMsg->lParam);
+	}
+	fwk_free_message(&msg);
+	return 0;
+}
+bool TranslateMessage (PMSG pMsg)
+{
+	return 0;
+}
+
+
diff --git a/noui/libvui/vgui_api.c b/noui/libvui/vgui_api.c
new file mode 100644
index 0000000..e0e45f6
--- /dev/null
+++ b/noui/libvui/vgui_api.c
@@ -0,0 +1,108 @@
+#include "vgui_api.h"
+#include <signal.h>
+#include <time.h>
+#include <memory.h>
+static PMAINWINCREATE g_pMainWindow;
+HWND CreateMainWindow (PMAINWINCREATE pCreateInfo)
+{
+	DBGMSG(NI, ("CreateMainWindow\n"));
+	g_pMainWindow = pCreateInfo;
+	PostMessage((int)g_pMainWindow, MSG_CREATE, 0, 0);
+    return (HWND)pCreateInfo;
+}
+
+int RegisterMainWindow (HWND hWnd)
+{
+	DBGMSG(NI, ("RegisterMainWindow 0x%08X\n", hWnd));
+	return 0;
+}
+
+int vgui_init()
+{
+	DBGMSG(NI, ("%s\n", __func__));
+	vui_init_msg();
+	return 0;
+}
+
+void vgui_deinit()
+{
+	DBGMSG(NI, ("%s\n", __func__));
+}
+
+void *get_proc(void)
+{
+    if(g_pMainWindow)
+		return g_pMainWindow->MainWindowProc;
+}
+
+static void my_alarm_handler(union sigval v)
+{
+	int timerid = v.sival_int;
+	PostMessage((int)g_pMainWindow, MSG_TIMER, 0, 0);
+}
+
+typedef struct _TIMER_
+{
+	int inited;
+	TIMERPROC pfn;
+	timer_t timer;
+} TIMER;
+static TIMER g_timer[10] = {0};
+
+bool SetTimerEx(HWND hWnd, int id, unsigned int speed, TIMERPROC timer_proc)
+{
+	struct sigevent evp;
+	struct itimerspec ts;
+	int ret;
+	TIMER *timer;
+
+	if(id >= sizeof(g_timer)/sizeof(g_timer[0]))
+		return -1;
+	timer = &g_timer[id];
+	timer->pfn = timer_proc;
+
+	memset(&evp, 0, sizeof(struct sigevent));
+	evp.sigev_value.sival_int = id;
+	evp.sigev_notify = SIGEV_THREAD;
+	evp.sigev_notify_function = my_alarm_handler;
+
+	ret = timer_create(CLOCK_REALTIME, &evp, &timer->timer);
+	if (ret) {
+		DBGMSG(NI, ("timer_create error\n"));
+	}
+	ts.it_interval.tv_sec = speed/1000;
+	ts.it_interval.tv_nsec = (speed%1000)*1000*1000;
+	ts.it_value.tv_sec = speed/1000;
+	ts.it_value.tv_nsec = (speed%1000)*1000*1000;
+
+	ret = timer_settime(timer->timer, 0, &ts, NULL);
+	if (ret) {
+		DBGMSG(NI, ("timer_settime error\n"));
+	}
+	timer->inited = 1;
+	return 0;
+}
+
+int KillTimer (HWND hWnd, int id)
+{
+	TIMER *timer;
+
+	if(id >= sizeof(g_timer)/sizeof(g_timer[0]))
+		return -1;
+	timer = &g_timer[id];
+	timer_delete(timer->timer);
+	timer->inited = 0;
+	return 0;
+}
+
+int idummy()
+{
+	DBGMSG(NI, ("idummy\n"));
+	return 0;
+}
+
+int vdummy()
+{
+	DBGMSG(NI, ("vdummy\n"));
+	return 0;
+}
\ No newline at end of file
diff --git a/noui/libvui/vgui_api.h b/noui/libvui/vgui_api.h
new file mode 100644
index 0000000..ea492cd
--- /dev/null
+++ b/noui/libvui/vgui_api.h
@@ -0,0 +1,537 @@
+#ifndef _VGUI_API_H_
+#define _VGUI_API_H_
+#include <stdlib.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+
+#define NM 3 /* must */
+#define NE 2 /* error */
+#define NI 1 /* info */
+#define DBGMSG( c, x ) c > 0? printf x : 0
+
+typedef unsigned int HMENU;
+typedef unsigned int HWND;
+typedef unsigned int HDC;
+typedef unsigned int DWORD;
+typedef unsigned int WPARAM;
+typedef unsigned long LPARAM;
+typedef unsigned char Uint8;
+typedef unsigned int Uint32;
+typedef unsigned int HICON;
+
+typedef struct _RECT_ {
+  unsigned short xmin;
+  /* width - 1 */
+  unsigned short xmax;
+  unsigned short ymin;
+  /* height - 1 */
+  unsigned short ymax;
+} RECT;
+
+struct _BITMAP
+{
+    Uint8   bmType;
+    Uint8   bmBitsPerPixel;
+    Uint8   bmBytesPerPixel;
+    Uint8   bmAlpha;
+    Uint32  bmColorKey;
+    Uint32  bmColorRep;
+    Uint32  bmWidth;
+    Uint32  bmHeight;
+    Uint32  bmPitch;
+    Uint8*  bmBits;
+    Uint8*  bmAlphaMask;
+    Uint32  bmAlphaPitch;
+};
+typedef struct _BITMAP BITMAP;
+typedef BITMAP* PBITMAP;
+
+typedef struct _WINDOW_ELEMENT_ATTR {
+    int we_attr_id;
+    DWORD we_attr;
+} WINDOW_ELEMENT_ATTR;
+
+typedef struct _CTRLDATA
+{
+    const char* class_name;             
+    DWORD       dwStyle;                
+    int         x, y, w, h;             
+    int         id;                     
+    const char* caption;                
+    DWORD       dwAddData;              
+	DWORD       dwExStyle;              
+    const char* werdr_name;
+    const WINDOW_ELEMENT_ATTR* we_attrs;
+} CTRLDATA;
+typedef CTRLDATA* PCTRLDATA;
+
+typedef struct _DLGTEMPLATE
+{
+    DWORD       dwStyle;                
+    DWORD       dwExStyle;              
+    int         x, y, w, h;             
+    const char* caption;                
+    HICON       hIcon;                  
+    HMENU       hMenu;                  
+    int         controlnr;              
+    PCTRLDATA   controls;               
+    DWORD       dwAddData;              
+} DLGTEMPLATE;
+typedef DLGTEMPLATE* PDLGTEMPLATE;
+
+
+
+typedef struct _MSG
+{
+    HWND             hwnd;
+    int              message;
+    WPARAM           wParam;
+    LPARAM           lParam;
+    unsigned int     time;
+	void *priv;
+} MSG;
+typedef MSG* PMSG;
+
+
+
+
+int idummy(void);
+int vdummy(void);
+int vgui_init();
+void vgui_deinit();
+
+#define MiniGUIMain \
+MiniGUIAppMain (int args, const char* argv[]); \
+int main (int args, const char* argv[]) \
+{ \
+	int iRet = 0;\
+	DBGMSG(NI, ("lib vgui running...\n"));\
+	if(vgui_init()) {\
+		DBGMSG(NI, ("vgui_init fail!\n"));\
+		return -1;\
+	}\
+    iRet = MiniGUIAppMain (args, argv); \
+    DBGMSG(NI, ("lib vgui exit...\n"));\
+ 	vgui_deinit();\
+    return iRet;\
+} \
+int MiniGUIAppMain
+
+typedef struct _MAINWINCREATE
+{
+    int dwStyle;
+    int dwExStyle;
+    const char* spCaption;
+    int hMenu;
+    int hCursor;
+    int hIcon;
+    int  hHosting;
+    int (*MainWindowProc)(HWND, int, WPARAM, LPARAM);
+    int lx, ty, rx, by;
+    int iBkColor;
+    int dwAddData;
+    int dwReserved;
+	int language;
+}MAINWINCREATE;
+typedef MAINWINCREATE* PMAINWINCREATE;
+#define HWND_INVALID        0xFFFFFFFF
+#define HWND_DESKTOP        0
+
+
+
+HWND CreateMainWindow (PMAINWINCREATE pCreateInfo);
+int RegisterMainWindow (HWND hWnd);
+
+#define InvalidateRect(x, y, z) printf("InvalidateRect\n")
+#define SetSystemLanguage(x, y) printf("SetSystemLanguage\n")
+#define DestroyAllControls(x) printf("DestroyAllControls\n")
+#define DestroyMainWindow(x) printf("DestroyMainWindow\n")
+#define UnregisterMainWindow(x) printf("UnregisterMainWindow\n")
+#define MainWindowThreadCleanup(x) printf("MainWindowThreadCleanup\n")
+#define BeginPaint(x) printf("BeginPaint\n"),1
+#define FillBoxWithBitmap(hdc, x, y, w, h, bmp) printf("FillBoxWithBitmap\n")
+#define EndPaint(x, y) printf("EndPaint %d %d\n", x, y)
+#define SendDlgItemMessage(x, y, z, x1, x2) printf("SendDlgItemMessage\n")
+#define GetNextDlgTabItem(hDlg, hCurFocus, FALSE) printf("GetNextDlgTabItem\n")
+#define SetNullFocus(x) printf("hCurFocus %d\n", x)
+#define SetFocus(x) printf("SetFocus %d\n", x)
+#define GetFocusChild(x) printf("GetFocusChild %d\n", x),1
+#define DefaultDialogProc(a, b, c, d) printf("DefaultDialogProc\n")
+#define EndDialog(x, y) printf("EndDialog %d %d\n", x, y)
+#define GetDlgDefPushButton(x) printf("GetDlgDefPushButton %d\n", x)
+#define MessageBox(a, b, c, d) printf("MessageBox %s %s\n", b, c)
+#define PostQuitMessage(x) printf("PostQuitMessage\n")
+
+		
+#define SetBkColor(x, y) printf("SetBkColor\n")
+#define TextOut(hdc, x, y, text) printf("TextOut\n")
+
+#define unloadres idummy
+#define loadres(x) printf("loadres\n")
+
+/* message */
+#define MSG_CREATE          0x0060
+#define MSG_USER            0x0800
+#define MSG_COMMAND         0x0120
+
+#define SCANCODE_ESCAPE                 1
+#define SCANCODE_ENTER                  28
+#define SCANCODE_MENU                   127
+
+
+
+#define MSG_SDCHANGE (MSG_USER + 1)
+#define MSG_BATTERY (MSG_USER + 2)
+#define MSG_CAMERA (MSG_USER + 3)
+#define MSG_VIDEOREC (MSG_USER + 4)
+#define MSG_VIDEOPLAY (MSG_USER + 5)
+#define MSG_SDCARDFORMAT (MSG_USER + 6)
+#define MSG_USBCHAGE (MSG_USER + 7)
+#define MSG_FILTER (MSG_USER + 8)
+#define MSG_SDMOUNTFAIL (MSG_USER + 9)
+#define MSG_SDNOTFIT (MSG_USER + 10)
+#define MSG_ADAS (MSG_USER + 11)
+#define MSG_PHOTOEND (MSG_USER + 13)
+#define MSG_REPAIR (MSG_USER + 14)
+#define MSG_FSINITFAIL (MSG_USER + 15)
+#define MSG_HDMI (MSG_USER + 16)
+#define MSG_CVBSOUT (MSG_USER + 17)
+#define MSG_USB_DISCONNECT (MSG_USER + 18)
+#define MSG_RK_USER (MSG_USER + 30)
+#define MSG_ATTACH_USER_MUXER (MSG_RK_USER + 0)
+#define MSG_DETACH_USER_MUXER (MSG_RK_USER + 1)
+#define MSG_ATTACH_USER_MDPROCESSOR (MSG_RK_USER + 2)
+#define MSG_DETACH_USER_MDPROCESSOR (MSG_RK_USER + 3)
+#define MSG_RECORD_RATE_CHANGE (MSG_RK_USER + 4)
+#define MSG_COLLISION (MSG_RK_USER + 5)
+
+
+
+//DEBUG
+#define REBOOT_TIME 10
+#define RECOVERY_TIME 5
+#define AWAKE_TIME 5
+#define STANDBY_TIME 5
+#define MODECHANGE_TIME 5
+#define VIDEO_TIME 2
+#define BEG_END_VIDEO_TIME 5
+#define PHOTO_TIME 5
+#define FWUPDATE_TEST_TIME 5
+
+//
+#define EVENT_VIDEOREC_UPDATETIME 1
+
+#define EVENT_VIDEOPLAY_UPDATETIME 1
+#define EVENT_VIDEOPLAY_EXIT 2
+
+#define EVENT_SDCARDFORMAT_FAIL 0
+#define EVENT_SDCARDFORMAT_FINISH 1
+
+#define IDM_NEW 1
+#define IDM_SAVE 3
+#define IDM_SAVEAS 4
+#define IDM_EXIT 5
+
+#define IDL_DIR 106
+#define IDL_FILE 110
+#define IDC_PATH 120
+#define IDC_LISTVIEW 121
+
+#define IDM_ABOUT_MP 103
+#define IDM_ABOUT_TIME 104
+#define IDM_ABOUT_CAR 105
+#define IDM_ABOUT_SETTING 106
+#define IDM_QUIT 107
+#define IDM_ABOUT_LINE1 108
+#define IDM_ABOUT_LINE2 109
+#define IDM_ABOUT_LINE3 110
+#define IDM_ABOUT_LINE4 111
+#define IDM_720P 112
+#define IDM_1080P 113
+#define IDM_1MIN 114
+#define IDM_3MIN 115
+#define IDM_5MIN 116
+#define IDM_OFF 117
+#define IDM_CAR1 118
+#define IDM_CAR2 119
+#define IDM_CAR3 120
+#define IDM_bright 121
+#define IDM_exposal 122
+#define IDM_detect 123
+#define IDM_mark 124
+#define IDM_record 125
+
+#define IDM_bright1 126
+#define IDM_bright2 127
+#define IDM_bright3 128
+#define IDM_bright4 129
+#define IDM_bright5 130
+
+#define IDM_exposal1 131
+#define IDM_exposal2 132
+#define IDM_exposal3 133
+#define IDM_exposal4 134
+#define IDM_exposal5 135
+
+#define IDM_detectOFF 136
+#define IDM_detectON 137
+
+#define IDM_markOFF 138
+#define IDM_markON 139
+
+#define IDM_recordOFF 140
+#define IDM_recordON 141
+
+#define IDM_ABOUT_AUTORECORD 142
+#define IDM_ABOUT_LANGUAGE 143
+#define IDM_ABOUT_FREQUENCY 144
+#define IDM_ABOUT_AVIN 145
+#define IDM_ABOUT_AUTOOFF 146
+#define IDM_ABOUT_SAVERR 147
+#define IDM_ABOUT_GSENSOR 148
+#define IDM_ABOUT_PARKING 149
+#define IDM_ABOUT_DATE_SET 150
+#define IDM_ABOUT_FORMAT 151
+#define IDM_ABOUT_DEF_SET 152
+#define IDM_ABOUT_VERSION 153
+
+#define IDM_autorecordOFF 154
+#define IDM_autorecordON 155
+
+#define IDM_langEN 156
+#define IDM_langCN 157
+
+#define IDM_50HZ 158
+#define IDM_60HZ 159
+#define IDM_MODE 160
+#define IDM_VEDIO 163
+#define IDM_PLAY 162
+#define IDM_CAMERA 161
+
+#define IDM_1M 164
+#define IDM_2M 165
+#define IDM_3M 166
+
+#define IDM_DELETE 167
+#define IDM_YES_DELETE 168
+#define IDM_NO_DELETE 169
+
+#define IDM_FILE 170
+
+#define IDM_FORMAT 171
+#define IDM_SETDATE 172
+#define IDC_BOX4 173
+#define IDC_HOUR 174
+#define IDC_MINUTE 175
+#define IDC_SECOND 176
+#define IDL_DAXIA 177
+#define IDL_YEAR 178
+#define IDL_MONTH 179
+#define IDL_DAY 180
+#define IDL_SEC 181
+
+#define IDC_PROMPT 182
+
+#define IDUSB 183
+#define USBBAT 184
+
+#define IDM_3DNR 185
+#define IDM_3DNROFF 186
+#define IDM_3DNRON 187
+
+#define IDM_ADAS 188
+#define IDM_ADAS_OFF 189
+#define IDM_ADAS_ON 190
+#define IDM_ADAS_SETTING 191
+
+#define IDM_BACKLIGHT 192
+#define IDM_BACKLIGHT_L 193
+#define IDM_BACKLIGHT_M 194
+#define IDM_BACKLIGHT_H 195
+
+#define IDC_SETMODE 196
+#define IDM_USB 197
+#define IDM_ADB 198
+#define IDM_FWVER 199
+#define IDM_RECOVERY 200
+
+#define IDM_1M_ph 201
+#define IDM_2M_ph 202
+#define IDM_3M_ph 203
+#define IDM_ABOUT_DEBUG 204
+
+#define IDM_BOOT_OFF 205
+#define IDM_RECOVERY_OFF 206
+#define IDM_AWAKE_1_OFF 207
+#define IDM_STANDBY_2_OFF 208
+#define IDM_MODE_CHANGE_OFF 209
+#define IDM_DEBUG_VIDEO_OFF 210
+#define IDM_BEG_END_VIDEO_OFF 211
+#define IDM_DEBUG_PHOTO_OFF 212
+
+#define IDM_BOOT_ON 213
+#define IDM_RECOVERY_ON 214
+#define IDM_AWAKE_1_ON 215
+#define IDM_STANDBY_2_ON 216
+#define IDM_MODE_CHANGE_ON 217
+#define IDM_DEBUG_VIDEO_ON 218
+#define IDM_BEG_END_VIDEO_ON 219
+#define IDM_DEBUG_PHOTO_ON 220
+
+#define IDM_BOOT 221
+#define IDM_RECOVERY_DEBUG 222
+#define IDM_AWAKE_1 223
+#define IDM_STANDBY_2 224
+#define IDM_MODE_CHANGE 225
+#define IDM_DEBUG_VIDEO 226
+#define IDM_BEG_END_VIDEO 227
+#define IDM_DEBUG_PHOTO 228
+
+#define IDM_FONTCAMERA 229
+#define IDM_BACKCAMERA 230
+#define IDM_FONT_1 231
+#define IDM_FONT_2 232
+#define IDM_FONT_3 233
+#define IDM_FONT_4 234
+#define IDM_BACK_1 235
+#define IDM_BACK_2 236
+#define IDM_BACK_3 237
+#define IDM_BACK_4 238
+
+#define IDM_COLLISION 239
+#define IDM_COLLISION_NO 240
+#define IDM_COLLISION_L 241
+#define IDM_COLLISION_M 242
+#define IDM_COLLISION_H 243
+#define IDM_PARKINGMONITOR 244
+#define IDM_PARKINGMONITOR_SHUTDOWN_MODE 245
+#define IDM_PARKINGMONITOR_OFF 246
+#define IDM_AUTOOFFSCREEN 247
+#define IDM_AUTOOFFSCREENOFF 248
+#define IDM_AUTOOFFSCREENON 249
+#define IDM_VIDEO_QUALITY 250
+#define IDM_VIDEO_QUALITY_H 251
+#define IDM_VIDEO_QUALITY_M 252
+#define IDM_VIDEO_QUALITY_L 253
+#define IDM_PARKINGMONITOR_SUSPEND_MODE 254
+#define IDM_MOTION_DETECT 255
+#define IDM_TIME_LAPSE_RECORD 256
+#define IDM_LICENSEPLATE_WATERMARK 260
+#define IDM_DEBUG_VIDEO_BIT_RATE 280
+
+#define IDM_DEBUG_VIDEO_BIT_RATE1 (IDM_DEBUG_VIDEO_BIT_RATE + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE2 (IDM_DEBUG_VIDEO_BIT_RATE1 + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE4 (IDM_DEBUG_VIDEO_BIT_RATE2 + 2)
+#define IDM_DEBUG_VIDEO_BIT_RATE5 (IDM_DEBUG_VIDEO_BIT_RATE4 + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE6 (IDM_DEBUG_VIDEO_BIT_RATE5 + 1)
+#define IDM_DEBUG_VIDEO_BIT_RATE8 (IDM_DEBUG_VIDEO_BIT_RATE6 + 2)
+#define IDM_DEBUG_VIDEO_BIT_RATE_MAX IDM_DEBUG_VIDEO_BIT_RATE8
+#define IDM_WIFI (IDM_DEBUG_VIDEO_BIT_RATE_MAX + 1)
+#define IDM_WIFION (IDM_WIFI + 1)
+#define IDM_WIFIOFF (IDM_WIFION + 1)
+
+#define IDM_DEBUG_TEMP (IDM_WIFIOFF + 1)
+#define IDM_DEBUG_TEMP_ON (IDM_DEBUG_TEMP + 1)
+#define IDM_DEBUG_TEMP_OFF (IDM_DEBUG_TEMP_ON + 1)
+
+#define IDM_IDC     (IDM_DEBUG_TEMP_OFF + 1)
+#define IDM_IDCOFF  (IDM_IDC + 1)
+#define IDM_IDCON   (IDM_IDCOFF + 1)
+
+#define IDM_timelapse               (IDM_IDCON + 1)
+#define IDM_TIME_LAPSE_OFF          (IDM_timelapse + 1)
+#define IDM_TIME_LAPSE_INTERNAL_1s  (IDM_TIME_LAPSE_OFF + 1)
+#define IDM_TIME_LAPSE_INTERNAL_5s  (IDM_TIME_LAPSE_INTERNAL_1s + 1)
+#define IDM_TIME_LAPSE_INTERNAL_10s (IDM_TIME_LAPSE_INTERNAL_5s + 1)
+#define IDM_TIME_LAPSE_INTERNAL_30s (IDM_TIME_LAPSE_INTERNAL_10s + 1)
+#define IDM_TIME_LAPSE_INTERNAL_60s (IDM_TIME_LAPSE_INTERNAL_30s + 1)
+
+#define IDM_CVBSOUT (IDM_TIME_LAPSE_INTERNAL_60s + 1)
+#define IDM_CVBSOUT_OFF (IDM_CVBSOUT + 1)
+#define IDM_CVBSOUT_ON_PAL (IDM_CVBSOUT + 2)
+#define IDM_CVBSOUT_ON_NTSC (IDM_CVBSOUT + 3)
+
+#define IDM_CIFCAMERA (IDM_CVBSOUT_ON_NTSC + 1)
+#define IDM_CIF_1 (IDM_CIFCAMERA + 1)
+#define IDM_CIF_2 (IDM_CIFCAMERA + 2)
+#define IDM_CIF_3 (IDM_CIFCAMERA + 3)
+#define IDM_CIF_4 (IDM_CIFCAMERA + 4)
+
+#define IDM_SETTING_FWUPDATE        (IDM_CIF_4 + 1)
+
+#define IDM_UVC     (IDM_SETTING_FWUPDATE + 1)
+
+#define IDM_FLIP            (IDM_UVC + 1)
+#define IDM_FLIP_OFF            (IDM_FLIP + 1)
+#define IDM_FLIP_ON         (IDM_FLIP_OFF + 1)
+
+#define IDM_DEBUG_FWUPDATE_TEST         (IDM_FLIP_ON + 1)
+
+#define IDM_GPS (IDM_DEBUG_FWUPDATE_TEST + 1)
+#define IDM_GPSOFF (IDM_GPS + 1)
+#define IDM_GPSON (IDM_GPSOFF + 1)
+
+#define FILE_TYPE_UNKNOW 0
+#define FILE_TYPE_PIC 1
+#define FILE_TYPE_VIDEO 2
+
+#define IDC_BUTTON_OK  1000
+#define IDC_STATIC1    1001
+#define IDC_STATIC2    1002
+#define IDC_STATIC3    1003
+#define IDC_STATIC4    1004
+#define IDC_STATIC5    1005
+#define IDC_STATIC6    1006
+#define IDC_STATIC7    1007
+#define IDC_STATIC8    1008
+
+#define FILE_TYPE_MAX 3
+
+#define MSG_INITDIALOG      0x0123
+#define MSG_KEYDOWN         0x0010
+#define MSG_KEYUP           0x0012
+#define MSG_KEYLONGPRESS    0x0016
+
+
+int vui_init_msg();
+int PostMessage(int hWnd, int iMsg, WPARAM wParam, LPARAM lParam);
+#define SendNotifyMessage(x, y, p1, p2) PostMessage(x, y, p1, p2)
+#define SendMessage(x, y, p1, p2) PostMessage(x, y, p1, p2)
+
+bool GetMessage (PMSG pMsg, HWND hWnd);
+bool TranslateMessage (PMSG pMsg);
+int DispatchMessage (PMSG pMsg);
+
+
+
+#define LANGUAGE_NUM	2
+
+#define WS_VISIBLE          0x08000000L
+#define WS_CHILD            0x40000000L
+#define SS_CENTER           0x00000020L
+#define WS_EX_NONE              0x00000000L
+#define CBS_AUTOLOOP            0x0200L
+#define CBS_AUTOSPIN            0x0001L
+#define WS_TABSTOP          0x00010000L
+
+#define HWND_DESKTOP        0
+#define IDC_STATIC    0
+#define IDOK          1
+#define IDCANCEL      2
+#define IDABORT       3
+#define IDRETRY       4
+#define IDIGNORE      5
+#define IDYES         6
+#define IDNO          7
+
+/* timer */
+#define MSG_TIMER           0x0144
+
+typedef bool (* TIMERPROC)(HWND, int, unsigned int);
+bool SetTimerEx(HWND hWnd, int id, unsigned int speed, TIMERPROC timer_proc);
+#define SetTimer(hwnd, id, speed) \
+                SetTimerEx(hwnd, id, speed, NULL)
+int KillTimer (HWND hWnd, int id);
+
+#endif
diff --git a/ueventmonitor/keyboard.c b/ueventmonitor/keyboard.c
new file mode 100755
index 0000000..0e1f1fe
--- /dev/null
+++ b/ueventmonitor/keyboard.c
@@ -0,0 +1,327 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Shunqing Chen <csq@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <stdbool.h>
+#include <signal.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/time.h>
+#include <sys/prctl.h>
+
+#include "keyboard.h"
+
+int kbd_fd;
+static list_declare(g_kbd_reg_list);
+pthread_mutex_t g_kbd_lock;
+int kdb_lock_init = 0;
+static struct alexa_key key_read[MAX_KEY_BUFFERED] = {0};
+
+static void kbd_lock(void)
+{
+	if (!kdb_lock_init) {
+		pthread_mutex_init(&g_kbd_lock, NULL);
+		kdb_lock_init = 1;
+	}
+	pthread_mutex_lock(&g_kbd_lock);
+}
+
+static void kbd_unlock(void)
+{
+	pthread_mutex_unlock(&g_kbd_lock);
+}
+
+int kbd_register(int (*kbd_msg_cb)(int keycode, int keyval, int islongpress))
+{
+	struct kbd_reg_t *kbd_node;
+
+	kbd_node = (struct kbd_reg_t *)malloc(sizeof(struct kbd_reg_t));
+	if (!kbd_node) {
+		printf("%s, malloc reg_node faild\n", __func__);
+		return -1;
+	}
+	memset(kbd_node, 0, sizeof(struct kbd_reg_t));
+	list_init(&kbd_node->list);
+	kbd_node->kbd_msg_cb = kbd_msg_cb;
+
+	kbd_lock();
+	list_add_head(&g_kbd_reg_list, &kbd_node->list);
+	kbd_unlock();
+
+	return 0;
+}
+
+static int kbd_event_open(const char *device)
+{
+	kbd_fd = open(device, O_RDONLY | O_NOCTTY);
+	if (kbd_fd < 0)
+		return -1;
+
+	return kbd_fd;
+}
+
+static void kbd_event_close(void)
+{
+	close(kbd_fd);
+	kbd_fd = -1;
+}
+
+/*
+ * Return the possible modifiers for the keyboard.
+ */
+static void kbd_event_get_modifier_info(int *modifiers)
+{
+	*modifiers = 0; 	/* no modifiers available */
+}
+
+/*
+ * This reads one keystroke from the keyboard, and the current state of
+ * the mode keys (ALT, SHIFT, CTRL).  Returns -1 on error, 0 if no data
+ * is ready, and 1 if data was read.  This is a non-blocking call.
+ */
+static int kbd_event_read(struct input_event *buf, int *modifiers)
+{
+	int cc;
+
+	*modifiers = 0;
+
+	cc=read(kbd_fd, buf, sizeof(*buf));
+	if (cc < 0) {
+		if ((errno != EINTR) && (errno != EAGAIN))
+			return 0;
+		return -1;
+	}
+
+	if (buf->type)
+		return 1;
+
+	return 0;
+}
+
+/* activate_keyboard:
+ *  Put keyboard into the mode we want.
+ */
+static void kbd_event_suspend(void)
+{
+	kbd_event_close();
+}
+
+/* deactivate_keyboard:
+ *  Restore the original keyboard settings.
+ */
+static int kbd_event_resume(void)
+{
+	return kbddev.Open(KBD_INPUT_EVENT);
+}
+
+kbddevice_t kbddev = {
+	kbd_event_open,
+	kbd_event_close,
+	kbd_event_get_modifier_info,
+	kbd_event_read,
+	kbd_event_suspend,
+	kbd_event_resume,
+};
+
+static int keyboard_open(int ch, const char *device)
+{
+	int fd;
+
+	fd = kbddev.Open(device);
+	if (fd < 0)
+		return -1;
+
+	return fd;
+}
+
+static int kbd_wait_event(int which, int maxfd, fd_set *in, fd_set *out,
+		      fd_set *except, struct timeval *timeout)
+{
+	int ret;
+
+	FD_ZERO(in);
+	FD_SET(maxfd, in);
+	ret = select(maxfd + 1, in, NULL, NULL, timeout);
+	if (ret > 0) {
+		if (FD_ISSET(maxfd, in)) {
+			FD_CLR (maxfd, in);
+			return ret;
+		}
+	}
+	if (ret == 0)
+		return ret;
+
+	return -1;
+}
+
+static void kbd_msg_notify(int keycode, int keyvalue, int islongpress)
+{
+	struct listnode *n;
+	struct kbd_reg_t *tmp_n = NULL;
+
+	kbd_lock();
+	if (list_empty(&g_kbd_reg_list)) {
+		kbd_unlock();
+		return;
+	}
+
+	list_for_each(n, &g_kbd_reg_list) {
+		tmp_n = node_to_item(n, struct kbd_reg_t, list);
+		if (tmp_n->kbd_msg_cb)
+			tmp_n->kbd_msg_cb(keycode, keyvalue, islongpress);
+	}
+	kbd_unlock();
+}
+
+static void kbd_replace_oldest_key(int code, struct timeval time)
+{
+	int i;
+	int oldest = 0;
+
+	printf("%s\n", __func__);
+
+	for (i = 1; i < MAX_KEY_BUFFERED; i++) {
+		if ((key_read[i].time.tv_sec < key_read[oldest].time.tv_sec) ||
+		    ((key_read[i].time.tv_sec == key_read[oldest].time.tv_sec) &&
+		    (key_read[i].time.tv_usec < key_read[oldest].time.tv_usec))) {
+		    oldest = i;
+		}
+	}
+
+	i = oldest;
+	kbd_msg_notify(key_read[i].key_code, KBD_VAL_KEY_DOWN, 0);
+	key_read[i].key_code = code;
+	key_read[i].time.tv_sec = time.tv_sec;
+	key_read[i].time.tv_usec = time.tv_usec;
+}
+
+static void kbd_insert_key(int code, struct timeval time)
+{
+	int i;
+
+	for (i = 0; i < MAX_KEY_BUFFERED; i++) {
+		if (!key_read[i].is_key_valid) {
+			key_read[i].key_code = code;
+			key_read[i].time.tv_sec = time.tv_sec;
+			key_read[i].time.tv_usec = time.tv_usec;
+			key_read[i].is_key_valid = 1;
+			kbd_msg_notify(key_read[i].key_code,
+				       KBD_VAL_KEY_DOWN, 0);
+			return;
+		} else if (i == MAX_KEY_BUFFERED - 1) {
+			kbd_replace_oldest_key(code, time);
+		}
+	}
+	return;
+}
+
+static int kbd_remove_key(int code)
+{
+	int i;
+
+	for (i = 0; i < MAX_KEY_BUFFERED; i++) {
+		if (key_read[i].is_key_valid &&
+		    key_read[i].key_code == code)
+			key_read[i].is_key_valid = 0;
+			key_read[i].is_long_press = 0;
+			key_read[i].key_code = 0;
+	}
+
+	kbd_msg_notify(key_read[i].key_code, KBD_VAL_KEY_UP, 0);
+	return;
+}
+
+
+static void kbd_parse_key_event(struct input_event *buf)
+{
+	struct timeval tv_now;
+
+	if (buf->type != 1)
+		return;
+
+	if (buf->value) {
+		gettimeofday(&tv_now, 0);
+		kbd_insert_key(buf->code, tv_now);
+	} else {
+		kbd_remove_key(buf->code);
+	}
+}
+
+static int kbd_clac_delta_time(struct timeval tv_old)
+{
+	struct timeval tv_now, tv_delta;
+	int delta_time;
+
+	gettimeofday(&tv_now, 0);
+
+	tv_delta.tv_sec = tv_now.tv_sec - tv_old.tv_sec;
+	tv_delta.tv_usec = tv_now.tv_usec - tv_old.tv_usec;
+	delta_time = tv_delta.tv_sec * 1000 * 1000 + tv_delta.tv_usec;
+
+	return delta_time;
+}
+
+static int kbd_is_long_key(void)
+{
+	int i;
+	int delta_time;
+
+	for (i = 0; i < MAX_KEY_BUFFERED; i++) {
+		if (key_read[i].is_key_valid) {
+			delta_time = kbd_clac_delta_time(key_read[i].time);
+			if (delta_time >= KBD_LONG_PRESS_US) {
+				key_read[i].is_long_press = 1;
+				kbd_msg_notify(key_read[i].key_code,
+					       KBD_VAL_KEY_DOWN, 1);
+			}
+		}
+	}
+}
+
+static void *kbd_event_monitor_thread(void *arg)
+{
+	fd_set rdfds;
+	struct timeval tv = {0, 0};
+	int ret, select_ret;
+	struct input_event buf;
+	int modifier;
+
+	prctl(PR_SET_NAME, "kbd");
+
+	kbd_fd = keyboard_open(0, KBD_INPUT_EVENT);
+	if (kbd_fd < 0)
+		return NULL;
+
+	while (1) {
+		tv.tv_sec = 1;
+		tv.tv_usec = 0;
+		select_ret = kbd_wait_event(0, kbd_fd, &rdfds, NULL, NULL, &tv);
+		if (select_ret > 0) {
+			ret = kbddev.Read(&buf, &modifier);
+			if (ret > 0)
+                            kbd_parse_key_event(&buf);
+		} else if (select_ret == 0) {
+			kbd_is_long_key();
+		}
+	}
+}
+
+int kbd_init(void)
+{
+	pthread_t tid;
+
+	return pthread_create(&tid, NULL, kbd_event_monitor_thread, NULL);
+}
diff --git a/ueventmonitor/keyboard.h b/ueventmonitor/keyboard.h
new file mode 100755
index 0000000..6d5558b
--- /dev/null
+++ b/ueventmonitor/keyboard.h
@@ -0,0 +1,73 @@
+/**
+ * Copyright (C) 2016 Fuzhou Rockchip Electronics Co., Ltd
+ * author: Shunqing Chen <csq@rock-chips.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __KEYBOARD_H__
+#define __KEYBOARD_H__
+
+#include <cutils/list.h>
+#include <linux/input.h>
+#include <stdio.h>
+#include <stdbool.h>
+
+#define KBD_INPUT_EVENT		"/dev/input/event1"
+
+#define KBD_LONG_PRESS_US	(1000 * 1000)
+#define KBD_ALWAYS_PRESS_US	(3 * 1000 * 1000)
+
+/*  key value */
+#define KBD_VAL_KEY_DOWN	1
+#define KBD_VAL_KEY_UP		2
+
+#define MAX_KEY_BUFFERED	6
+
+/* key code */
+#define KBD_CODE_KEY_UP		0
+#define KBD_CODE_KEY_DOWN	0
+#define KBD_CODE_KEY_OK		0
+#define KBD_CODE_KEY_MODE	0
+#define KBD_CODE_KEY_POWER	0
+#define KBD_CODE_KEY_MENU	0
+#define KBD_CODE_KEY_RESET	0
+#define KBD_CODE_KEY_NUM	0
+#define KBD_CODE_KEY_LOADER	1
+
+struct alexa_key {
+	int key_code;
+	int is_long_press;
+	int is_key_valid;
+	int key_func;
+	struct timeval time;
+};
+
+/* Interface to Keyboard Device Driver*/
+typedef struct _kbddevice {
+	int  (*Open)(const char *dev);
+	void (*Close)(void);
+	void (*GetModifierInfo)(int *modifiers);
+	int  (*Read)(struct input_event *buf, int *modifiers);
+	void (*Suspend) (void);
+	int  (*Resume) (void);
+} kbddevice_t;
+
+struct kbd_reg_t {
+	int (*kbd_msg_cb)(int, int, int);
+	struct listnode list;
+};
+
+extern kbddevice_t kbddev;
+
+int kbd_init(void);
+int kbd_register(int (*kbd_msg_cb)(int keycode, int keyval, int islongpress));
+
+#endif
diff --git a/videoplay.c b/videoplay.c
index 5163d6a..c33d20b 100644
--- a/videoplay.c
+++ b/videoplay.c
@@ -35,7 +35,11 @@
 #include <libswresample/swresample.h>
 
 #include "audio_dev.h"
+#ifdef WITHOUT_UI
+#include "noui/camera_ui_def.h"
+#else
 #include "ui/cvr/camera_ui_def.h"
+#endif
 #include "video_ion_alloc.h"
 #include <cvr_ffmpeg_shared.h>
 #include <mpp/vpu.h>
-- 
1.9.1

