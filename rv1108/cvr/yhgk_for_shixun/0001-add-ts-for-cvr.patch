From aad15672b1a0c46a472a9fe78241dd5b020b60b6 Mon Sep 17 00:00:00 2001
From: lanshh <lsh@rock-chips.com>
Date: Thu, 25 May 2017 09:37:03 +0800
Subject: [PATCH 1/2] add ts for cvr

Signed-off-by: lanshh <lsh@rock-chips.com>
---
 src/ial/RKKeybroad.c | 156 +++++++++++++++++++++++++++++++++++++++++++++------
 1 file changed, 138 insertions(+), 18 deletions(-)
 mode change 100755 => 100644 src/ial/RKKeybroad.c

diff --git a/src/ial/RKKeybroad.c b/src/ial/RKKeybroad.c
old mode 100755
new mode 100644
index 09e7fee..43129fb
--- a/src/ial/RKKeybroad.c
+++ b/src/ial/RKKeybroad.c
@@ -30,6 +30,9 @@
 #include "cliprect.h"
 #include "../include/internals.h"
 
+
+
+
 typedef unsigned int __u32;
 typedef int __s32;
 typedef short __s16;
@@ -54,6 +57,65 @@ static int app_fd = -1;
 static char state[NR_KEYS];
 static int s_enable_appmode;
 
+
+#if 1
+#include "tslib.h"
+enum{
+    TS_TYPE = 1,
+    KEY_TYPE,
+};
+
+typedef struct {
+    unsigned short pressure;
+    unsigned short x;
+    unsigned short y;
+    unsigned short pad;
+} TS_EVENT;
+
+static TS_EVENT ts_event;
+static struct tsdev *ts;
+static int pressure_val_flag = 0;
+static int mouse_x, mouse_y, mouse_button;
+
+typedef struct tagPOS
+{
+	short x;
+	short y;
+	short b;
+} POS;
+
+/************************  Low Level Input Operations **********************/
+/*
+ * Mouse operations -- Event
+ */
+static int mouse_update(void)
+{
+    struct ts_sample samp;
+
+    if (ts_read (ts, &samp, 1) > 0) {
+        if (samp.pressure > 0) {
+            mouse_x = samp.x;
+            mouse_y = samp.y;
+        }
+        mouse_button = (samp.pressure > 0) ? IAL_MOUSE_LEFTBUTTON : 0;
+        return 1;
+    }else{
+        return 0;
+    }
+}
+
+static void mouse_getxy (int* x, int* y)
+{
+    *x = mouse_x;
+    *y = mouse_y;
+}
+
+static int mouse_getbutton(void)
+{
+    return mouse_button;
+}
+
+#endif
 void mg_ial_ioctl(unsigned int cmd, unsigned int value)
 { 
     if (s_enable_appmode) {
@@ -177,6 +239,7 @@ static int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *ex
     int    retvalue = 0;
     fd_set rfds;
     int    fd, e;
+	struct ts_sample sample;
 
     if (!in) {
         in = &rfds;
@@ -204,7 +267,7 @@ static int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *ex
     if( MICE_MODE == s_current_mode) { 
 		int i;
 		for (i = 0; i < MAX_INPUTNUM; i++) {
-	        if (which & IAL_KEYEVENT && kbd_fd[i] >= 0) {
+	        if ((which & (IAL_KEYEVENT | IAL_MOUSEEVENT)) && kbd_fd[i] >= 0) {
 	            fd = kbd_fd[i];
 	            mg_fd_set (fd, in);
 	            if (fd > maxfd) 
@@ -215,15 +278,23 @@ static int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *ex
         e = mg_select (maxfd + 1, in, out, except, timeout) ;
         if (e > 0) {
          	for (i = 0; i < MAX_INPUTNUM; i++) {
-            	/* If data is present on the mouse fd, service it: */
-				kbdevent_id[i] = 0;
-	            fd = kbd_fd[i];
-	            /* If data is present on the keyboard fd, service it: */
-	            if (fd >= 0 && FD_ISSET (fd, in)) {
-	                FD_CLR (fd, in);
-	                retvalue |= IAL_KEYEVENT;
-					kbdevent_id[i] = 1;
-	            }  
+                kbdevent_id[i] = 0;
+                fd = kbd_fd[i];
+                /* If data is present on the mouse fd, service it: */
+                if (fd == ts_fd(ts) && ts != NULL) {
+                    if (fd > 0 && FD_ISSET (fd, in)) {
+                        FD_CLR (fd, in);
+                        retvalue |= IAL_MOUSEEVENT;
+                        return retvalue;
+                    }
+
+                } else {
+                    if (fd >= 0 && FD_ISSET (fd, in)) {
+                        FD_CLR (fd, in);
+                        retvalue |= IAL_KEYEVENT;
+                        kbdevent_id[i] = 1;
+                    }
+                }
          	}
         } else if (e < 0) {        
             return -1;
@@ -286,7 +357,7 @@ static int wait_event (int which, int maxfd, fd_set *in, fd_set *out, fd_set *ex
 static void keyboard_suspend(void)
 {
 	int i;
-	for (i = 0; i < MAX_INPUTNUM; i++) {
+	for (i = 1; i < MAX_INPUTNUM; i++) {
 	    kbddev->Suspends(i);    
 	    kbd_fd[i] = -1;
 	}
@@ -297,7 +368,7 @@ static int keyboard_resume(void)
 	int i;
     memset(state, 0, NR_KEYS);
 	
-	for (i = 0; i < MAX_INPUTNUM; i++) {
+	for (i = 1; i < MAX_INPUTNUM; i++) {
     kbd_fd[i] = kbddev->Resumes (i);
 	    if (kbd_fd[i] < 0) {
 	        fprintf (stderr, "IAL Native Engine: Can not open keyboard!\n");
@@ -324,22 +395,65 @@ static int keyboard_open(int ch, const char *device) {
     return fd;
 }
 
+static int readInputType(char * deviceName){
+    int fd;
+    int readsize;
+    char temp[20];
+
+    fd = open (deviceName, O_RDONLY);
+    if (fd < 0) {
+        return -1;
+    }
+    readsize = read(fd, temp, sizeof(char)*19);
+    temp[readsize] = '\0';
+    close(fd);
+    if (strstr("key",temp) != NULL) {
+        return KEY_TYPE;
+    } else {
+        return TS_TYPE;
+    }
+}
+
 BOOL InitRKInput (INPUT* input, const char* mdev, const char* mtype)
 {
     {
 #       define KBD "/dev/input/event1"
 		int i = 0;
         char keyboard_device[30];
-        //system("mknod "KBD" c 13 64 > /dev/null 2>&1");
-        //kbd_fd = keyboard_open(keyboard_device);
+        char devicename[40];
+        int inputType;
+
         for (i = 0; i < MAX_INPUTNUM; i++) {
-	        sprintf(keyboard_device, "/dev/input/event%d", i);
-			kbd_fd[i] = keyboard_open(i, keyboard_device);
+            sprintf(keyboard_device, "/dev/input/event%d", i);
+            sprintf(devicename, "/sys/class/input/input%d/name", i);
+			inputType = readInputType(devicename);
+			if (inputType == TS_TYPE) {
+			} else if (inputType == KEY_TYPE) {
+			}
+			if(i == 0){
+                ts = ts_open(keyboard_device,0);
+                if(!ts){
+                    perror("ts_open()");
+                    exit(-1);
+                }
+                if(ts_config(ts)){
+                    perror("ts_config()");
+                    exit(-1);
+                }
+                ts_event.x = 0;
+                ts_event.y = 0;
+                ts_event.pressure = 0;
+                mouse_x = 0;
+                mouse_y = 0;
+                mouse_button = 0;
+                kbd_fd[i] = ts_fd(ts);
+            } else {
+                kbd_fd[i] = keyboard_open(i, keyboard_device);
+            }
         }
     }
         s_enable_appmode = 0;
 
-
     if (s_enable_appmode) {
         system("mknod /dev/hidraw0 c 253 0 > /dev/null 2>&1");
         system("mknod /dev/hidraw1 c 253 1 > /dev/null 2>&1");
@@ -361,7 +475,13 @@ BOOL InitRKInput (INPUT* input, const char* mdev, const char* mtype)
     input->resume_keyboard = keyboard_resume;
     input->set_leds = NULL;
 
-    input->wait_event = wait_event; 
+    input->update_mouse = mouse_update;
+    input->get_mouse_xy = mouse_getxy;
+    input->set_mouse_xy = NULL;
+    input->get_mouse_button = mouse_getbutton;
+    input->set_mouse_range = NULL;
+
+    input->wait_event = wait_event;
     return TRUE;
 }
 
-- 
1.9.1

